[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Learn Vim (the Smart Way)",
    "section": "",
    "text": "Preface\nLearn-Vim compiled as quarto book.\nBuilt: 2023-02-04"
  },
  {
    "objectID": "chapters/ch01_starting_vim.md.html#installing",
    "href": "chapters/ch01_starting_vim.md.html#installing",
    "title": "1  Ch01. Starting Vim",
    "section": "1.1 Installing",
    "text": "1.1 Installing\nI won’t go through the detailed instruction how to install Vim on a specific machine. The good news is, most Unix-based computers should come with Vim installed. If not, most distros should have some instructions to install Vim.\nTo download more information about Vim installation process, check out Vim’s official download website or Vim’s official github repository: - Vim website - Vim github"
  },
  {
    "objectID": "chapters/ch01_starting_vim.md.html#the-vim-command",
    "href": "chapters/ch01_starting_vim.md.html#the-vim-command",
    "title": "1  Ch01. Starting Vim",
    "section": "1.2 The Vim Command",
    "text": "1.2 The Vim Command\nNow that you have Vim installed, run this from the terminal:\nvim\nYou should see an intro screen. This is the where you will be working on your new file. Unlike most text editors and IDEs, Vim is a modal editor. If you want to type hello, you need to switch to insert mode with i. Press ihello<Esc> to insert the text hello."
  },
  {
    "objectID": "chapters/ch01_starting_vim.md.html#exiting-vim",
    "href": "chapters/ch01_starting_vim.md.html#exiting-vim",
    "title": "1  Ch01. Starting Vim",
    "section": "1.3 Exiting Vim",
    "text": "1.3 Exiting Vim\nThere are several ways to exit Vim. The most common one is to type:\n:quit\nYou can type :q for short. That command is a command-line mode command (another one of Vim modes). If you type : in normal mode, the cursor will move to the bottom of the screen where you can type some commands. You will learn about the command-line mode later in chapter 15. If you are in insert mode, typing : will literally produce the character : on the screen. In this case, you need to switch back to normal mode. Type <Esc> to switch to normal mode. By the way, you can also return to normal mode from command-line mode by pressing <Esc>. You will notice that you can escape out of several Vim modes back to normal mode by pressing <Esc>."
  },
  {
    "objectID": "chapters/ch01_starting_vim.md.html#saving-a-file",
    "href": "chapters/ch01_starting_vim.md.html#saving-a-file",
    "title": "1  Ch01. Starting Vim",
    "section": "1.4 Saving a File",
    "text": "1.4 Saving a File\nTo save your changes, type:\n:write\nYou can also type :w for short. If this is a new file, you need to give it a name before you can save it. Let’s name it file.txt. Run:\n:w file.txt\nTo save and quit, you can combine the :w and :q commands:\n:wq\nTo quit without saving any changes, add ! after :q to force quit:\n:q!\nThere are other ways to exit Vim, but these are the ones you will use on a daily basis."
  },
  {
    "objectID": "chapters/ch01_starting_vim.md.html#help",
    "href": "chapters/ch01_starting_vim.md.html#help",
    "title": "1  Ch01. Starting Vim",
    "section": "1.5 Help",
    "text": "1.5 Help\nThroughout this guide, I will refer you to various Vim help pages. You can go to the help page by typing :help {some-command} (:h for short). You can pass to the :h command a topic or a command name as an argument. For example, to learn about different ways to quit Vim, type:\n:h write-quit\nHow did I know to search for write-quit? I actually didn’t. I just typed :h, then quit, then <Tab>. Vim displayed relevant keywords to choose from. If you ever need to look up something (I wish Vim can do this…), just type :h and try some keywords, then <Tab>."
  },
  {
    "objectID": "chapters/ch01_starting_vim.md.html#opening-a-file",
    "href": "chapters/ch01_starting_vim.md.html#opening-a-file",
    "title": "1  Ch01. Starting Vim",
    "section": "1.6 Opening a File",
    "text": "1.6 Opening a File\nTo open a file (hello1.txt) on Vim from the terminal, run:\nvim hello1.txt\nYou can also open multiple files at once:\nvim hello1.txt hello2.txt hello3.txt\nVim opens hello1.txt, hello2.txt, and hello3.txt in separate buffers. You will learn about buffers in the next chapter."
  },
  {
    "objectID": "chapters/ch01_starting_vim.md.html#arguments",
    "href": "chapters/ch01_starting_vim.md.html#arguments",
    "title": "1  Ch01. Starting Vim",
    "section": "1.7 Arguments",
    "text": "1.7 Arguments\nYou can pass the vim terminal command with different flags and options.\nTo check the current Vim version, run:\nvim --version\nThis tells you the current Vim version and all available features marked with either + or -. Some of these features in this guide require certain features to be available. For example, you will explore Vim’s command-line history in a later chapter with the :history command. Your Vim needs to have +cmdline_history feature for the command to work. There is a good chance that the Vim you just installed have all the necessary features, especially if it is from a popular download source.\nMany things you do from the terminal can also be done from inside Vim. To see the version from inside Vim, you can run this:\n:version\nIf you want to open the file hello.txt and immediately execute a Vim command, you can pass to the vim command the +{cmd} option.\nIn Vim, you can substitute strings with the :s command (short for :substitute). If you want to open hello.txt and substitute all pancake with bagel, run:\nvim +%s/pancake/bagel/g hello.txt\nThese Vim commands can be stacked:\nvim +%s/pancake/bagel/g +%s/bagel/egg/g +%s/egg/donut/g hello.txt\nVim will replace all instances of pancake with bagel, then replace bagel with egg, then replace egg with donut (you will learn substitution in a later chapter).\nYou can also pass the -c option followed by a Vim command instead of the + syntax:\nvim -c %s/pancake/bagel/g hello.txt\nvim -c %s/pancake/bagel/g -c %s/bagel/egg/g -c %s/egg/donut/g hello.txt"
  },
  {
    "objectID": "chapters/ch01_starting_vim.md.html#opening-multiple-windows",
    "href": "chapters/ch01_starting_vim.md.html#opening-multiple-windows",
    "title": "1  Ch01. Starting Vim",
    "section": "1.8 Opening Multiple Windows",
    "text": "1.8 Opening Multiple Windows\nYou can launch Vim on split horizontal and vertical windows with the -o and -O options, respectively.\nTo open Vim with two horizontal windows, run:\nvim -o2\nTo open Vim with 5 horizontal windows, run:\nvim -o5\nTo open Vim with 5 horizontal windows and fill up the first two with hello1.txt and hello2.txt, run:\nvim -o5 hello1.txt hello2.txt\nTo open Vim with two vertical windows, 5 vertical windows, and 5 vertical windows with 2 files:\nvim -O2\nvim -O5\nvim -O5 hello1.txt hello2.txt"
  },
  {
    "objectID": "chapters/ch01_starting_vim.md.html#suspending",
    "href": "chapters/ch01_starting_vim.md.html#suspending",
    "title": "1  Ch01. Starting Vim",
    "section": "1.9 Suspending",
    "text": "1.9 Suspending\nIf you need to suspend Vim while in the middle of editing, you can press Ctrl-z. You can also run either the :stop or :suspend command. To return to the suspended Vim, run fg from the terminal."
  },
  {
    "objectID": "chapters/ch01_starting_vim.md.html#starting-vim-the-smart-way",
    "href": "chapters/ch01_starting_vim.md.html#starting-vim-the-smart-way",
    "title": "1  Ch01. Starting Vim",
    "section": "1.10 Starting Vim the Smart Way",
    "text": "1.10 Starting Vim the Smart Way\nThe vim command can take many different options, just like any other terminal command. Two options allow you to pass a Vim command as a parameter: +{cmd} and -c cmd. As you learn more commands throughout this guide, see if you can apply it when starting Vim. Also being a terminal command, you can combine vim with many other terminal commands. For example, you can redirect the output of the ls command to be edited in Vim with ls -l | vim -.\nTo learn more about vim command in the terminal, check out man vim. To learn more about the Vim editor, continue reading this guide along with the :help command."
  },
  {
    "objectID": "chapters/ch02_buffers_windows_tabs.md.html#buffers",
    "href": "chapters/ch02_buffers_windows_tabs.md.html#buffers",
    "title": "2  Ch02. Buffers, Windows, and Tabs",
    "section": "2.1 Buffers",
    "text": "2.1 Buffers\nWhat is a buffer?\nA buffer is an in-memory space where you can write and edit some text. When you open a file in Vim, the data is bound to a buffer. When you open 3 files in Vim, you have 3 buffers.\nHave two empty files, file1.js and file2.js available (if possible, create them with Vim). Run this in the terminal:\nvim file1.js\nWhat you are seeing is file1.js buffer. Whenever you open a new file, Vim creates a new buffer.\nExit Vim. This time, open two new files:\nvim file1.js file2.js\nVim currently displays file1.js buffer, but it actually creates two buffers: file1.js buffer and file2.js buffer. Run :buffers to see all the buffers (alternatively, you can use :ls or :files too). You should see both file1.js and file2.js listed. Running vim file1 file2 file3 ... filen creates n amount of buffers. Each time you open a new file, Vim create a new buffer for that file.\nThere are several ways you can traverse buffers: - :bnext to go to the next buffer (:bprevious to go to the previous buffer). - :buffer + filename. Vim can autocomplete filename with <Tab>. - :buffer + n, where n is the buffer number. For example, typing :buffer 2 will take you to buffer #2. - Jump to the older position in the jump list with Ctrl-O and to the newer position with Ctrl-I. These are not buffer specific methods, but they can be used to jump between different buffers. I will explain jumps in further details in Chapter 5. - Go to the previously edited buffer with Ctrl-^.\nOnce Vim creates a buffer, it will remain in your buffers list. To remove it, you can type :bdelete. It can also accept a buffer number as a parameter (:bdelete 3 to delete buffer #3) or a filename (:bdelete then use <Tab> to autocomplete).\nThe hardest thing for me when learning about buffers was visualizing how they worked because my mind was used to windows from when using a mainstream text editor. A good analogy is a deck of playing cards. If I have 2 buffers, I have a stack of 2 cards. The card on top is the only card I see, but I know there are cards below it. If I see file1.js buffer displayed then the file1.js card is on the top of the deck. I can’t see the other card, file2.js here, but it’s there. If I switch buffers to file2.js, that file2.js card is now on the top of the deck and file1.js card is below it.\nIf you haven’t used Vim before, this is a new concept. Take your time to understand it."
  },
  {
    "objectID": "chapters/ch02_buffers_windows_tabs.md.html#exiting-vim",
    "href": "chapters/ch02_buffers_windows_tabs.md.html#exiting-vim",
    "title": "2  Ch02. Buffers, Windows, and Tabs",
    "section": "2.2 Exiting Vim",
    "text": "2.2 Exiting Vim\nBy the way, if you have multiple buffers opened, you can close all of them with quit-all:\n:qall\nIf you want to close without saving your changes, just add ! at the end:\n:qall!\nTo save and quit all, run:\n:wqall"
  },
  {
    "objectID": "chapters/ch02_buffers_windows_tabs.md.html#windows",
    "href": "chapters/ch02_buffers_windows_tabs.md.html#windows",
    "title": "2  Ch02. Buffers, Windows, and Tabs",
    "section": "2.3 Windows",
    "text": "2.3 Windows\nA window is a viewport on a buffer. If you’re coming from a mainstream editor, this concept may be familiar to you. Most text editors have the ability to display multiple windows. In Vim, you can also have multiple windows.\nLet’s open file1.js from the terminal again:\nvim file1.js\nEarlier I wrote that you’re looking at file1.js buffer. While that was correct, that statement was incomplete. You are looking at the file1.js buffer, displayed through a window. A window is how you are viewing a buffer through.\nDon’t quit Vim yet. Run:\n:split file2.js\nNow you are looking at two buffers through two windows. The top window displays file2.js buffer. The bottom window displays file1.js buffer.\nIf you want to navigate between windows, use these shortcuts:\nCtrl-W H    Moves the cursor to the left window\nCtrl-W J    Moves the cursor to the window below\nCtrl-W K    Moves the cursor to the window upper\nCtrl-W L    Moves the cursor to the right window\nNow run:\n:vsplit file3.js\nYou are now seeing three windows displaying three buffers. One window displays file3.js buffer, another window displays file2.js buffer, and another window displays file1.js buffer.\nYou can have multiple windows displaying the same buffer. While you’re on the top left window, type:\n:buffer file2.js\nNow both two windows are displaying file2.js buffer. If you start typing on a file2.js window, you will see that both windows that display file2.js buffers are being updated in real-time.\nTo close the current window, you can run Ctrl-W C or type :quit. When you close a window, the buffer will still be there (run :buffers to confirm this).\nHere are some useful normal-mode window commands:\nCtrl-W V    Opens a new vertical split\nCtrl-W S    Opens a new horizontal split\nCtrl-W C    Closes a window\nCtrl-W O    Makes the current window the only one on screen and closes other windows\nAnd here is a list of useful window command-line commands:\n:vsplit filename    Split window vertically\n:split filename     Split window horizontally\n:new filename       Create new window\nTake your time to understand them. For more information, check out :h window."
  },
  {
    "objectID": "chapters/ch02_buffers_windows_tabs.md.html#tabs",
    "href": "chapters/ch02_buffers_windows_tabs.md.html#tabs",
    "title": "2  Ch02. Buffers, Windows, and Tabs",
    "section": "2.4 Tabs",
    "text": "2.4 Tabs\nA tab is a collection of windows. Think of it like a layout for windows. In most modern text editors (and modern internet browsers), a tab means an open file / page and when you close it, that file / page goes away. In Vim, a tab does not represent an opened file. When you close a tab in Vim, you are not closing a file. You are only closing the layout. The files opened in that layout are still not closed, they are still opened in their buffers.\nLet’s see Vim tabs in action. Open file1.js:\nvim file1.js\nTo open file2.js in a new tab:\n:tabnew file2.js\nYou can also let Vim autocomplete the file you want to open in a new tab by pressing <Tab> (no pun intended).\nBelow is a list of useful tab navigations:\n:tabnew file.txt    Open file.txt in a new tab\n:tabclose           Close the current tab\n:tabnext            Go to next tab\n:tabprevious        Go to previous tab\n:tablast            Go to last tab\n:tabfirst           Go to first tab\nYou can also run gt to go to next tab page (you can go to previous tab with gT). You can pass count as argument to gt, where count is tab number. To go to the third tab, do 3gt.\nOne advantage of having multiple tabs is you can have different window arrangements in different tabs. Maybe you want your first tab to have 3 vertical windows and second tab to have a mixed horizontal and vertical windows layout. Tab is the perfect tool for the job!\nTo start Vim with multiple tabs, you can do this from the terminal:\nvim -p file1.js file2.js file3.js"
  },
  {
    "objectID": "chapters/ch02_buffers_windows_tabs.md.html#moving-in-3d",
    "href": "chapters/ch02_buffers_windows_tabs.md.html#moving-in-3d",
    "title": "2  Ch02. Buffers, Windows, and Tabs",
    "section": "2.5 Moving in 3D",
    "text": "2.5 Moving in 3D\nMoving between windows is like traveling two-dimensionally along the X-Y axis in Cartesian coordinates. You can move to the top, right, bottom, and left window with Ctrl-W H/J/K/L.\nMoving between buffers is like traveling across the Z axis in Cartesian coordinates. Imagine your buffer files lining up across the Z axis. You can traverse the Z axis one buffer at a time with :bnext and :bprevious. You can jump to any coordinate in Z axis with :buffer filename/buffernumber.\nYou can move in three-dimensional space by combining window and buffer movements. You can move to the top, right, bottom, or left window (X-Y navigations) with window movements. Since each window contains buffers, you can move forward and backward (Z navigations) with buffer movements."
  },
  {
    "objectID": "chapters/ch02_buffers_windows_tabs.md.html#using-buffers-windows-and-tabs-the-smart-way",
    "href": "chapters/ch02_buffers_windows_tabs.md.html#using-buffers-windows-and-tabs-the-smart-way",
    "title": "2  Ch02. Buffers, Windows, and Tabs",
    "section": "2.6 Using Buffers, Windows, and Tabs the Smart Way",
    "text": "2.6 Using Buffers, Windows, and Tabs the Smart Way\nYou have learned what buffers, windows, and tabs are and how they work in Vim. Now that you understand them better, you can use them in your own workflow.\nEveryone has a different workflow, here is mine for example: - First, I use buffers to store all the required files for the current task. Vim can handle many opened buffers before it starts slowing down. Plus having many buffers opened won’t crowd my screen. I am only seeing one buffer (assuming I only have one window) at any time, allowing me to focus on one screen. When I need to go somewhere, I can quickly fly to any open buffer anytime. - I use multiple windows to view multiple buffers at once, usually when diffing files, reading docs, or following a code flow. I try to keep the number of windows opened to no more than three because my screen will get crowded (I use a small laptop). When I am done, I close any extra windows. Fewer windows means less distractions. - Instead of tabs, I use tmux windows. I usually use multiple tmux windows at once. For example, one tmux window for client-side codes and another for backend codes.\nMy workflow may look different from yours based on your editing style and that’s fine. Experiment around to discover your own flow, suiting your coding style."
  },
  {
    "objectID": "chapters/ch03_searching_files.md.html#opening-and-editing-files",
    "href": "chapters/ch03_searching_files.md.html#opening-and-editing-files",
    "title": "3  Ch03. Searching Files",
    "section": "3.1 Opening and Editing Files",
    "text": "3.1 Opening and Editing Files\nTo open a file in Vim, you can use :edit.\n:edit file.txt\nIf file.txt exists, it opens the file.txt buffer. If file.txt doesn’t exist, it creates a new buffer for file.txt.\nAutocomplete with <Tab> works with :edit. For example, if your file is inside a Rails app controller users controller directory ./app/controllers/users_controllers.rb, you can use <Tab> to expand the terms quickly:\n:edit a<Tab>c<Tab>u<Tab>\n:edit accepts wildcards arguments. * matches any file in the current directory. If you are only looking for files with .yml extension in the current directory:\n:edit *.yml<Tab>\nVim will give you a list of all .yml files in the current directory to choose from.\nYou can use ** to search recursively. If you want to look for all *.md files in your project, but you are not sure in which directories, you can do this:\n:edit **/*.md<Tab>\n:edit can be used to run netrw, Vim’s built-in file explorer. To do that, give :edit a directory argument instead of file:\n:edit .\n:edit test/unit/"
  },
  {
    "objectID": "chapters/ch03_searching_files.md.html#searching-files-with-find",
    "href": "chapters/ch03_searching_files.md.html#searching-files-with-find",
    "title": "3  Ch03. Searching Files",
    "section": "3.2 Searching Files With Find",
    "text": "3.2 Searching Files With Find\nYou can find files with :find. For example:\n:find package.json\n:find app/controllers/users_controller.rb\nAutocomplete also works with :find:\n:find p<Tab>                \" to find package.json\n:find a<Tab>c<Tab>u<Tab>    \" to find app/controllers/users_controller.rb\nYou may notice that :find looks like :edit. What’s the difference?"
  },
  {
    "objectID": "chapters/ch03_searching_files.md.html#find-and-path",
    "href": "chapters/ch03_searching_files.md.html#find-and-path",
    "title": "3  Ch03. Searching Files",
    "section": "3.3 Find and Path",
    "text": "3.3 Find and Path\nThe difference is that :find finds file in path, :edit doesn’t. Let’s learn a little bit about path. Once you learn how to modify your paths, :find can become a powerful searching tool. To check what your paths are, do:\n:set path?\nBy default, yours probably look like this:\npath=.,/usr/include,,\n\n. means to search in the directory of the currently opened file.\n, means to search in the current directory.\n/usr/include is the typical directory for C libraries header files.\n\nThe first two are important in our context and the third one can be ignored for now. The takeaway here is that you can modify your own paths, where Vim will look for files. Let’s assume this is your project structure:\napp/\n  assets/\n  controllers/\n    application_controller.rb\n    comments_controller.rb\n    users_controller.rb\n    ...\nIf you want to go to users_controller.rb from the root directory, you have to go through several directories (and pressing a considerable amount of tabs). Often when working with a framework, you spend 90% of your time in a particular directory. In this situation, you only care about going to the controllers/ directory with the least amount of keystrokes. The path setting can shorten that journey.\nYou need to add the app/controllers/ to the current path. Here is how you can do it:\n:set path+=app/controllers/\nNow that your path is updated, when you type :find u<Tab>, Vim will now search inside app/controllers/ directory for files starting with u.\nIf you have a nested controllers/ directory, like app/controllers/account/users_controller.rb, Vim won’t find users_controllers. Instead, you need to add :set path+=app/controllers/** in order for autocompletion will find users_controller.rb. This is great! Now you can find the users controller with 1 press of tab instead of 3.\nYou might be thinking to add the entire project directories so when you press tab, Vim will search everywhere for that file, like this:\n:set path+=$PWD/**\n$PWD is the current working directory. If you try to add your entire project to path hoping to make all files reachable upon a tab press, although this may work for a small project, doing this will slow down your search significantly if you have a large number of files in your project. I recommend adding only the path of your most visited files / directories.\nYou can add the set path+={your-path-here} in your vimrc. Updating path takes only a few seconds and doing so can save you a lot of time."
  },
  {
    "objectID": "chapters/ch03_searching_files.md.html#searching-in-files-with-grep",
    "href": "chapters/ch03_searching_files.md.html#searching-in-files-with-grep",
    "title": "3  Ch03. Searching Files",
    "section": "3.4 Searching in Files With Grep",
    "text": "3.4 Searching in Files With Grep\nIf you need to find in files (find phrases in files), you can use grep. Vim has two ways of doing that:\n\nInternal grep (:vim. Yes, it is spelled :vim. It is short for :vimgrep).\nExternal grep (:grep).\n\nLet’s go through internal grep first. :vim has the following syntax:\n:vim /pattern/ file\n\n/pattern/ is a regex pattern of your search term.\nfile is the file argument. You can pass multiple arguments. Vim will search for the pattern inside the file argument. Similar to :find, you can pass it * and ** wildcards.\n\nFor example, to look for all occurrences of breakfast string inside all ruby files (.rb) inside app/controllers/ directory:\n:vim /breakfast/ app/controllers/**/*.rb\nAfter running that, you will be redirected to the first result. Vim’s vim search command uses quickfix operation. To see all search results, run :copen. This opens a quickfix window. Here are some useful quickfix commands to get you productive immediately:\n:copen        Open the quickfix window\n:cclose       Close the quickfix window\n:cnext        Go to the next error\n:cprevious    Go to the previous error\n:colder       Go to the older error list\n:cnewer       Go to the newer error list\nTo learn more about quickfix, check out :h quickfix.\nYou may notice that running internal grep (:vim) can get slow if you have a large number of matches. This is because Vim loads each matching file into memory, as if it were being edited. If Vim finds a large number of files matching your search, it will load them all and therefore consume a large amount of memory.\nLet’s talk about external grep. By default, it uses grep terminal command. To search for lunch inside a ruby file inside app/controllers/ directory, you can do this:\n:grep -R \"lunch\" app/controllers/\nNote that instead of using /pattern/, it follows the terminal grep syntax \"pattern\". It also displays all matches using quickfix.\nVim defines the grepprg variable to determine which external program to run when running the :grep Vim command so that you don’t have to close Vim and invoke the terminal grep command. Later, I will show you how to change the default program invoked when using the :grep Vim command."
  },
  {
    "objectID": "chapters/ch03_searching_files.md.html#browsing-files-with-netrw",
    "href": "chapters/ch03_searching_files.md.html#browsing-files-with-netrw",
    "title": "3  Ch03. Searching Files",
    "section": "3.5 Browsing Files With Netrw",
    "text": "3.5 Browsing Files With Netrw\nnetrw is Vim’s built-in file explorer. It is useful to see a project’s hierarchy. To run netrw, you need these two settings in your .vimrc:\nset nocp\nfiletype plugin on\nSince netrw is a vast topic, I will only cover the basic usage, but it should be enough to get you started. You can start netrw when you launch Vim by passing it a directory as a parameter instead of a file. For example:\nvim .\nvim src/client/\nvim app/controllers/\nTo launch netrw from inside Vim, you can use the :edit command and pass it a directory parameter instead of a filename:\n:edit .\n:edit src/client/\n:edit app/controllers/\nThere are other ways to launch netrw window without passing a directory:\n:Explore     Starts netrw on current file\n:Sexplore    No kidding. Starts netrw on split top half of the screen\n:Vexplore    Starts netrw on split left half of the screen\nYou can navigate netrw with Vim motions (motions will be covered in depth in a later chapter). If you need to create, delete, or rename a file or directory, here is a list of useful netrw commands:\n%    Create a new file\nd    Create a new directory\nR    Rename a file or directory\nD    Delete a file or directory\n:h netrw is very comprehensive. Check it out if you have time.\nIf you find netrw too bland and need more flavor, vim-vinegar is a good plugin to improve netrw. If you’re looking for a different file explorer, NERDTree is a good alternative. Check them out!"
  },
  {
    "objectID": "chapters/ch03_searching_files.md.html#fzf",
    "href": "chapters/ch03_searching_files.md.html#fzf",
    "title": "3  Ch03. Searching Files",
    "section": "3.6 Fzf",
    "text": "3.6 Fzf\nNow that you’ve learned how to search files in Vim with built-in tools, let’s learn how to do it with plugins.\nOne thing that modern text editors get right and that Vim didn’t is how easy it is to find files, especially via fuzzy search. In this second half of the chapter, I will show you how to use fzf.vim to make searching in Vim easy and powerful."
  },
  {
    "objectID": "chapters/ch03_searching_files.md.html#setup",
    "href": "chapters/ch03_searching_files.md.html#setup",
    "title": "3  Ch03. Searching Files",
    "section": "3.7 Setup",
    "text": "3.7 Setup\nFirst, make sure you have fzf and ripgrep downloaded. Follow the instruction on their github repo. The commands fzf and rg should now be available after successful installs.\nRipgrep is a search tool much like grep (hence the name). It is generally faster than grep and has many useful features. Fzf is a general-purpose command-line fuzzy finder. You can use it with any commands, including ripgrep. Together, they make a powerful search tool combination.\nFzf does not use ripgrep by default, so we need to tell fzf to use ripgrep by defining a FZF_DEFAULT_COMMAND variable. In my .zshrc (.bashrc if you use bash), I have these:\nif type rg &> /dev/null; then\n  export FZF_DEFAULT_COMMAND='rg --files'\n  export FZF_DEFAULT_OPTS='-m'\nfi\nPay attention to -m in FZF_DEFAULT_OPTS. This option allows us to make multiple selections with <Tab> or <Shift-Tab>. You don’t need this line to make fzf work with Vim, but I think it is a useful option to have. It will come in handy when you want to perform search and replace in multiple files which I’ll cover in just a little. The fzf command accepts many more options, but I won’t cover them here. To learn more, check out fzf’s repo or man fzf. At minimum you should have export FZF_DEFAULT_COMMAND='rg'.\nAfter installing fzf and ripgrep, let’s set up the fzf plugin. I am using vim-plug plugin manager in this example, but you can use any plugin managers.\nAdd these inside your .vimrc plugins. You need to use fzf.vim plugin (created by the same fzf author).\ncall plug#begin()\nPlug 'junegunn/fzf.vim'\nPlug 'junegunn/fzf', { 'do': { -> fzf#install() } }\ncall plug#end()\nAfter adding these lines, you will need to open vim and run :PlugInstall. It will install all plugins that are defined in your vimrc file and are not installed. In our case, it will install fzf.vim and fzf.\nFor more info about this plugin, you can check out fzf.vim repo."
  },
  {
    "objectID": "chapters/ch03_searching_files.md.html#fzf-syntax",
    "href": "chapters/ch03_searching_files.md.html#fzf-syntax",
    "title": "3  Ch03. Searching Files",
    "section": "3.8 Fzf Syntax",
    "text": "3.8 Fzf Syntax\nTo use fzf efficiently, you should learn some basic fzf syntax. Fortunately, the list is short:\n\n^ is a prefix exact match. To search for a phrase starting with welcome: ^welcome.\n$ is a suffix exact match. To search for a phrase ending with my friends: friends$.\n' is an exact match. To search for the phrase welcome my friends: 'welcome my friends.\n| is an or match. To search for either friends or foes: friends | foes.\n! is an inverse match. To search for phrase containing welcome and not friends: welcome !friends\n\nYou can mix and match these options. For example, ^hello | ^welcome friends$ will search for the phrase starting with either welcome or hello and ending with friends."
  },
  {
    "objectID": "chapters/ch03_searching_files.md.html#finding-files",
    "href": "chapters/ch03_searching_files.md.html#finding-files",
    "title": "3  Ch03. Searching Files",
    "section": "3.9 Finding Files",
    "text": "3.9 Finding Files\nTo search for files inside Vim using fzf.vim plugin, you can use the :Files method. Run :Files from Vim and you will be prompted with fzf search prompt.\nSince you will be using this command frequently, it is good to have this mapped to a keyboard shortcut. I map mine to Ctrl-f. In my vimrc, I have this:\nnnoremap <silent> <C-f> :Files<CR>"
  },
  {
    "objectID": "chapters/ch03_searching_files.md.html#finding-in-files",
    "href": "chapters/ch03_searching_files.md.html#finding-in-files",
    "title": "3  Ch03. Searching Files",
    "section": "3.10 Finding in Files",
    "text": "3.10 Finding in Files\nTo search inside files, you can use the :Rg command.\nAgain, since you will probably use this frequently, let’s map it to a keyboard shortcut. I map mine to <Leader>f. The <Leader> key is mapped to \\ by default.\nnnoremap <silent> <Leader>f :Rg<CR>"
  },
  {
    "objectID": "chapters/ch03_searching_files.md.html#other-searches",
    "href": "chapters/ch03_searching_files.md.html#other-searches",
    "title": "3  Ch03. Searching Files",
    "section": "3.11 Other Searches",
    "text": "3.11 Other Searches\nFzf.vim provides many other search commands. I won’t go through each one of them here, but you can check them out here.\nHere’s what my fzf maps look like:\nnnoremap <silent> <Leader>b :Buffers<CR>\nnnoremap <silent> <C-f> :Files<CR>\nnnoremap <silent> <Leader>f :Rg<CR>\nnnoremap <silent> <Leader>/ :BLines<CR>\nnnoremap <silent> <Leader>' :Marks<CR>\nnnoremap <silent> <Leader>g :Commits<CR>\nnnoremap <silent> <Leader>H :Helptags<CR>\nnnoremap <silent> <Leader>hh :History<CR>\nnnoremap <silent> <Leader>h: :History:<CR>\nnnoremap <silent> <Leader>h/ :History/<CR>"
  },
  {
    "objectID": "chapters/ch03_searching_files.md.html#replacing-grep-with-rg",
    "href": "chapters/ch03_searching_files.md.html#replacing-grep-with-rg",
    "title": "3  Ch03. Searching Files",
    "section": "3.12 Replacing Grep With Rg",
    "text": "3.12 Replacing Grep With Rg\nAs mentioned earlier, Vim has two ways to search in files: :vim and :grep. :grep uses external search tool that you can reassign using the grepprg keyword. I will show you how to configure Vim to use ripgrep instead of terminal grep when running the :grep command.\nNow let’s setup grepprg so that the :grep Vim command uses ripgrep. Add this in your vimrc:\nset grepprg=rg\\ --vimgrep\\ --smart-case\\ --follow\nFeel free to modify some of the options above! For more information on what the options above mean, check out man rg.\nAfter you updated grepprg, now when you run :grep, it runs rg --vimgrep --smart-case --follow instead of grep. If you want to search for donut using ripgrep, you can now run a more succinct command :grep \"donut\" instead of :grep \"donut\" . -R\nJust like the old :grep, this new :grep also uses quickfix to display results.\nYou might wonder, “Well, this is nice but I never used :grep in Vim, plus can’t I just use :Rg to find phrases in files? When will I ever need to use :grep?\nThat is a very good question. You may need to use :grep in Vim to do search and replace in multiple files, which I will cover next."
  },
  {
    "objectID": "chapters/ch03_searching_files.md.html#search-and-replace-in-multiple-files",
    "href": "chapters/ch03_searching_files.md.html#search-and-replace-in-multiple-files",
    "title": "3  Ch03. Searching Files",
    "section": "3.13 Search and Replace in Multiple Files",
    "text": "3.13 Search and Replace in Multiple Files\nModern text editors like VSCode makes it very easy to search and replace a string across multiple files. In this section, I will show you two different methods to easily do that in Vim.\nThe first method is to replace all matching phrases in your project. You will need to use :grep. If you want to replace all instances of pizza with donut, here’s what you do:\n:grep \"pizza\"\n:cfdo %s/pizza/donut/g | update\nLet’s break down the commands:\n\n:grep pizza uses ripgrep to search for all instances of pizza (by the way, this would still work even if you didn’t reassign grepprg to use ripgrep. You would have to do :grep \"pizza\" . -R instead of :grep \"pizza\").\n:cfdo executes any command you pass to all files in your quickfix list. In this case, your command is the substitution command %s/pizza/donut/g. The pipe (|) is a chain operator. The update command saves each file after substitution. I will cover the substitute command in more depth in a later chapter.\n\nThe second method is to search and replace in selected files. With this method, you can manually choose which files you want to perform select-and-replace on. Here is what you do:\n\nClear your buffers first. It is imperative that your buffer list contains only the files you want to apply the replace on. You can either restart Vim or run :%bd | e# command (%bd deletes all the buffers and e# opens the file you were just on).\nRun :Files.\nSelect all files you want to perform search-and-replace on. To select multiple files, use <Tab> / <Shift-Tab>. This is only possible if you have the multiple flag (-m) in FZF_DEFAULT_OPTS.\nRun :bufdo %s/pizza/donut/g | update. The command :bufdo %s/pizza/donut/g | update looks similar to the earlier :cfdo %s/pizza/donut/g | update command. The difference is instead of substituting all quickfix entries (:cfdo), you are substituting all buffer entries (:bufdo)."
  },
  {
    "objectID": "chapters/ch03_searching_files.md.html#learn-search-the-smart-way",
    "href": "chapters/ch03_searching_files.md.html#learn-search-the-smart-way",
    "title": "3  Ch03. Searching Files",
    "section": "3.14 Learn Search the Smart Way",
    "text": "3.14 Learn Search the Smart Way\nSearching is the bread-and-butter of text editing. Learning how to search well in Vim will improve your text editing workflow significantly.\nFzf.vim is a game-changer. I can’t imagine using Vim without it. I think it is very important to have a good search tool when starting Vim. I’ve seen people struggling to transition to Vim because it seems to be missing critical features modern text editors have, like an easy and powerful search feature. I hope this chapter will help you to make the transition to Vim easier.\nYou also just saw Vim’s extensibility in action - the ability to extend search functionality with a plugin and an external program. In the future, keep in mind of what other features you wish to extend Vim with. Chances are, it’s already in Vim, someone has created a plugin or there is a program for it already. Next, you’ll learn about a very important topic in Vim: Vim grammar."
  },
  {
    "objectID": "chapters/ch04_vim_grammar.md.html#how-to-learn-a-language",
    "href": "chapters/ch04_vim_grammar.md.html#how-to-learn-a-language",
    "title": "4  Ch04. Vim Grammar",
    "section": "4.1 How to Learn a Language",
    "text": "4.1 How to Learn a Language\nI am not a native English speaker. I learned English when I was 13 when I moved to the US. There are three things you need to do to learn to speak a new language:\n\nLearn grammar rules.\nIncrease vocabulary.\nPractice, practice, practice.\n\nLikewise, to speak Vim language, you need to learn the grammar rules, increase vocabulary, and practice until you can run the commands without thinking."
  },
  {
    "objectID": "chapters/ch04_vim_grammar.md.html#grammar-rule",
    "href": "chapters/ch04_vim_grammar.md.html#grammar-rule",
    "title": "4  Ch04. Vim Grammar",
    "section": "4.2 Grammar Rule",
    "text": "4.2 Grammar Rule\nThere is only one grammar rule in Vim language:\nverb + noun\nThat’s it!\nThis is like saying these English phrases:\n\nEat (verb) a donut (noun)\nKick (verb) a ball (noun)\nLearn (verb) the Vim editor (noun)\n\nNow you need to build up your vocabulary with basic Vim verbs and nouns."
  },
  {
    "objectID": "chapters/ch04_vim_grammar.md.html#nouns-motions",
    "href": "chapters/ch04_vim_grammar.md.html#nouns-motions",
    "title": "4  Ch04. Vim Grammar",
    "section": "4.3 Nouns (Motions)",
    "text": "4.3 Nouns (Motions)\nNouns are Vim motions. Motions are used to move around in Vim. Below is a list of some of Vim motions:\nh    Left\nj    Down\nk    Up\nl    Right\nw    Move forward to the beginning of the next word\n}    Jump to the next paragraph\n$    Go to the end of the line\nYou will learn more about motions in the next chapter, so don’t worry too much if you don’t understand some of them."
  },
  {
    "objectID": "chapters/ch04_vim_grammar.md.html#verbs-operators",
    "href": "chapters/ch04_vim_grammar.md.html#verbs-operators",
    "title": "4  Ch04. Vim Grammar",
    "section": "4.4 Verbs (Operators)",
    "text": "4.4 Verbs (Operators)\nAccording to :h operator, Vim has 16 operators. However, in my experience, learning these 3 operators is enough for 80% of my editing needs:\ny    Yank text (copy)\nd    Delete text and save to register\nc    Delete text, save to register, and start insert mode\nBtw, after you yank a text, you can paste it with p (after the cursor) or P (before the cursor)."
  },
  {
    "objectID": "chapters/ch04_vim_grammar.md.html#verb-and-noun",
    "href": "chapters/ch04_vim_grammar.md.html#verb-and-noun",
    "title": "4  Ch04. Vim Grammar",
    "section": "4.5 Verb and Noun",
    "text": "4.5 Verb and Noun\nNow that you know basic nouns and verbs, let’s apply the grammar rule, verb + noun! Suppose you have this expression:\nconst learn = \"vim\";\n\nTo yank everything from your current location to the end of the line: y$.\nTo delete from your current location to the beginning of the next word: dw.\nTo change from your current location to the end of the current paragraph, say c}.\n\nMotions also accept count number as arguments (I will discuss this in the next chapter). If you need to go up 3 lines, instead of pressing k 3 times, you can do 3k. Count works with Vim grammar. - To yank two characters to the left: y2h. - To delete the next two words: d2w. - To change the next two lines: c2j.\nRight now, you may have to think long and hard to execute even a simple command. You’re not alone. When I first started, I had similar struggles but I got faster in time. So will you. Repetition, repetition, repetition.\nAs a side note, linewise operations (operations affecting the entire line) are common operations in text editing. In general, by typing an operator command twice, Vim performs a linewise operation for that action. For example, dd, yy, and cc perform deletion, yank, and change on the entire line. Try this with other operators!\nThis is really cool. I am seeing a pattern here. But I am not quite done yet. Vim has one more type of noun: text objects."
  },
  {
    "objectID": "chapters/ch04_vim_grammar.md.html#more-nouns-text-objects",
    "href": "chapters/ch04_vim_grammar.md.html#more-nouns-text-objects",
    "title": "4  Ch04. Vim Grammar",
    "section": "4.6 More Nouns (Text Objects)",
    "text": "4.6 More Nouns (Text Objects)\nImagine you are somewhere inside a pair of parentheses like (hello Vim) and you need to delete the entire phrase inside the parentheses. How can you quickly do it? Is there a way to delete the group you are inside of?\nThe answer is yes. Texts often come structured. They often contain parentheses, quotes, brackets, braces, and more. Vim has a way to capture this structure with text objects.\nText objects are used with operators. There are two types of text objects: inner and outer text objects.\ni + object    Inner text object\na + object    Outer text object\nInner text object selects the object inside without the white space or the surrounding objects. Outer text object selects the object inside including the white space or the surrounding objects. Generally, an outer text object always selects more text than an inner text object. If your cursor is somewhere inside the parentheses in the expression (hello Vim): - To delete the text inside the parentheses without deleting the parentheses: di(. - To delete the parentheses and the text inside: da(.\nLet’s look at a different example. Suppose you have this Javascript function and your cursor is on the H in Hello:\nconst hello = function() {\n  console.log(\"Hello Vim\");\n  return true;\n}\n\nTo delete the entire Hello Vim: di(.\nTo delete the content of function (surrounded by {}): di{.\nTo delete the Hello string: diw.\n\nText objects are powerful because you can target different objects from one location. You can delete the objects inside the parentheses, the function block, or the current word. Mnemonically, when you see di(, di{, and diw, you get a pretty good idea which text objects they represent: a pair of parentheses, a pair of braces, and a word.\nLet’s look at one last example. Suppose you have these HTML tags:\n<div>\n  <h1>Header1</h1>\n  <p>Paragraph1</p>\n  <p>Paragraph2</p>\n</div>\nIf your cursor is on Header1 text: - To delete Header1: dit. - To delete <h1>Header1</h1>: dat.\nIf your cursor is on div: - To delete h1 and both p lines: dit. - To delete everything: dat. - To delete div: di<.\nBelow is a list of common text objects:\nw         A word\np         A paragraph\ns         A sentence\n( or )    A pair of ( )\n{ or }    A pair of { }\n[ or ]    A pair of [ ]\n< or >    A pair of < >\nt         XML tags\n\"         A pair of \" \"\n'         A Pair of ' '\n`         A pair of ` `\nTo learn more, check out :h text-objects."
  },
  {
    "objectID": "chapters/ch04_vim_grammar.md.html#composability-and-grammar",
    "href": "chapters/ch04_vim_grammar.md.html#composability-and-grammar",
    "title": "4  Ch04. Vim Grammar",
    "section": "4.7 Composability and Grammar",
    "text": "4.7 Composability and Grammar\nVim grammar is subset of Vim’s composability feature. Let’s discuss composability in Vim and why this is a great feature to have in a text editor.\nComposability means having a set of general commands that can be combined (composed) to perform more complex commands. Just like in programming where you can create more complex abstractions from simpler abstractions, in Vim you can execute complex commands from simpler commands. Vim grammar is the manifestation of Vim’s composable nature.\nThe true power of Vim’s composability shines when it integrates with external programs. Vim has a filter operator (!) to use external programs as filters for our texts. Suppose you have this messy text below and you want to tabularize it:\nId|Name|Cuteness\n01|Puppy|Very\n02|Kitten|Ok\n03|Bunny|Ok\nThis cannot be easily done with Vim commands, but you can get it done quickly with column terminal command (assuming your terminal has column command). With your cursor on Id, run !}column -t -s \"|\". Voila! Now you have this pretty tabular data with just one quick command.\nId  Name    Cuteness\n01  Puppy   Very\n02  Kitten  Ok\n03  Bunny   Ok\nLet’s break down the command. The verb was ! (filter operator) and the noun was } (go to next paragraph). The filter operator ! accepted another argument, a terminal command, so I gave it column -t -s \"|\". I won’t go through how column worked, but in effect, it tabularized the text.\nSuppose you want to not only tabularize your text, but to display only the rows with Ok. You know that awk can do the job easily. You can do this instead:\n!}column -t -s \"|\" | awk 'NR > 1 && /Ok/ {print $0}'\nResult:\n02  Kitten  Ok\n03  Bunny   Ok\nGreat! The external command operator can also use pipe (|).\nThis is the power of Vim’s composability. The more you know your operators, motions, and terminal commands, your ability to compose complex actions is multiplied.\nSuppose you only know four motions, w, $, }, G and only one operator, d. You can do 8 actions: move 4 different ways (w, $, }, G) and delete 4 different targets (dw, d$, d}, dG). Then one day you learn about the uppercase (gU) operator. You have added not just one new ability to your Vim tool belt, but four: gUw, gU$, gU}, gUG. This makes at 12 tools in your Vim tool belt. Each new knowledge is a multiplier to your current abilities. If you know 10 motions and 5 operators, you have 60 moves (50 operations + 10 motions) in your arsenal. Vim has a line-number motion (nG) that gives you n motions, where n is how many lines you have in your file (to go to line 5, run 5G). The search motion (/) practically gives you near unlimited number motions because you can search for anything. External command operator (!) gives you as many filtering tools as the number of terminal commands you know. Using a composable tool like Vim, everything you know can be linked together to do operations with increasing complexity. The more you know, the more powerful you become.\nThis composable behavior echoes Unix philosophy: do one thing well. An operator has one job: do Y. A motion has one job: go to X. By combining an operator with a motion, you predictably get YX: do Y on X.\nMotions and operators are extendable. You can create custom motions and operators to add to your Vim toolbelt. The vim-textobj-user plugin allows you to create your own text objects. It also contains a list of user-made custom text objects."
  },
  {
    "objectID": "chapters/ch04_vim_grammar.md.html#learn-vim-grammar-the-smart-way",
    "href": "chapters/ch04_vim_grammar.md.html#learn-vim-grammar-the-smart-way",
    "title": "4  Ch04. Vim Grammar",
    "section": "4.8 Learn Vim Grammar the Smart Way",
    "text": "4.8 Learn Vim Grammar the Smart Way\nYou just learned about Vim grammar’s rule: verb + noun. One of my biggest Vim AHA! moment was when I had just learned about the uppercase (gU) operator and wanted to uppercase the current word, I instinctively ran gUiw and it worked! The word was uppercased. At that moment, I finally began to understand Vim. My hope is that you will have your own AHA! moment soon, if not already.\nThe goal of this chapter is to show you the verb + noun pattern in Vim so you will approach learning Vim like learning a new language instead of memorizing every command combination.\nLearn the pattern and understand the implications. That’s the smart way to learn."
  },
  {
    "objectID": "chapters/ch05_moving_in_file.md.html#character-navigation",
    "href": "chapters/ch05_moving_in_file.md.html#character-navigation",
    "title": "5  Ch05. Moving in a File",
    "section": "5.1 Character Navigation",
    "text": "5.1 Character Navigation\nThe most basic motion unit is moving one character left, down, up, and right.\nh   Left\nj   Down\nk   Up\nl   Right\ngj  Down in a soft-wrapped line\ngk  Up in a soft-wrapped line\nYou can also move with directional arrows. If you are just starting, feel free to use any method you’re most comfortable with.\nI prefer hjkl because my right hand can stay in the home row. Doing this gives me shorter reach to surrounding keys. To get used to hjkl, I actually disabled the arrow buttons when starting out by adding these in ~/.vimrc:\nnoremap <Up> <NOP>\nnoremap <Down> <NOP>\nnoremap <Left> <NOP>\nnoremap <Right> <NOP>\nThere are also plugins to help break this bad habit. One of them is vim-hardtime. To my surprise, it took me less than a week to get used to hjkl.\nIf you wonder why Vim uses hjkl to move, this is because Lear-Siegler ADM-3A terminal where Bill Joy wrote Vi, didn’t have arrow keys and used hjkl as left/down/up/right.*"
  },
  {
    "objectID": "chapters/ch05_moving_in_file.md.html#relative-numbering",
    "href": "chapters/ch05_moving_in_file.md.html#relative-numbering",
    "title": "5  Ch05. Moving in a File",
    "section": "5.2 Relative Numbering",
    "text": "5.2 Relative Numbering\nI think it is helpful to have number and relativenumber set. You can do it by having this on .vimrc:\nset relativenumber number\nThis displays my current line number and relative line numbers.\nIt is easy why having a number on the left column is useful, but some of you may ask how having relative numbers on the left column may be useful. Having a relative number allows me to quickly see how many lines apart my cursor is from the target text. With this, I can easily spot that my target text is 12 lines below me so I can do d12j to delete them. Otherwise, if I’m on line 69 and my target is on line 81, I have to do mental calculation (81 - 69 = 12). Doing math while editing takes too much mental resources. The less I have to think about where I need to go, the better.\nThis is 100% personal preference. Experiment with relativenumber / norelativenumber, number / nonumber and use whatever you find most useful!"
  },
  {
    "objectID": "chapters/ch05_moving_in_file.md.html#count-your-move",
    "href": "chapters/ch05_moving_in_file.md.html#count-your-move",
    "title": "5  Ch05. Moving in a File",
    "section": "5.3 Count Your Move",
    "text": "5.3 Count Your Move\nLet’s talk about the count argument. Vim motions accept a preceding numerical argument. I mentioned above that you can go down 12 lines with 12j. The 12 in 12j is the count number.\nThe syntax to use count with your motion is:\n[count] + motion\nYou can apply this to all motions. If you want to move 9 characters to the right, instead of pressing l 9 times, you can do 9l."
  },
  {
    "objectID": "chapters/ch05_moving_in_file.md.html#word-navigation",
    "href": "chapters/ch05_moving_in_file.md.html#word-navigation",
    "title": "5  Ch05. Moving in a File",
    "section": "5.4 Word Navigation",
    "text": "5.4 Word Navigation\nLet’s move to a larger motion unit: word. You can move to the beginning of the next word (w), to the end of the next word (e), to the beginning of the previous word (b), and to the end of the previous word (ge).\nIn addition, there is WORD, distinct from word. You can move to the beginning of the next WORD (W), to the end of the next WORD (E), to the beginning of the previous WORD (B), and to the end of the previous WORD (gE). To make it easy to remember, WORD uses the same letters as word, only uppercased.\nw     Move forward to the beginning of the next word\nW     Move forward to the beginning of the next WORD\ne     Move forward one word to the end of the next word\nE     Move forward one word to the end of the next WORD\nb     Move backward to beginning of the previous word\nB     Move backward to beginning of the previous WORD\nge    Move backward to end of the previous word\ngE    Move backward to end of the previous WORD\nSo what are the similarities and differences between a word and a WORD? Both word and WORD are separated by blank characters. A word is a sequence of characters containing only a-zA-Z0-9_. A WORD is a sequence of all characters except white space (a white space means either space, tab, and EOL). To learn more, check out :h word and :h WORD.\nFor example, suppose you have:\nconst hello = \"world\";\nWith your cursor at the start of the line, to go to the end of the line with l, it will take you 21 key presses. Using w, it will take 6. Using W, it will only take 4. Both word and WORD are good options to travel short distance.\nHowever, you can get from c to ; in one keystroke with current line navigation."
  },
  {
    "objectID": "chapters/ch05_moving_in_file.md.html#current-line-navigation",
    "href": "chapters/ch05_moving_in_file.md.html#current-line-navigation",
    "title": "5  Ch05. Moving in a File",
    "section": "5.5 Current Line Navigation",
    "text": "5.5 Current Line Navigation\nWhen editing, you often need to navigate horizontally in a line. To jump to the first character in current line, use 0. To go to the last character in the current line, use $. Additionally, you can use ^ to go to the first non-blank character in the current line and g_ to go to the last non-blank character in the current line. If you want to go to the column n in the current line, you can use n|.\n0     Go to the first character in the current line\n^     Go to the first nonblank char in the current line\ng_    Go to the last non-blank char in the current line\n$     Go to the last char in the current line\nn|    Go the column n in the current line\nYou can do current line search with f and t. The difference between f and t is that f takes you to the first letter of the match and t takes you till (right before) the first letter of the match. So if you want to search for h and land on h, use fh. If you want to search for first h and land right before the match, use th. If you want to go to the next occurrence of the last current line search, use ;. To go to the previous occurrence of the last current line match, use ,.\nF and T are the backward counterparts of f and t. To search backwards for h, run Fh. To keep searching for h in the same direction, use ;. Note that ; after a Fh searches backward and , after Fh searches forward.\nf    Search forward for a match in the same line\nF    Search backward for a match in the same line\nt    Search forward for a match in the same line, stopping before match\nT    Search backward for a match in the same line, stopping before match\n;    Repeat the last search in the same line using the same direction\n,    Repeat the last search in the same line using the opposite direction\nBack at the previous example:\nconst hello = \"world\";\nWith your cursor at the start of the line, you can go to the last character in current line (;) with one keypress: $. If you want to go to w in world, you can use fw. A good tip to go anywhere in a line is to look for least-common-letters like j, x, z near your target."
  },
  {
    "objectID": "chapters/ch05_moving_in_file.md.html#sentence-and-paragraph-navigation",
    "href": "chapters/ch05_moving_in_file.md.html#sentence-and-paragraph-navigation",
    "title": "5  Ch05. Moving in a File",
    "section": "5.6 Sentence and Paragraph Navigation",
    "text": "5.6 Sentence and Paragraph Navigation\nNext two navigation units are sentence and paragraph.\nLet’s talk about what a sentence is first. A sentence ends with either . ! ? followed by an EOL, a space, or a tab. You can jump to the next sentence with ) and the previous sentence with (.\n(    Jump to the previous sentence\n)    Jump to the next sentence\nLet’s look at some examples. Which phrases do you think are sentences and which aren’t? Try navigating with ( and ) in Vim!\nI am a sentence. I am another sentence because I end with a period. I am still a sentence when ending with an exclamation point! What about question mark? I am not quite a sentence because of the hyphen - and neither semicolon ; nor colon :\n\nThere is an empty line above me.\nBy the way, if you’re having a problem with Vim not counting a sentence for phrases separated by . followed by a single line, you might be in 'compatible' mode. Add set nocompatible into vimrc. In Vi, a sentence is a . followed by two spaces. You should have nocompatible set at all times.\nLet’s talk what a paragraph is. A paragraph begins after each empty line and also at each set of a paragraph macro specified by the pairs of characters in paragraphs option.\n{    Jump to the previous paragraph\n}    Jump to the next paragraph\nIf you’re not sure what a paragraph macro is, do not worry. The important thing is that a paragraph begins and ends after an empty line. This should be true most of the time.\nLet’s look at this example. Try navigating around with } and { (also, play around with sentence navigations ( ) to move around too!)\nHello. How are you? I am great, thanks!\nVim is awesome.\nIt may not easy to learn it at first...- but we are in this together. Good luck!\n\nHello again.\n\nTry to move around with ), (, }, and {. Feel how they work.\nYou got this.\nCheck out :h sentence and :h paragraph to learn more."
  },
  {
    "objectID": "chapters/ch05_moving_in_file.md.html#match-navigation",
    "href": "chapters/ch05_moving_in_file.md.html#match-navigation",
    "title": "5  Ch05. Moving in a File",
    "section": "5.7 Match Navigation",
    "text": "5.7 Match Navigation\nProgrammers write and edit codes. Codes typically use parentheses, braces, and brackets. You can easily get lost in them. If you’re inside one, you can jump to the other pair (if it exists) with %. You can also use this to find out whether you have matching parentheses, braces, and brackets.\n%    Navigate to another match, usually works for (), [], {}\nLet’s look at a Scheme code example because it uses parentheses extensively. Move around with % inside different parentheses.\n(define (fib n)\n  (cond ((= n 0) 0)\n        ((= n 1) 1)\n        (else\n          (+ (fib (- n 1)) (fib (- n 2)))\n        )))\nI personally like to complement % with visual indicators plugins like vim-rainbow. For more, check out :h %."
  },
  {
    "objectID": "chapters/ch05_moving_in_file.md.html#line-number-navigation",
    "href": "chapters/ch05_moving_in_file.md.html#line-number-navigation",
    "title": "5  Ch05. Moving in a File",
    "section": "5.8 Line Number Navigation",
    "text": "5.8 Line Number Navigation\nYou can jump to line number n with nG. For example, if you want to jump to line 7, use 7G. To jump to the first line, use either 1G or gg. To jump to the last line, use G.\nOften you don’t know exactly what line number your target is, but you know it’s approximately at 70% of the whole file. In this case, you can do 70%. To jump halfway through the file, you can do 50%.\ngg    Go to the first line\nG     Go to the last line\nnG    Go to line n\nn%    Go to n% in file\nBy the way, if you want to see total lines in a file, you can use Ctrl-g."
  },
  {
    "objectID": "chapters/ch05_moving_in_file.md.html#window-navigation",
    "href": "chapters/ch05_moving_in_file.md.html#window-navigation",
    "title": "5  Ch05. Moving in a File",
    "section": "5.9 Window Navigation",
    "text": "5.9 Window Navigation\nTo quickly go to the top, middle, or bottom of your window, you can use H, M, and L.\nYou can also pass a count to H and L. If you use 10H, you will go to 10 lines below the top of window. If you use 3L, you will go to 3 lines above the last line of window.\nH     Go to top of screen\nM     Go to medium screen\nL     Go to bottom of screen\nnH    Go n line from top\nnL    Go n line from bottom"
  },
  {
    "objectID": "chapters/ch05_moving_in_file.md.html#scrolling",
    "href": "chapters/ch05_moving_in_file.md.html#scrolling",
    "title": "5  Ch05. Moving in a File",
    "section": "5.10 Scrolling",
    "text": "5.10 Scrolling\nTo scroll, you have 3 speed increments: full-screen (Ctrl-F/Ctrl-B), half-screen (Ctrl-D/Ctrl-U), and line (Ctrl-E/Ctrl-Y).\nCtrl-E    Scroll down a line\nCtrl-D    Scroll down half screen\nCtrl-F    Scroll down whole screen\nCtrl-Y    Scroll up a line\nCtrl-U    Scroll up half screen\nCtrl-B    Scroll up whole screen\nYou can also scroll relatively to the current line (zoom screen sight):\nzt    Bring the current line near the top of your screen\nzz    Bring the current line to the middle of your screen\nzb    Bring the current line near the bottom of your screen"
  },
  {
    "objectID": "chapters/ch05_moving_in_file.md.html#search-navigation",
    "href": "chapters/ch05_moving_in_file.md.html#search-navigation",
    "title": "5  Ch05. Moving in a File",
    "section": "5.11 Search Navigation",
    "text": "5.11 Search Navigation\nOften you know that a phrase exists inside a file. You can use search navigation to very quickly reach your target. To search for a phrase, you can use / to search forward and ? to search backward. To repeat the last search you can use n. To repeat the last search going opposite direction, you can use N.\n/    Search forward for a match\n?    Search backward for a match\nn    Repeat last search in same direction of previous search\nN    Repeat last search in opposite direction of previous search\nSuppose you have this text:\nlet one = 1;\nlet two = 2;\none = \"01\";\none = \"one\";\nlet onetwo = 12;\nIf you are searching for let, run /let. To quickly search for let again, you can just do n. To search for let again in opposite direction, run N. If you run ?let, it will search for let backwards. If you use n, it will now search for let backwards (N will search for let forwards now).\nYou can enable search highlight with set hlsearch. Now when you search for /let, it will highlight all matching phrases in the file. In addition, you can set incremental search with set incsearch. This will highlight the pattern while typing. By default, your matching phrases will remain highlighted until you search for another phrase. This can quickly turn into an annoyance. To disable highlight, you can run :nohlsearch or simply :noh. Because I use this no-highlight feature frequently, I created a map in vimrc:\nnnoremap <esc><esc> :noh<return><esc>\nYou can quickly search for the text under the cursor with * to search forward and # to search backward. If your cursor is on the string one, pressing * will be the same as if you had done /\\<one\\>.\nBoth \\< and \\> in /\\<one\\> mean whole word search. It does not match one if it is a part of a bigger word. It will match for the word one but not onetwo. If your cursor is over one and you want to search forward to match whole or partial words like one and onetwo, you need to use g* instead of *.\n*     Search for whole word under cursor forward\n#     Search for whole word under cursor backward\ng*    Search for word under cursor forward\ng#    Search for word under cursor backward"
  },
  {
    "objectID": "chapters/ch05_moving_in_file.md.html#marking-position",
    "href": "chapters/ch05_moving_in_file.md.html#marking-position",
    "title": "5  Ch05. Moving in a File",
    "section": "5.12 Marking Position",
    "text": "5.12 Marking Position\nYou can use marks to save your current position and return to this position later. It’s like a bookmark for text editing. You can set a mark with mx, where x can be any alphabetical letter a-zA-Z. There are two ways to return to mark: exact (line and column) with `x and linewise ('x).\nma    Mark position with mark \"a\"\n`a    Jump to line and column \"a\"\n'a    Jump to line \"a\"\nThere is a difference between marking with lowercase letters (a-z) and uppercase letters (A-Z). Lowercase alphabets are local marks and uppercase alphabets are global marks (sometimes known as file marks).\nLet’s talk about local marks. Each buffer can have its own set of local marks. If I have two files opened, I can set a mark a (ma) in the first file and another mark a (ma) in the second file.\nUnlike local marks where you can have a set of marks in each buffer, you only get one set of global marks. If you set mA inside myFile.txt, the next time you run mA in a different file, it will overwrite the first A mark. One advantage of global marks is you can jump to any global mark even if you are inside a completely different project. Global marks can travel across files.\nTo view all marks, use :marks. You may notice from the marks list there are more marks other than a-zA-Z. Some of them are:\n''    Jump back to the last line in current buffer before jump\n``    Jump back to the last position in current buffer before jump\n`[    Jump to beginning of previously changed / yanked text\n`]    Jump to the ending of previously changed / yanked text\n`<    Jump to the beginning of last visual selection\n`>    Jump to the ending of last visual selection\n`0    Jump back to the last edited file when exiting vim\nThere are more marks than the ones listed above. I won’t cover them here because I think they are rarely used, but if you’re curious, check out :h marks."
  },
  {
    "objectID": "chapters/ch05_moving_in_file.md.html#jump",
    "href": "chapters/ch05_moving_in_file.md.html#jump",
    "title": "5  Ch05. Moving in a File",
    "section": "5.13 Jump",
    "text": "5.13 Jump\nIn Vim, you can jump to a different file or different part of a file with some motions. Not all motions count as a jump, though. Going down with j does not count as a jump. Going to line 10 with 10G counts as a jump.\nHere are the commands Vim consider as jump commands:\n'       Go to the marked line\n`       Go to the marked position\nG       Go to the line\n/       Search forward\n?       Search backward\nn       Repeat the last search, same direction\nN       Repeat the last search, opposite direction\n%       Find match\n(       Go to the last sentence\n)       Go to the next sentence\n{       Go to the last paragraph\n}       Go to the next paragraph\nL       Go to the the last line of displayed window\nM       Go to the middle line of displayed window\nH       Go to the top line of displayed window\n[[      Go to the previous section\n]]      Go to the next section\n:s      Substitute\n:tag    Jump to tag definition\nI don’t recommend memorizing this list. A good rule of thumb is, any motion that moves farther than a word and current line navigation is probably a jump. Vim keeps track of where you’ve been when you move around and you can see this list inside :jumps.\nFor more, check out :h jump-motions.\nWhy are jumps useful? Because you can navigate the jump list with Ctrl-O to move up the jump list and Ctrl-I to move down the jump list. hjkl are not jump commands, but you can manually add the current location to jump list with m' before movement. For example, m'5j adds current location to jump list and goes down 5 lines, and you can come back with Ctrl-O. You can jump across different files, which I will discuss more in the next part."
  },
  {
    "objectID": "chapters/ch05_moving_in_file.md.html#learn-navigation-the-smart-way",
    "href": "chapters/ch05_moving_in_file.md.html#learn-navigation-the-smart-way",
    "title": "5  Ch05. Moving in a File",
    "section": "5.14 Learn Navigation the Smart Way",
    "text": "5.14 Learn Navigation the Smart Way\nIf you are new to Vim, this is a lot to learn. I do not expect anyone to remember everything immediately. It takes time before you can execute them without thinking.\nI think the best way to get started is to memorize a few essential motions. I recommend starting out with these 10 motions: h, j, k, l, w, b, G, /, ?, n. Repeat them sufficiently until you can use them without thinking.\nTo improve your navigation skill, here are my suggestions: 1. Watch for repeated actions. If you find yourself doing l repeatedly, look for a motion that will take you forward faster. You will find that you can use w. If you catch yourself repeatedly doing w, look if there is a motion that will take you across the current line quickly. You will find that you can use the f. If you can describe your need succinctly, there is a good chance Vim has a way to do it. 2. Whenever you learn a new move, spend some time until you can do it without thinking.\nFinally, realize that you do not need to know every single Vim command to be productive. Most Vim users don’t. I don’t. Learn the commands that will help you accomplish your task at that moment.\nTake your time. Navigation skill is a very important skill in Vim. Learn one small thing every day and learn it well."
  },
  {
    "objectID": "chapters/ch06_insert_mode.md.html#ways-to-go-to-insert-mode",
    "href": "chapters/ch06_insert_mode.md.html#ways-to-go-to-insert-mode",
    "title": "6  Ch06. Insert Mode",
    "section": "6.1 Ways to Go to Insert Mode",
    "text": "6.1 Ways to Go to Insert Mode\nThere are many ways to get into insert mode from the normal mode. Here are some of them:\ni    Insert text before the cursor\nI    Insert text before the first non-blank character of the line\na    Append text after the cursor\nA    Append text at the end of line\no    Starts a new line below the cursor and insert text\nO    Starts a new line above the cursor and insert text\ns    Delete the character under the cursor and insert text\nS    Delete the current line and insert text, synonym for \"cc\"\ngi   Insert text in same position where the last insert mode was stopped\ngI   Insert text at the start of line (column 1)\nNotice the lowercase / uppercase pattern. For each lowercase command, there is an uppercase counterpart. If you are new, don’t worry if you don’t remember the whole list above. Start with i and o. They should be enough to get you started. Gradually learn more over time."
  },
  {
    "objectID": "chapters/ch06_insert_mode.md.html#different-ways-to-exit-insert-mode",
    "href": "chapters/ch06_insert_mode.md.html#different-ways-to-exit-insert-mode",
    "title": "6  Ch06. Insert Mode",
    "section": "6.2 Different Ways to Exit Insert Mode",
    "text": "6.2 Different Ways to Exit Insert Mode\nThere are a few different ways to return to the normal mode while in the insert mode:\n<Esc>     Exits insert mode and go to normal mode\nCtrl-[    Exits insert mode and go to normal mode\nCtrl-C    Like Ctrl-[ and <Esc>, but does not check for abbreviation\nI find <Esc> key too far to reach, so I map my computer <Caps-Lock> to behave like <Esc>. If you search for Bill Joy’s ADM-3A keyboard (Vi creator), you will see that the <Esc> key is not located on far top left like modern keyboards, but to the left of q key. This is why I think it makes sense to map <Caps lock> to <Esc>.\nAnother common convention I have seen Vim users do is mapping <Esc> to jj or jk in insert mode. If you prefer this option add this one of those lines (or both) in your vimrc file.\ninoremap jj <Esc>\ninoremap jk <Esc>"
  },
  {
    "objectID": "chapters/ch06_insert_mode.md.html#repeating-insert-mode",
    "href": "chapters/ch06_insert_mode.md.html#repeating-insert-mode",
    "title": "6  Ch06. Insert Mode",
    "section": "6.3 Repeating Insert Mode",
    "text": "6.3 Repeating Insert Mode\nYou can pass a count parameter before entering insert mode. For example:\n10i\nIf you type hello world! and exit insert mode, Vim will repeat the text 10 times. This will work with any insert mode method (ex: 10I, 11a, 12o)."
  },
  {
    "objectID": "chapters/ch06_insert_mode.md.html#deleting-chunks-in-insert-mode",
    "href": "chapters/ch06_insert_mode.md.html#deleting-chunks-in-insert-mode",
    "title": "6  Ch06. Insert Mode",
    "section": "6.4 Deleting Chunks in Insert Mode",
    "text": "6.4 Deleting Chunks in Insert Mode\nWhen you make a typing mistake, it can be cumbersome to type <Backspace> repeatedly. It may make more sense to go to normal mode and delete your mistake. You can also delete several characters at a time while in insert mode.\nCtrl-h    Delete one character\nCtrl-w    Delete one word\nCtrl-u    Delete the entire line"
  },
  {
    "objectID": "chapters/ch06_insert_mode.md.html#insert-from-register",
    "href": "chapters/ch06_insert_mode.md.html#insert-from-register",
    "title": "6  Ch06. Insert Mode",
    "section": "6.5 Insert From Register",
    "text": "6.5 Insert From Register\nVim registers can store texts for future use. To insert a text from any named register while in insert mode, type Ctrl-R plus the register symbol. There are many symbols you can use, but for this section, let’s cover only the named registers (a-z).\nTo see it in action, first you need to yank a word to register a. Move your cursor on any word. Then type:\n\"ayiw\n\n\"a tells Vim that the target of your next action will go to register a.\nyiw yanks inner word. Review the chapter on Vim grammar for a refresher.\n\nRegister a now contains the word you just yanked. While in insert mode, to paste the text stored in register a:\nCtrl-R a\nThere are multiple types of registers in Vim. I will cover them in greater detail in a later chapter."
  },
  {
    "objectID": "chapters/ch06_insert_mode.md.html#scrolling",
    "href": "chapters/ch06_insert_mode.md.html#scrolling",
    "title": "6  Ch06. Insert Mode",
    "section": "6.6 Scrolling",
    "text": "6.6 Scrolling\nDid you know that you can scroll while inside insert mode? While in insert mode, if you go to Ctrl-X sub-mode, you can do additional operations. Scrolling is one of them.\nCtrl-X Ctrl-Y    Scroll up\nCtrl-X Ctrl-E    Scroll down"
  },
  {
    "objectID": "chapters/ch06_insert_mode.md.html#autocompletion",
    "href": "chapters/ch06_insert_mode.md.html#autocompletion",
    "title": "6  Ch06. Insert Mode",
    "section": "6.7 Autocompletion",
    "text": "6.7 Autocompletion\nAs mentioned above, if you press Ctrl-X from insert mode, Vim will enter a sub-mode. You can do text autocompletion while in this insert mode sub-mode. Although it is not as good as intellisense or any other Language Server Protocol (LSP), but for something that is available right out of the box, it is a very capable feature.\nHere are some useful autocomplete commands to get started:\nCtrl-X Ctrl-L      Insert a whole line\nCtrl-X Ctrl-N      Insert a text from current file\nCtrl-X Ctrl-I      Insert a text from included files\nCtrl-X Ctrl-F      Insert a file name\nWhen you trigger autocompletion, Vim will display a pop-up window. To navigate up and down the pop-up window, use Ctrl-N and Ctrl-P.\nVim also has two autocompletion shortcuts that don’t involve the Ctrl-X sub-mode:\nCtrl-N             Find the next word match\nCtrl-P             Find the previous word match\nIn general, Vim looks at the text in all available buffers for autocompletion source. If you have an open buffer with a line that says Chocolate donuts are the best: - When you type Choco and do Ctrl-X Ctrl-L, it will match and print the entire line. - When you type Choco and do Ctrl-P, it will match and print the word Chocolate.\nAutocomplete is a vast topic in Vim. This is just the tip of the iceberg. To learn more, check out :h ins-completion."
  },
  {
    "objectID": "chapters/ch06_insert_mode.md.html#executing-a-normal-mode-command",
    "href": "chapters/ch06_insert_mode.md.html#executing-a-normal-mode-command",
    "title": "6  Ch06. Insert Mode",
    "section": "6.8 Executing a Normal Mode Command",
    "text": "6.8 Executing a Normal Mode Command\nDid you know Vim can execute a normal mode command while in insert mode?\nWhile in insert mode, if you press Ctrl-O, you’ll be in insert-normal sub-mode. If you look at the mode indicator on bottom left, normally you will see -- INSERT --, but pressing Ctrl-O changes it to -- (insert) --. In this mode, you can do one normal mode command. Some things you can do:\nCentering and jumping\nCtrl-O zz       Center window\nCtrl-O H/M/L    Jump to top/middle/bottom window\nCtrl-O 'a       Jump to mark a\nRepeating text\nCtrl-O 100ihello    Insert \"hello\" 100 times\nExecuting terminal commands\nCtrl-O !! curl https://google.com    Run curl\nCtrl-O !! pwd                        Run pwd\nDeleting faster\nCtrl-O dtz    Delete from current location till the letter \"z\"\nCtrl-O D      Delete from current location to the end of the line"
  },
  {
    "objectID": "chapters/ch06_insert_mode.md.html#learn-insert-mode-the-smart-way",
    "href": "chapters/ch06_insert_mode.md.html#learn-insert-mode-the-smart-way",
    "title": "6  Ch06. Insert Mode",
    "section": "6.9 Learn Insert Mode the Smart Way",
    "text": "6.9 Learn Insert Mode the Smart Way\nIf you are like me and you come from another text editor, it can be tempting to stay in insert mode. However, staying in insert mode when you’re not entering a text is an anti-pattern. Develop a habit to go to normal mode when your fingers aren’t typing new text.\nWhen you need to insert a text, first ask yourself if that text already exists. If it does, try to yank or move that text instead of typing it. If you have to use insert mode, see if you can autocomplete that text whenever possible. Avoid typing the same word more than once if you can."
  },
  {
    "objectID": "chapters/ch07_the_dot_command.md.html#usage",
    "href": "chapters/ch07_the_dot_command.md.html#usage",
    "title": "7  Ch07. the Dot Command",
    "section": "7.1 Usage",
    "text": "7.1 Usage\nJust like its name, you can use the dot command by pressing the dot key (.).\nFor example, if you want to replace all let with const in the following expressions:\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\n\nSearch with /let to go to the match.\nChange with cwconst<Esc> to replace let with const.\nNavigate with n to find the next match using the previous search.\nRepeat what you just did with the dot command (.).\nContinue pressing n . n . until you replace every word.\n\nHere the dot command repeated the cwconst<Esc> sequence. It saved you from typing eight keystrokes in exchange for just one."
  },
  {
    "objectID": "chapters/ch07_the_dot_command.md.html#what-is-a-change",
    "href": "chapters/ch07_the_dot_command.md.html#what-is-a-change",
    "title": "7  Ch07. the Dot Command",
    "section": "7.2 What Is a Change?",
    "text": "7.2 What Is a Change?\nIf you look at the definition of the dot command (:h .), it says that the dot command repeats the last change. What is a change?\nAny time you update (add, modify, or delete) the content of the current buffer, you are making a change. The exceptions are updates done by command-line commands (the commands starting with :) do not count as a change.\nIn the first example, cwconst<Esc> was the change. Now suppose you have this text:\npancake, potatoes, fruit-juice,\nTo delete the text from the start of the line to the next occurrence of a comma, first delete to the comma, then repeat twice it with df,...\nLet’s try another example:\npancake, potatoes, fruit-juice,\nThis time, your task is to delete the comma, not the breakfast items. With the cursor at the beginning of the line, go to the first comma, delete it, then repeat two more times with f,x.. Easy, right? Wait a minute, it didn’t work! Why?\nA change excludes motions because it does not update buffer content. The command f,x consisted of two actions: the command f, to move the cursor to , and x to delete a character. Only the latter, x, caused a change. Contrast that with df, from the earlier example. In it, f, is a directive to the delete operator d, not a motion to move the cursor. The f, in df, and f,x have two very different roles.\nLet’s finish the last task. After you run f, then x, go to the next comma with ; to repeat the latest f. Finally, use . to delete the character under the cursor. Repeat ; . ; . until everything is deleted. The full command is f,x;.;..\nLet’s try another one:\npancake\npotatoes\nfruit-juice\nLet’s add a comma at the end of each line. Starting at the first line, do A,<Esc>j. By now, you realize that j does not cause a change. The change here is only A,. You can move and repeat the change with j . j .. The full command is A,<Esc>j.j..\nEvery action from the moment you press the insert command operator (A) until you exit the insert command (<Esc>) is considered as a change."
  },
  {
    "objectID": "chapters/ch07_the_dot_command.md.html#multi-line-repeat",
    "href": "chapters/ch07_the_dot_command.md.html#multi-line-repeat",
    "title": "7  Ch07. the Dot Command",
    "section": "7.3 Multi-line Repeat",
    "text": "7.3 Multi-line Repeat\nSuppose you have this text:\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\nconst foo = \"bar';\nlet four = \"4\";\nlet five = \"5\";\nlet six = \"6\";\nlet seven = \"7\";\nlet eight = \"8\";\nlet nine = \"9\";\nYour goal is to delete all lines except the foo line. First, delete the first three lines with d2j, then to the line below the foo line. On the next line, use the dot command twice. The full command is d2jj...\nHere the change was d2j. In this context, 2j was not a motion, but a part of the delete operator.\nLet’s look at another example:\nzlet zzone = \"1\";\nzlet zztwo = \"2\";\nzlet zzthree = \"3\";\nlet four = \"4\";\nLet’s remove all the z’s. Starting from the first character on the first line, visually select only the first z from the first three lines with blockwise visual mode (Ctrl-Vjj). If you’re not familiar with blockwise visual mode, I will cover them in a later chapter. Once you have the three z’s visually selected, delete them with the delete operator (d). Then move to the next word (w) to the next z. Repeat the change two more times (..). The full command is Ctrl-vjjdw...\nWhen you deleted a column of three z’s (Ctrl-vjjd), it was counted as a change. Visual mode operation can be used to target multiple lines as part of a change."
  },
  {
    "objectID": "chapters/ch07_the_dot_command.md.html#including-a-motion-in-a-change",
    "href": "chapters/ch07_the_dot_command.md.html#including-a-motion-in-a-change",
    "title": "7  Ch07. the Dot Command",
    "section": "7.4 Including a Motion in a Change",
    "text": "7.4 Including a Motion in a Change\nLet’s revisit the first example in this chapter. Recall that the command /letcwconst<Esc> followed by n . n . replaced all let with const in the following expressions:\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\nThere is a faster way to accomplish this. After you searched /let, run cgnconst<Esc> then . ..\ngn is a motion that searches forward for the last search pattern (in this case, /let) and automatically does a visual highlight. To replace the next occurrence, you no longer have to move and repeat the change ( n . n .), but only repeat (. .). You do not have to use search motions anymore because searching the next match is now part of the change!\nWhen you are editing, always be on the lookout for motions that can do several things at once like gn whenever possible."
  },
  {
    "objectID": "chapters/ch07_the_dot_command.md.html#learn-the-dot-command-the-smart-way",
    "href": "chapters/ch07_the_dot_command.md.html#learn-the-dot-command-the-smart-way",
    "title": "7  Ch07. the Dot Command",
    "section": "7.5 Learn the Dot Command the Smart Way",
    "text": "7.5 Learn the Dot Command the Smart Way\nThe dot command’s power comes from exchanging several keystrokes for one. It is probably not a profitable exchange to use the dot command for single key operations like x. If your last change requires a complex operation like cgnconst<Esc>, the dot command reduces nine keypresses into one, a very profitable trade-off.\nWhen editing, think about repeatability. For example, if I need to remove the next three words, is it more economical to use d3w or to do dw then . two times? Will you be deleting a word again? If so, then it makes sense to use dw and repeat it several times instead of d3w because dw is more reusable than d3w.\nThe dot command is a versatile command for automating single changes. In a later chapter, you will learn how to automate more complex actions with Vim macros. But first, let’s learn about registers to store and retrieve text."
  },
  {
    "objectID": "chapters/ch08_registers.md.html#the-ten-register-types",
    "href": "chapters/ch08_registers.md.html#the-ten-register-types",
    "title": "8  Ch08. Registers",
    "section": "8.1 The Ten Register Types",
    "text": "8.1 The Ten Register Types\nHere are the 10 Vim register types:\n\nThe unnamed register (\"\").\nThe numbered registers (\"0-9).\nThe small delete register (\"-).\nThe named registers (\"a-z).\nThe read-only registers (\":, \".,and \"%).\nThe alternate file register (\"#).\nThe expression register (\"=).\nThe selection registers (\"* and \"+).\nThe black hole register (\"_).\nThe last search pattern register (\"/)."
  },
  {
    "objectID": "chapters/ch08_registers.md.html#register-operators",
    "href": "chapters/ch08_registers.md.html#register-operators",
    "title": "8  Ch08. Registers",
    "section": "8.2 Register Operators",
    "text": "8.2 Register Operators\nTo use registers, you need to first store them with operators. Here are some operators that store values to registers:\ny    Yank (copy)\nc    Delete text and start insert mode\nd    Delete text\nThere are more operators (like s or x), but the above are the useful ones. The rule of thumb is, if an operator can remove a text, it probably stores the text to registers.\nTo paste a text from registers, you can use:\np    Paste the text after the cursor\nP    Paste the text before the cursor\nBoth p and P accept a count and a register symbol as arguments. For example, to paste ten times, do 10p. To paste the text from register a, do \"ap. To paste the text from register a ten times, do 10\"ap. By the way, the p actually technically stands for put, not paste, but I figure paste is a more conventional word.\nThe general syntax to get the content from a specific register is \"a, where a is the register symbol."
  },
  {
    "objectID": "chapters/ch08_registers.md.html#calling-registers-from-insert-mode",
    "href": "chapters/ch08_registers.md.html#calling-registers-from-insert-mode",
    "title": "8  Ch08. Registers",
    "section": "8.3 Calling Registers From Insert Mode",
    "text": "8.3 Calling Registers From Insert Mode\nEverything you learn in this chapter can also be executed in insert mode. To get the text from register a, normally you do \"ap. But if you are in insert mode, run Ctrl-R a. The syntax to call registers from insert mode is:\nCtrl-R a\nWhere a is the register symbol. Now that you know how to store and retrieve registers, let’s dive in!"
  },
  {
    "objectID": "chapters/ch08_registers.md.html#the-unnamed-register",
    "href": "chapters/ch08_registers.md.html#the-unnamed-register",
    "title": "8  Ch08. Registers",
    "section": "8.4 The Unnamed Register",
    "text": "8.4 The Unnamed Register\nTo get the text from the unnamed register, do \"\"p. It stores the last text you yanked, changed, or deleted. If you do another yank, change, or delete, Vim will automatically replace the old text. The unnamed register is like a computer’s standard copy / paste operation.\nBy default, p (or P) is connected to the unnamed register (from now on I will refer to the unnamed register with p instead of \"\"p)."
  },
  {
    "objectID": "chapters/ch08_registers.md.html#the-numbered-registers",
    "href": "chapters/ch08_registers.md.html#the-numbered-registers",
    "title": "8  Ch08. Registers",
    "section": "8.5 The Numbered Registers",
    "text": "8.5 The Numbered Registers\nNumbered registers automatically fill themselves up in ascending order. There are 2 different numbered registers: the yanked register (0) and the numbered registers (1-9). Let’s discuss the yanked register first.\n\n8.5.1 The Yanked Register\nIf you yank an entire line of text (yy), Vim actually saves that text in two registers:\n\nThe unnamed register (p).\nThe yanked register (\"0p).\n\nWhen you yank a different text, Vim will update both the yanked register and the unnamed register. Any other operations (like delete) will not be stored in register 0. This can be used to your advantage, because unless you do another yank, the yanked text will always be there, no matter how many changes and deletions you do.\nFor example, if you: 1. Yank a line (yy) 2. Delete a line (dd) 3. Delete another line (dd)\nThe yanked register will have the text from step one.\nIf you: 1. Yank a line (yy) 2. Delete a line (dd) 3. Yank another line (yy)\nThe yanked register will have the text from step three.\nOne last tip, while in insert mode, you can quickly paste the text you just yanked using Ctrl-R 0.\n\n\n8.5.2 The Non-zero Numbered Registers\nWhen you change or delete a text that is at least one line long, that text will be stored in the numbered registers 1-9 sorted by the most recent.\nFor example, if you have these lines:\nline three\nline two\nline one\nWith your cursor on line three, delete them one by one with dd. Once all lines are deleted, register 1 should contain line one (most recent), register two line two (second most recent), and register three line three (oldest). To get the content from register one, do \"1p.\nAs a side note, these numbered registers are automatically incremented when using the dot command. If your numbered register one (\"1) contains line one, register two (\"2) line two, and register three (\"3) line three, you can paste them sequentially with this trick: - Do \"1P to paste the content from the numbered register one (1). - Do . to paste the content from the numbered register two (2). - Do . to paste the content from the numbered register three (“3).\nThis trick works with any numbered register. If you started with \"5P, . would do \"6P, . again would do \"7P, and so on.\nSmall deletions like a word deletion (dw) or word change (cw) do not get stored in the numbered registers. They are stored in the small delete register (\"-), which I will discuss next."
  },
  {
    "objectID": "chapters/ch08_registers.md.html#the-small-delete-register",
    "href": "chapters/ch08_registers.md.html#the-small-delete-register",
    "title": "8  Ch08. Registers",
    "section": "8.6 The Small Delete Register",
    "text": "8.6 The Small Delete Register\nChanges or deletions less than one line are not stored in the numbered registers 0-9, but in the small delete register (\"-).\nFor example: 1. Delete a word (diw) 2. Delete a line (dd) 3. Delete a line (dd)\n\"-p gives you the deleted word from step one.\nAnother example: 1. I delete a word (diw) 2. I delete a line (dd) 3. I delete a word (diw)\n\"-p gives you the deleted word from step three. \"1p gives you the deleted line from step two. Unfortunately, there is no way to retrieve the deleted word from step one because the small delete register only stores one item. However, if you want to preserve the text from step one, you can do it with the named registers."
  },
  {
    "objectID": "chapters/ch08_registers.md.html#the-named-register",
    "href": "chapters/ch08_registers.md.html#the-named-register",
    "title": "8  Ch08. Registers",
    "section": "8.7 The Named Register",
    "text": "8.7 The Named Register\nThe named registers are Vim’s most versatile register. It can store yanked, changed, and deleted texts into registers a-z. Unlike the previous 3 register types you’ve seen which automatically stores texts into registers, you have to explicitly tell Vim to use the named register, giving you full control.\nTo yank a word into register a, you can do it with \"ayiw. - \"a tells Vim that the next action (delete / change / yank) will be stored in register a. - yiw yanks the word.\nTo get the text from register a, run \"ap. You can use all twenty-six alphabetical characters to store twenty-six different texts with named registers.\nSometimes you may want to add to your existing named register. In this case, you can append your text instead of starting all over. To do that, you can use the uppercase version of that register. For example, suppose you have the word Hello already stored in register a. If you want to add world into register a, you can find the text world and yank it using A register (\"Ayiw)."
  },
  {
    "objectID": "chapters/ch08_registers.md.html#the-read-only-registers",
    "href": "chapters/ch08_registers.md.html#the-read-only-registers",
    "title": "8  Ch08. Registers",
    "section": "8.8 The Read-only Registers",
    "text": "8.8 The Read-only Registers\nVim has three read-only registers: ., :, and %. They are pretty simple to use:\n.    Stores the last inserted text\n:    Stores the last executed command-line\n%    Stores the name of current file\nIf the last text you wrote was Hello Vim, running \".p will print out the text Hello Vim. If you want to get the name of current file, run \"%p. If you run :s/foo/bar/g command, running \":p will print out the literal text s/foo/bar/g."
  },
  {
    "objectID": "chapters/ch08_registers.md.html#the-alternate-file-register",
    "href": "chapters/ch08_registers.md.html#the-alternate-file-register",
    "title": "8  Ch08. Registers",
    "section": "8.9 The Alternate File Register",
    "text": "8.9 The Alternate File Register\nIn Vim, # usually represents the alternate file. An alternative file is the last file you opened. To insert the name of the alternate file, you can use \"#p."
  },
  {
    "objectID": "chapters/ch08_registers.md.html#the-expression-register",
    "href": "chapters/ch08_registers.md.html#the-expression-register",
    "title": "8  Ch08. Registers",
    "section": "8.10 The Expression Register",
    "text": "8.10 The Expression Register\nVim has an expression register, \"=, to evaluate expressions.\nTo evaluate mathematical expressions 1 + 1, run:\n\"=1+1<Enter>p\nHere, you are telling Vim that you are using the expression register with \"=. Your expression is (1 + 1). You need to type p to get the result. As mentioned earlier, you can also access the register from insert mode. To evaluate mathematical expression from insert mode, you can do:\nCtrl-R =1+1\nYou can also get the values from any register via the expression register when appended with @. If you wish to get the text from register a:\n\"=@a\nThen press <Enter>, then p. Similarly, to get values from register a while in insert mode:\nCtrl-r =@a\nExpression is a vast topic in Vim, so I will only cover the basics here. I will address expressions in more details in later Vimscript chapters."
  },
  {
    "objectID": "chapters/ch08_registers.md.html#the-selection-registers",
    "href": "chapters/ch08_registers.md.html#the-selection-registers",
    "title": "8  Ch08. Registers",
    "section": "8.11 The Selection Registers",
    "text": "8.11 The Selection Registers\nDon’t you sometimes wish that you can copy a text from external programs and paste it locally in Vim, and vice versa? With Vim’s selection registers, you can. Vim has two selection registers: quotestar (\"*) and quoteplus (\"+). You can use them to access copied text from external programs.\nIf you are on an external program (like Chrome browser) and you copy a block of text with Ctrl-C (or Cmd-C, depending on your OS), normally you wouldn’t be able to use p to paste the text in Vim. However, both Vim’s \"+ and \"* are connected to your clipboard, so you can actually paste the text with \"+p or \"*p. Conversely, if you yank a word from Vim with \"+yiw or \"*yiw, you can paste that text in the external program with Ctrl-V (or Cmd-V). Note that this only works if your Vim program comes with the +clipboard option (to check it, run :version).\nYou may wonder if \"* and \"+ do the same thing, why does Vim have two different registers? Some machines use X11 window system. This system has 3 types of selections: primary, secondary, and clipboard. If your machine uses X11, Vim uses X11’s primary selection with the quotestar (\"*) register and X11’s clipboard selection with the quoteplus (\"+) register. This is only applicable if you have +xterm_clipboard option available in your Vim build. If your Vim doesn’t have xterm_clipboard, it’s not a big deal. It just means that both quotestar and quoteplus are interchangeable (mine doesn’t either).\nI find doing =*p or =+p (or \"*p or \"+p) to be cumbersome. To make Vim to paste copied text from the external program with just p, you can add this in your vimrc:\nset clipboard=unnamed\nNow when I copy a text from an external program, I can paste it with the unnamed register, p. I can also copy a text from Vim and paste it to an external program. If you have +xterm_clipboard on, you may want to use both unnamed and unnamedplus clipboard options."
  },
  {
    "objectID": "chapters/ch08_registers.md.html#the-black-hole-register",
    "href": "chapters/ch08_registers.md.html#the-black-hole-register",
    "title": "8  Ch08. Registers",
    "section": "8.12 The Black Hole Register",
    "text": "8.12 The Black Hole Register\nEach time you delete or change a text, that text is stored in Vim register automatically. There will be times when you don’t want to save anything into the register. How can you do that?\nYou can use the black hole register (\"_). To delete a line and not have Vim store the deleted line into any register, use \"_dd.\nThe black hole register is like the /dev/null of registers."
  },
  {
    "objectID": "chapters/ch08_registers.md.html#the-last-search-pattern-register",
    "href": "chapters/ch08_registers.md.html#the-last-search-pattern-register",
    "title": "8  Ch08. Registers",
    "section": "8.13 The Last Search Pattern Register",
    "text": "8.13 The Last Search Pattern Register\nTo paste your last search (/ or ?), you can use the last search pattern register (\"/). To paste the last search term, use \"/p."
  },
  {
    "objectID": "chapters/ch08_registers.md.html#viewing-the-registers",
    "href": "chapters/ch08_registers.md.html#viewing-the-registers",
    "title": "8  Ch08. Registers",
    "section": "8.14 Viewing the Registers",
    "text": "8.14 Viewing the Registers\nTo view all your registers, use the :register command. To view only registers a,1, and “-, use :register a 1 -.\nThere is a plugin called vim-peekaboo that lets you to peek into the contents of the registers when you hit \" or @ in normal mode and Ctrl-R in insert mode. I find this plugin very useful because most times, I can’t remember the content in my registers. Give it a try!"
  },
  {
    "objectID": "chapters/ch08_registers.md.html#executing-a-register",
    "href": "chapters/ch08_registers.md.html#executing-a-register",
    "title": "8  Ch08. Registers",
    "section": "8.15 Executing a Register",
    "text": "8.15 Executing a Register\nThe named registers are not just for storing texts. They can also execute macros with @. I will go over macros in the next chapter.\nKeep in mind since macros are stored inside Vim registers, you can accidentally overwrite the stored text with macros. If you store the text Hello Vim in register a and you later record a macro in the same register (qa{macro-sequence}q), that macro will overwrite your Hello Vim text stored earlier."
  },
  {
    "objectID": "chapters/ch08_registers.md.html#clearing-a-register",
    "href": "chapters/ch08_registers.md.html#clearing-a-register",
    "title": "8  Ch08. Registers",
    "section": "8.16 Clearing a Register",
    "text": "8.16 Clearing a Register\nTechnically, there is no need to clear any register because the next text that you store under the same register name will overwrite it. However, you can quickly clear any named register by recording an empty macro. For example, if you run qaq, Vim will record an empty macro in the register a.\nAnother alternative is to run the command :call setreg('a', 'hello register a') where a is the register a and hello register a is the text that you want to store.\nOne more way to clear register is to set the content of “a register to an empty string with the expression :let @a = ''."
  },
  {
    "objectID": "chapters/ch08_registers.md.html#putting-the-content-of-a-register",
    "href": "chapters/ch08_registers.md.html#putting-the-content-of-a-register",
    "title": "8  Ch08. Registers",
    "section": "8.17 Putting the Content of a Register",
    "text": "8.17 Putting the Content of a Register\nYou can use the :put command to paste the content of any one register. For example, if you run :put a, Vim will print the content of register a below the current line. This behaves much like \"ap, with the difference that the normal mode command p prints the register content after the cursor and the command :put prints the register content at newline.\nSince :put is a command-line command, you can pass it an address. :10put a will paste text from register a to below line 10.\nOne cool trick to pass :put with the black hole register (\"_). Since the black hole register does not store any text, :put _ will insert a blank line instead. You can combine this with the global command to insert multiple blank lines. For example, to insert blank lines below all lines that contain the text end, run :g/end/put _. You will learn about the global command later."
  },
  {
    "objectID": "chapters/ch08_registers.md.html#learning-registers-the-smart-way",
    "href": "chapters/ch08_registers.md.html#learning-registers-the-smart-way",
    "title": "8  Ch08. Registers",
    "section": "8.18 Learning Registers the Smart Way",
    "text": "8.18 Learning Registers the Smart Way\nYou made it to the end. Congratulations! If you are feeling overwhelmed by the sheer information, you are not alone. When I first started learning about Vim registers, there were way too much information to take at once.\nI don’t think you should memorize all the registers immediately. To become productive, you can start by using only these 3 registers: 1. The unnamed register (\"\"). 2. The named registers (\"a-z). 3. The numbered registers (\"0-9).\nSince the unnamed register defaults to p and P, you only have to learn two registers: the named registers and the numbered registers. Gradually learn more registers when you need them. Take your time.\nThe average human has a limited short-term memory capacity, about 5 - 7 items at once. That is why in my everyday editing, I only use about 5 - 7 named registers. There is no way I can remember all twenty-six in my head. I normally start with register a, then b, ascending the alphabetical order. Try it and experiment around to see what technique works best for you.\nVim registers are powerful. Used strategically, it can save you from typing countless repeating texts. Next, let’s learn about macros."
  },
  {
    "objectID": "chapters/ch09_macros.md.html#basic-macros",
    "href": "chapters/ch09_macros.md.html#basic-macros",
    "title": "9  Ch09. Macros",
    "section": "9.1 Basic Macros",
    "text": "9.1 Basic Macros\nHere is the basic syntax of a Vim macro:\nqa                     Start recording a macro in register a\nq (while recording)    Stop recording macro\nYou can choose any lowercase letters (a-z) to store macros. Here is how you can execute a macro:\n@a    Execute macro from register a\n@@    Execute the last executed macros\nSuppose you have this text and you want to uppercase everything on each line:\nhello\nvim\nmacros\nare\nawesome\nWith your cursor at the start of the line hello, run:\nqa0gU$jq\nThe breakdown: - qa starts recording a macro in the a register. - 0 goes to beginning of the line. - gU$ uppercases the text from your current location to the end of the line. - j goes down one line. - q stops recording.\nTo replay it, run @a. Just like many other Vim commands, you can pass a count argument to macros. For example, running 3@a executes the macro three times."
  },
  {
    "objectID": "chapters/ch09_macros.md.html#safety-guard",
    "href": "chapters/ch09_macros.md.html#safety-guard",
    "title": "9  Ch09. Macros",
    "section": "9.2 Safety Guard",
    "text": "9.2 Safety Guard\nMacro execution automatically ends when it encounters an error. Suppose you have this text:\na. chocolate donut\nb. mochi donut\nc. powdered sugar donut\nd. plain donut\nIf you want to uppercase the first word on each line, this macro should work:\nqa0W~jq\nHere’s the breakdown of the command above: - qa starts recording a macro in the a register. - 0 goes to the beginning of the line. - W goes to the next WORD. - ~ toggles the case of the character under the cursor. - j goes down one line. - q stops recording.\nI prefer to overcount my macro execution than undercount it, so I usually call it ninety-nine times (99@a). With this command, Vim does not actually run this macro ninety-nine times. When Vim reaches the last line and runs j motion, it finds no more line to go down to, throws an error, and stops the macro execution.\nThe fact that macro execution stops upon the first error encounter is a good feature, otherwise Vim will continue to execute this macro ninety-nine times even though it already reaches the end of the line."
  },
  {
    "objectID": "chapters/ch09_macros.md.html#command-line-macro",
    "href": "chapters/ch09_macros.md.html#command-line-macro",
    "title": "9  Ch09. Macros",
    "section": "9.3 Command Line Macro",
    "text": "9.3 Command Line Macro\nRunning @a in normal mode is not the only way you can execute macros in Vim. You can also run :normal @a command line. :normal allows the user to execute any normal mode command passed as argument. In the case above, it is the same as running @a from normal mode.\nThe :normal command accepts range as arguments. You can use this to run macro in select ranges. If you want to execute your macro between lines 2 and 3, you can run :2,3 normal @a."
  },
  {
    "objectID": "chapters/ch09_macros.md.html#executing-a-macro-across-multiple-files",
    "href": "chapters/ch09_macros.md.html#executing-a-macro-across-multiple-files",
    "title": "9  Ch09. Macros",
    "section": "9.4 Executing a Macro Across Multiple Files",
    "text": "9.4 Executing a Macro Across Multiple Files\nSuppose you have multiple .txt files, each contains some texts. Your task is to uppercase the first word only on lines containing the word donut. Assume you have 0W~j in register a (the same macro as before). How can you quickly accomplish this?\nFirst file:\n## savory.txt\na. cheddar jalapeno donut\nb. mac n cheese donut\nc. fried dumpling\nSecond file:\n## sweet.txt\na. chocolate donut\nb. chocolate pancake\nc. powdered sugar donut\nThird file:\n## plain.txt\na. wheat bread\nb. plain donut\nHere is how you can do it: - :args *.txt to find all .txt files in your current directory. - :argdo g/donut/normal @a executes the global command g/donut/normal @a on each file inside :args. - :argdo update executes update command to save each file inside :args when the buffer has been modified.\nIf you are not familiar with the global command :g/donut/normal @a, it executes the command you give (normal @a) on lines that match the pattern (/donut/). I will go over the global command in a later chapter."
  },
  {
    "objectID": "chapters/ch09_macros.md.html#recursive-macro",
    "href": "chapters/ch09_macros.md.html#recursive-macro",
    "title": "9  Ch09. Macros",
    "section": "9.5 Recursive Macro",
    "text": "9.5 Recursive Macro\nYou can recursively execute a macro by calling the same macro register while recording that macro. Suppose you have this list again and you need to toggle the case of the first word:\na. chocolate donut\nb. mochi donut\nc. powdered sugar donut\nd. plain donut\nThis time, let’s do it recursively. Run:\nqaqqa0W~j@aq\nHere is the breakdown of the steps: - qaq records an empty macro a. It is necessary to start with an empty register because when you recursively call the macro, it will run whatever is in that register. - qa starts recording on register a. - 0 goes to the first character in the current line. - W goes to the next WORD. - ~ toggles the case of the character under the cursor. - j goes down one line. - @a executes macro a. - q stops recording.\nNow you can just run @a and watch Vim execute the macro recursively.\nHow did the macro know when to stop? When the macro was on the last line, it triedto run j, since there was no more line to go to, it stopped the macro execution."
  },
  {
    "objectID": "chapters/ch09_macros.md.html#appending-a-macro",
    "href": "chapters/ch09_macros.md.html#appending-a-macro",
    "title": "9  Ch09. Macros",
    "section": "9.6 Appending a Macro",
    "text": "9.6 Appending a Macro\nIf you need to add actions to an existing macro, instead of recreating the macro from scratch, you can append actions to an existing one. In the register chapter, you learned that you can append a named register by using its uppercased symbol. The same rule applies. To append actions to register a macro, use register A.\nRecord a macro in register a: qa0W~q (this sequence toggles the case of the next WORD in a line). If you want to append a new sequence to also add a dot at the end of the line, run:\nqAA.<Esc>q\nThe breakdown: - qA starts recording the macro in register A. - A.<Esc> inserts at the end of the line (here A is the insert mode command, not to be confused with the macro A) a dot, then exits insert mode. - q stops recording macro.\nNow when you execute @a, it not only toggles the case of the next WORD, it also adds a dot at the end of the line."
  },
  {
    "objectID": "chapters/ch09_macros.md.html#amending-a-macro",
    "href": "chapters/ch09_macros.md.html#amending-a-macro",
    "title": "9  Ch09. Macros",
    "section": "9.7 Amending a Macro",
    "text": "9.7 Amending a Macro\nWhat if you need to add new actions in the middle of a macro?\nAssume that you have a macro that toggles the first actual word and adding a period at the end of the line, 0W~A.<Esc> in register a. Suppose that between uppercasing the first word and adding a period at the end of the line, you need to add the word deep fried right before the word donut (because the only thing better than regular donuts are deep fried donuts).\nI will reuse the text from earlier section:\na. chocolate donut\nb. mochi donut\nc. powdered sugar donut\nd. plain donut\nFirst, let’s call the existing macro (assume you have kept the macro from the previous section in register a) with :put a:\n0W~A.^[\nWhat is this ^[? Didn’t you do 0W~A.<Esc>? Where is the <Esc>? ^[ is Vim’s internal code representation of <Esc>. With certain special keys, Vim prints the representation of those keys in the form of internal codes. Some common keys that have internal code representations are <Esc>, <Backspace>, and <Enter>. There are more special keys, but they are not within the scope of this chapter.\nBack to the macro, right after the toggle case operator (~), let’s add the instructions to go to the end of the line ($), go back one word (b), go to the insert mode (i), type deep fried (don’t forget the space after fried), and exit insert mode (<Esc>).\nHere is what you will end up with:\n0W~$bideep fried <Esc>A.^[\nThere is a small problem. Vim does not understand <Esc>. You can’t literally type <Esc>. You will have to write the internal code representation for the <Esc> key. While in insert mode, you press Ctrl-V followed by <Esc>. Vim will print ^[.Ctrl-V is an insert mode operator to insert the next non-digit character literally. Your macro code should look like this now:\n0W~$bideep fried ^[A.^[\nTo add the amended instruction into register a, you can do it the same way as adding a new entry into a named register. At the start of the line, run \"ay$ to store the yanked text in register a.\nNow when you execute @a, your macro will toggle the case of the first word, add deep fried before donut, and add a . at the end of the line. Yum!\nAn alternative way to amend a macro is to use a command line expression. Do :let @a=\", then do Ctrl-R a, this will literally paste the content of register a. Finally, don’t forget to close the double quotes (\"). You might have something like :let @a=\"0W~$bideep fried ^[A.^[\"."
  },
  {
    "objectID": "chapters/ch09_macros.md.html#macro-redundancy",
    "href": "chapters/ch09_macros.md.html#macro-redundancy",
    "title": "9  Ch09. Macros",
    "section": "9.8 Macro Redundancy",
    "text": "9.8 Macro Redundancy\nYou can easily duplicate macros from one register to another. For example, to duplicate a macro in register a to register z, you can do :let @z = @a. @a represents the content of register a. Now if you run @z, it does the exact same actions as @a.\nI find creating a redundancy useful on my most frequently used macros. In my workflow, I usually record macros in the first seven alphabetical letters (a-g) and I often replace them without much thought. If I move the useful macros towards the end of the alphabets, I can preserve them without worrying that I might accidentally replace them."
  },
  {
    "objectID": "chapters/ch09_macros.md.html#series-vs-parallel-macro",
    "href": "chapters/ch09_macros.md.html#series-vs-parallel-macro",
    "title": "9  Ch09. Macros",
    "section": "9.9 Series vs Parallel Macro",
    "text": "9.9 Series vs Parallel Macro\nVim can execute macros in series and parallel. Suppose you have this text:\nimport { FUNC1 } from \"library1\";\nimport { FUNC2 } from \"library2\";\nimport { FUNC3 } from \"library3\";\nimport { FUNC4 } from \"library4\";\nimport { FUNC5 } from \"library5\";\nIf you want to record a macro to lowercase all the uppercased FUNC, this macro should work:\nqa0f{gui{jq\nThe breakdown: - qa starts recording in register a. - 0 goes to first line. - f{ finds the first instance of {. - gui{ lowercases (gu) the text inside the bracket text-object (i{). - j goes down one line. - q stops macro recording.\nNow you can run 99@a to execute it on the remaining lines. However, what if you have this import expression inside your file?\nimport { FUNC1 } from \"library1\";\nimport { FUNC2 } from \"library2\";\nimport { FUNC3 } from \"library3\";\nimport foo from \"bar\";\nimport { FUNC4 } from \"library4\";\nimport { FUNC5 } from \"library5\";\nRunning 99@a, only executes the macro three times. It does not execute the macro on last two lines because the execution fails to run f{ on the foo line. This is expected when running the macro in series. You can always go to the next line where FUNC4 is and replay that macro again. But what if you want to get everything done in one go?\nRun the macro in parallel.\nRecall from earlier section that macros can be executed using the command line command :normal (ex: :3,5 normal @a executes macro a on lines 3-5). If you run :1,$ normal @a, you will see that the macro is being executed on all lines except the foo line. It works!\nAlthough internally Vim does not actually run the macros in parallel, outwardly, it behaves like it. Vim executes @a independently on each line from the first to the last line (1,$). Since Vim executes these macros independently, each line does not know that one of the macro executions had failed on the foo line."
  },
  {
    "objectID": "chapters/ch09_macros.md.html#learn-macros-the-smart-way",
    "href": "chapters/ch09_macros.md.html#learn-macros-the-smart-way",
    "title": "9  Ch09. Macros",
    "section": "9.10 Learn Macros the Smart Way",
    "text": "9.10 Learn Macros the Smart Way\nMany things you do in editing are repetitive. To get better at editing, get into the habit of detecting repetitive actions. Use macros (or dot command) so you don’t have to perform the same action twice. Almost everything that you can do in Vim can be replicated with macros.\nIn the beginning, I find it very awkward to write macros, but don’t give up. With enough practice, you will get into the habit of automating everything.\nYou might find it helpful to use mnemonics to help remember your macros. If you have a macro that creates a function, use the f register (qf). If you have a macro for numerical operations, then register should work (qn). Name it with the first named register that comes to your mind when you think of that operation. I also find that the “q register makes a good default macro register because qq requires less brain power to come up with. Lastly, I also like to increment my macros in alphabetical orders, like qa, then qb, then qc, and so on.\nFind a method that works best for you."
  },
  {
    "objectID": "chapters/ch10_undo.md.html#undo-redo-and-undo",
    "href": "chapters/ch10_undo.md.html#undo-redo-and-undo",
    "title": "10  Ch10. Undo",
    "section": "10.1 Undo, Redo, and UNDO",
    "text": "10.1 Undo, Redo, and UNDO\nTo perform a basic undo, you can use u or run :undo.\nIf you have this text (note the empty line below one):\none\n\nThen you add another text:\none\ntwo\nIf you press u, Vim undoes the text two.\nHow does Vim know how much to undo? Vim undoes a single change at a time, similar to a dot command’s change (unlike the dot command, command-line command also count as a change).\nTo redo the last change, press Ctrl-R or run :redo. After you undo the text above to remove two, running Ctrl-R will get the removed text back.\nVim also has UNDO that you can run with U. It undoes all latest changes.\nHow is U different from u? First, U removes all the changes on the latest changed line, while u only removes one change at a time. Second, while doing u does not count as a change, doing U counts as a change.\nBack to this example:\none\ntwo\nChange the second line to three:\none\nthree\nChange the second line again and replace it with four:\none\nfour\nIf you press u, you will see three. If you press u again, you’ll see two. If instead of pressing u when you still had the text four, you had pressed U, you will see:\none\n\nU bypasses all the intermediary changes and goes to the original state when you started (an empty line). In addition, since UNDO actually creates a new change in Vim, you can UNDO your UNDO. U followed by U will undo itself. You can press U, then U, then U, etc. You will see the same two text states toggling back and forth.\nI personally do not use U because it is hard to remember the original state (I seldom ever need it).\nVim sets a maximum number of how many times you can undo in undolevels option variable. You can check it with :echo &undolevels. I have mine set to be 1000. To change yours to 1000, run :set undolevels=1000. Feel free to set it to any number you like."
  },
  {
    "objectID": "chapters/ch10_undo.md.html#breaking-the-blocks",
    "href": "chapters/ch10_undo.md.html#breaking-the-blocks",
    "title": "10  Ch10. Undo",
    "section": "10.2 Breaking the Blocks",
    "text": "10.2 Breaking the Blocks\nI mentioned earlier that u undoes a single change similar to the dot command’s change: the texts inserted from when you enter the insert mode until you exit it count as a change.\nIf you do ione two three<Esc> then press u, Vim removes the entire one two three text because the whole thing counts as a change. This is not a big deal if you have written short texts, but what if you have written several paragraphs within one insert mode session without exiting and later you realized you made a mistake? If you press u, everything you had written would be removed. Wouldn’t it be useful if you can press u to remove only a section of your text?\nLuckily, you can break the undo blocks. When you are typing in insert mode, pressing Ctrl-G u creates an undo breakpoint. For example, if you do ione <Ctrl-G u>two <Ctrl-G u>three<Esc>, then press u, you will only lose the text three (press u one more time to remove two). When you write a long text, use Ctrl-G u strategically. The end of each sentence, between two paragraphs, or after each line of code are prime locations to add undo breakpoints to make it easier to undo your mistakes if you ever make one.\nIt is also useful to create an undo breakpoint when deleting chunks in insert mode with Ctrl-W (delete the word before the cursor) and Ctrl-U (delete all text before the cursor). A friend suggested to use the following maps:\ninoremap <c-u> <c-g>u<c-u>\ninoremap <c-w> <c-g>u<c-w>\nWith these, you can easily recover the deleted texts."
  },
  {
    "objectID": "chapters/ch10_undo.md.html#undo-tree",
    "href": "chapters/ch10_undo.md.html#undo-tree",
    "title": "10  Ch10. Undo",
    "section": "10.3 Undo Tree",
    "text": "10.3 Undo Tree\nVim stores every change ever written in an undo tree. Start a new empty file. Then add a new text:\none\n\nAdd a new text:\none\ntwo\nUndo once:\none\n\nAdd a different text:\none\nthree\nUndo again:\none\n\nAnd add another different text:\none\nfour\nNow if you undo, you will lose the text four you just added:\none\n\nIf you undo one more time:\n\nYou will lose the text one. In most text editor, getting the texts two and three back would have been impossible, but not with Vim! Press g+ and you’ll get your text one back:\none\n\nType g+ again and you will see an old friend:\none\ntwo\nLet’s keep going. Press g+ again:\none\nthree\nPress g+ one more time:\none\nfour\nIn Vim, every time you press u and then make a different change, Vim stores the previous state’s text by creating an undo branch. In this example, after you typed two, then pressed u, then typed three, you created an leaf branch that stores the state containing the text two. At that moment, the undo tree contained at least two leaf nodes: the main node containing the text three (most recent) and the undo branch node containing the text two. If you had done another undo and typed the text four, you would have at three nodes: a main node containing the text four and two nodes containing the texts three and two.\nTo traverse each undo tree nodes, you can use g+ to go to a newer state and g- to go to an older state. The difference between u, Ctrl-R, g+, and g- is that both u and Ctrl-R traverse only the main nodes in undo tree while g+ and g- traverse all nodes in the undo tree.\nUndo tree is not easy to visualize. I find vim-mundo plugin to be very useful to help visualize Vim’s undo tree. Give it some time to play around with it."
  },
  {
    "objectID": "chapters/ch10_undo.md.html#persistent-undo",
    "href": "chapters/ch10_undo.md.html#persistent-undo",
    "title": "10  Ch10. Undo",
    "section": "10.4 Persistent Undo",
    "text": "10.4 Persistent Undo\nIf you start Vim, open a file, and immediately press u, Vim will probably display Already at oldest change warning. There is nothing to undo because you haven’t made any changes.\nTo rollover the undo history from the last editing session, Vim can preserve your undo history with an undo file with :wundo.\nCreate a file mynumbers.txt. Type:\none\nThen type another line (make sure each line counts as a change):\none\ntwo\nType another line:\none\ntwo\nthree\nNow create your undo file with :wundo {my-undo-file}. If you need to overwrite an existing undo file, you can add ! after wundo.\n:wundo! mynumbers.undo\nThen exit Vim.\nBy now you should have mynumbers.txt and mynumbers.undo files in your directory. Open up mynumbers.txt again and try pressing u. You can’t. You haven’t made any changes since you opened the file. Now load your undo history by reading the undo file with :rundo:\n:rundo mynumbers.undo\nNow if you press u, Vim removes three. Press u again to remove two. It is like you never even closed Vim!\nIf you want to have an automatic undo persistence, one way to do it is by adding these in vimrc:\nset undodir=~/.vim/undo_dir\nset undofile\nThe setting above will put all the undofile in one centralized directory, the ~/.vim directory. The name undo_dir is arbitrary. set undofile tells Vim to turn on undofile feature because it is off by default. Now whenever you save, Vim automatically creates and updates the relevant file inside the undo_dir directory (make sure that you create the actual undo_dir directory inside ~/.vim directory before running this)."
  },
  {
    "objectID": "chapters/ch10_undo.md.html#time-travel",
    "href": "chapters/ch10_undo.md.html#time-travel",
    "title": "10  Ch10. Undo",
    "section": "10.5 Time Travel",
    "text": "10.5 Time Travel\nWho says that time travel doesn’t exist? Vim can travel to a text state in the past with :earlier command-line command.\nIf you have this text:\none\n\nThen later you add:\none\ntwo\nIf you had typed two less than ten seconds ago, you can go back to the state where two didn’t exist ten seconds ago with:\n:earlier 10s\nYou can use :undolist to see when the last change was made. :earlier also accepts different arguments:\n:earlier 10s    Go to the state 10 seconds before\n:earlier 10m    Go to the state 10 minutes before\n:earlier 10h    Go to the state 10 hours before\n:earlier 10d    Go to the state 10 days before\nIn addition, it also accepts a regular count as argument to tell Vim to go to the older state count times. For example, if you do :earlier 2, Vim will go back to an older text state two changes ago. It is the same as doing g- twice. You can also tell it to go to the older text state 10 saves ago with :earlier 10f.\nThe same set of arguments work with :earlier counterpart: :later.\n:later 10s    go to the state 10 seconds later\n:later 10m    go to the state 10 minutes later\n:later 10h    go to the state 10 hours later\n:later 10d    go to the state 10 days later\n:later 10     go to the newer state 10 times\n:later 10f    go to the state 10 saves later"
  },
  {
    "objectID": "chapters/ch10_undo.md.html#learn-undo-the-smart-way",
    "href": "chapters/ch10_undo.md.html#learn-undo-the-smart-way",
    "title": "10  Ch10. Undo",
    "section": "10.6 Learn Undo the Smart Way",
    "text": "10.6 Learn Undo the Smart Way\nu and Ctrl-R are two indispensable Vim commands for correcting mistakes. Learn them first. Next, learn how to use :earlier and :later using the time arguments first. After that, take your time to understand the undo tree. The vim-mundo plugin helped me a lot. Type along the texts in this chapter and check the undo tree as you make each change. Once you grasp it, you will never see undo system the same way again.\nPrior to this chapter, you learned how to find any text in a project space, with undo, you can now find any text in a time dimension. You are now able to search for any text by its location and time written. You have achieved Vim-omnipresence."
  },
  {
    "objectID": "chapters/ch11_visual_mode.md.html#the-three-types-of-visual-modes",
    "href": "chapters/ch11_visual_mode.md.html#the-three-types-of-visual-modes",
    "title": "11  Ch11. Visual Mode",
    "section": "11.1 The Three Types of Visual Modes",
    "text": "11.1 The Three Types of Visual Modes\nVim has three different visual modes. They are:\nv         Character-wise visual mode\nV         Line-wise visual mode\nCtrl-V    Block-wise visual mode\nIf you have the text:\none\ntwo\nthree\nCharacter-wise visual mode works with individual characters. Press v on the first character. Then go down to the next line with j. It highlights all texts from one up to your cursor location. If you press gU, Vim uppercases the highlighted characters.\nLine-wise visual mode works with lines. Press V and watch Vim selects the entire line your cursor is on. Just like character-wise visual mode, if you run gU, Vim uppercases the highlighted characters.\nBlock-wise visual mode works with rows and columns. It gives you more freedom of movement than the other two modes. If you press Ctrl-V, Vim highlights the character under the cursor just like character-wise visual mode, except instead of highlighting each character until the end of the line before going down to the next line, it goes to the next line with minimal highlighting. Try moving around with h/j/k/l and watch the cursor move.\nOn the bottom left of your Vim window, you will see either -- VISUAL --, -- VISUAL LINE --, or -- VISUAL BLOCK -- displayed to indicate which visual mode you are in.\nWhile you are inside a visual mode, you can switch to another visual mode by pressing either v, V, or Ctrl-V. For example, if you are in line-wise visual mode and you want to switch to block-wise visual mode, run Ctrl-V. Try it!\nThere are three ways to exit the visual mode: <Esc>, Ctrl-C, and the same key as your current visual mode. What the latter means is if you are currently in the line-wise visual mode (V), you can exit it by pressing V again. If you are in the character-wise visual mode, you can exit it by pressing v.\nThere is actually one more way to enter the visual mode:\ngv    Go to the previous visual mode\nIt will start the same visual mode on the same highlighted text block as you did last time."
  },
  {
    "objectID": "chapters/ch11_visual_mode.md.html#visual-mode-navigation",
    "href": "chapters/ch11_visual_mode.md.html#visual-mode-navigation",
    "title": "11  Ch11. Visual Mode",
    "section": "11.2 Visual Mode Navigation",
    "text": "11.2 Visual Mode Navigation\nWhile in a visual mode, you can expand the highlighted text block with Vim motions.\nLet’s use the same text you used earlier:\none\ntwo\nthree\nThis time let’s start from the line two. Press v to go to the character-wise visual mode (here the square brackets [] represent the character highlights):\none\n[t]wo\nthree\nPress j and Vim will highlight all the text from the line two down to the first character of the line three.\none\n[two\nt]hree\nAssume from this position, you want to add the line one too. If you press k, to your dismay, the highlight moves away from the line three.\none\n[t]wo\nthree\nIs there a way to freely expand visual selection to move in any direction you want? Definitely. Let’s back up a little bit to where you have the line two and three highlighted.\none\n[two\nt]hree    <-- cursor\nVisual highlight follows the cursor movement. If you want to expand it upward to the line one, you need to move the cursor up to the line two. Right now the cursor is on the line three. You can toggle the cursor location with either o or O.\none\n[two     <-- cursor\nt]hree\nNow when you press k, it no longer reduces the selection, but expands it upward.\n[one\ntwo\nt]hree\nWith o or O in visual mode, the cursor jumps from the beginning to the end of the highlighted block, allowing you to expand the highlight area."
  },
  {
    "objectID": "chapters/ch11_visual_mode.md.html#visual-mode-grammar",
    "href": "chapters/ch11_visual_mode.md.html#visual-mode-grammar",
    "title": "11  Ch11. Visual Mode",
    "section": "11.3 Visual Mode Grammar",
    "text": "11.3 Visual Mode Grammar\nThe visual mode shares many operations with normal mode.\nFor example, if you have the following text and you want to delete the first two lines from visual mode:\none\ntwo\nthree\nHighlight the lines one and two with the line-wise visual mode (V):\n[one\ntwo]\nthree\nPressing d will delete the selection, similar to normal mode. Notice the grammar rule from normal mode, verb + noun, does not apply. The same verb is still there (d), but there is no noun in visual mode. The grammar rule in visual mode is noun + verb, where noun is the highlighted text. Select the text block first, then the command follows.\nIn normal mode, there are some commands that do not require a motion, like x to delete a single character under the cursor and r to replace the character under the cursor (rx replaces the character under the cursor with x). In visual mode, these commands are now being applied to the entire highlighted text instead of a single character. Back at the highlighted text:\n[one\ntwo]\nthree\nRunning x deletes all highlighted texts.\nYou can use this behavior to quickly create a header in markdown text. Suppose you need to quickly turn the following text into a first-level markdown header (===):\nChapter One\nFirst, copy the text with yy, then paste it with p:\nChapter One\nChapter One\nNow, go to the second line and select it with line-wise visual mode:\nChapter One\n[Chapter One]\nA first-level header is a series of = below a text. Run r=, voila! This saves you from typing = manually.\nChapter One\n===========\nTo learn more about operators in visual mode, check out :h visual-operators."
  },
  {
    "objectID": "chapters/ch11_visual_mode.md.html#visual-mode-and-command-line-commands",
    "href": "chapters/ch11_visual_mode.md.html#visual-mode-and-command-line-commands",
    "title": "11  Ch11. Visual Mode",
    "section": "11.4 Visual Mode and Command-line Commands",
    "text": "11.4 Visual Mode and Command-line Commands\nYou can selectively apply command-line commands on a highlighted text block. If you have these statements and you want to substitute const with let only on the first two lines:\nconst one = \"one\";\nconst two = \"two\";\nconst three = \"three\";\nHighlight the first two lines with any visual mode and run the substitute command :s/const/let/g:\nlet one = \"one\";\nlet two = \"two\";\nconst three = \"three\";\nNotice I said you can do this with any visual mode. You do not have to highlight the entire line to run the command on that line. As long as you select at least a character on each line, the command is applied."
  },
  {
    "objectID": "chapters/ch11_visual_mode.md.html#adding-text-on-multiple-lines",
    "href": "chapters/ch11_visual_mode.md.html#adding-text-on-multiple-lines",
    "title": "11  Ch11. Visual Mode",
    "section": "11.5 Adding Text on Multiple Lines",
    "text": "11.5 Adding Text on Multiple Lines\nYou can add text on multiple lines in Vim using the block-wise visual mode. If you need to add a semicolon at the end of each line:\nconst one = \"one\"\nconst two = \"two\"\nconst three = \"three\"\nWith your cursor on the first line: - Run block-wise visual mode and go down two lines (Ctrl-V jj). - Highlight to the end of the line ($). - Append (A) then type ;. - Exit visual mode (<Esc>).\nYou should see the appended ; on each line now. Pretty cool! There are two ways to enter the insert mode from block-wise visual mode: A to enter the text after the cursor or I to enter the text before the cursor. Do not confuse them with A (append text at the end of the line) and I (insert text before the first non-blank line) from normal mode.\nAlternatively, you can also use the :normal command to add text on multiple lines: - Highlight all 3 lines (vjj). - Type :normal! A;.\nRemember, :normal command executes normal mode commands. You can instruct it to run A; to append text ; at the end of the line."
  },
  {
    "objectID": "chapters/ch11_visual_mode.md.html#incrementing-numbers",
    "href": "chapters/ch11_visual_mode.md.html#incrementing-numbers",
    "title": "11  Ch11. Visual Mode",
    "section": "11.6 Incrementing Numbers",
    "text": "11.6 Incrementing Numbers\nVim has Ctrl-X and Ctrl-A commands to decrement and increment numbers. When used with visual mode, you can increment numbers across multiple lines.\nIf you have these HTML elements:\n<div id=\"app-1\"></div>\n<div id=\"app-1\"></div>\n<div id=\"app-1\"></div>\n<div id=\"app-1\"></div>\n<div id=\"app-1\"></div>\nIt is a bad practice to have several ids having the same name, so let’s increment them to make them unique: - Move your cursor to the 1 on the second line. - Start block-wise visual mode and go down 3 lines (Ctrl-V 3j). This highlights the remaining 1s. Now all 1 should be highlighted (except the first line). - Run g Ctrl-A.\nYou should see this result:\n<div id=\"app-1\"></div>\n<div id=\"app-2\"></div>\n<div id=\"app-3\"></div>\n<div id=\"app-4\"></div>\n<div id=\"app-5\"></div>\ng Ctrl-A increments numbers on multiple lines. Ctrl-X/Ctrl-A can increment letters too, with the number formats option:\nset nrformats+=alpha\nThe nrformats option instructs Vim which bases are considered as numbers for Ctrl-A and Ctrl-X to increment and decrement. By adding alpha, an alphabetical character is now considered as a number. If you have the following HTML elements:\n<div id=\"app-a\"></div>\n<div id=\"app-a\"></div>\n<div id=\"app-a\"></div>\n<div id=\"app-a\"></div>\n<div id=\"app-a\"></div>\nPut your cursor on the second app-a. Use the same technique as above (Ctrl-V 3j then g Ctrl-A) to increment the ids.\n<div id=\"app-a\"></div>\n<div id=\"app-b\"></div>\n<div id=\"app-c\"></div>\n<div id=\"app-d\"></div>\n<div id=\"app-e\"></div>"
  },
  {
    "objectID": "chapters/ch11_visual_mode.md.html#selecting-the-last-visual-mode-area",
    "href": "chapters/ch11_visual_mode.md.html#selecting-the-last-visual-mode-area",
    "title": "11  Ch11. Visual Mode",
    "section": "11.7 Selecting the Last Visual Mode Area",
    "text": "11.7 Selecting the Last Visual Mode Area\nEarlier in this chapter, I mentioned that gv can quickly highlight the last visual mode highlight. You can also go to the location of the start and the end of the last visual mode with these two special marks:\n`<    Go to the first place of the previous visual mode highlight\n`>    Go to the last place of the previous visual mode highlight\nEarlier, I also mentioned that you can selectively execute command-line commands on a highlighted text, like :s/const/let/g. When you did that, you’d see this below:\n:`<,`>s/const/let/g\nYou were actually executing a ranged s/const/let/g command (with the two marks as the addresses). Interesting!\nYou can always edit these marks anytime you wish. If instead you needed to substitute from the start of the highlighted text to the end of the file, you just change the command to:\n:`<,$s/const/let/g"
  },
  {
    "objectID": "chapters/ch11_visual_mode.md.html#entering-visual-mode-from-insert-mode",
    "href": "chapters/ch11_visual_mode.md.html#entering-visual-mode-from-insert-mode",
    "title": "11  Ch11. Visual Mode",
    "section": "11.8 Entering Visual Mode From Insert Mode",
    "text": "11.8 Entering Visual Mode From Insert Mode\nYou can also enter visual mode from the insert mode. To go to character-wise visual mode while you are in insert mode:\nCtrl-O v\nRecall that running Ctrl-O while in the insert mode lets you execute a normal mode command. While in this normal-mode-command-pending mode, run v to enter character-wise visual mode. Notice that on the bottom left of the screen, it says --(insert) VISUAL--. This trick works with any visual mode operator: v, V, and Ctrl-V."
  },
  {
    "objectID": "chapters/ch11_visual_mode.md.html#select-mode",
    "href": "chapters/ch11_visual_mode.md.html#select-mode",
    "title": "11  Ch11. Visual Mode",
    "section": "11.9 Select Mode",
    "text": "11.9 Select Mode\nVim has a mode similar to visual mode called the select mode. Like the visual mode, it also has three different modes:\ngh         Character-wise select mode\ngH         Line-wise select mode\ngCtrl-h    Block-wise select mode\nSelect mode emulates a regular editor’s text highlighting behavior closer than Vim’s visual mode does.\nIn a regular editor, after you highlight a text block and type a letter, say the letter y, it will delete the highlighted text and insert the letter y. If you highlight a line with line-wise select mode (gH) and type y, it will delete the highlighted text and insert the letter y.\nContrast this select mode with visual mode: if you highlight a line of text with line-wise visual mode (V) and type y, the highlighted text will not be deleted and replaced by the literal letter y, it will be yanked. You can’t execute normal mode commands on highlighted text in select mode.\nI personally never used select mode, but it’s good to know that it exists."
  },
  {
    "objectID": "chapters/ch11_visual_mode.md.html#learn-visual-mode-the-smart-way",
    "href": "chapters/ch11_visual_mode.md.html#learn-visual-mode-the-smart-way",
    "title": "11  Ch11. Visual Mode",
    "section": "11.10 Learn Visual Mode the Smart Way",
    "text": "11.10 Learn Visual Mode the Smart Way\nThe visual mode is Vim’s representation of the text highlighting procedure.\nIf you find yourself using visual mode operation far more often than normal mode operations, be careful. This is an anti-pattern. It takes more keystrokes to run a visual mode operation than its normal mode counterpart. For example, if you need to delete an inner word, why use four keystrokes, viwd (visually highlight an inner word then delete), if you can accomplish it with just three keystrokes (diw)? The latter is more direct and concise. Of course, there will be times when visual modes are appropriate, but in general, favor a more direct approach."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#smart-case-sensitivity",
    "href": "chapters/ch12_search_and_substitute.md.html#smart-case-sensitivity",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.1 Smart Case Sensitivity",
    "text": "12.1 Smart Case Sensitivity\nIt can be tricky trying to match the case of the search term. If you are searching for the text Learn Vim, you can easily mistype the case of one letter and get a false search result. Wouldn’t it be easier and safer if you can match any case? This is where the option ignorecase shines. Just add set ignorecase in your vimrc and all your search terms become case insensitive. Now you don’t have to do /Learn Vim anymore, /learn vim will work.\nHowever, there are times when you need to search for a case specific phrase. One way to do that is to turn off ignorecase option by running set noignorecase, but that is a lot of work to turn on and off each time you need to search for a case sensitive phrase.\nTo avoid toggling ignorecase, Vim has a smartcase option to search for case insensitive string if the search pattern contains at least one uppercase character. You can combine both ignorecase and smartcase to perform a case insensitive search when you enter all lowercase characters and a case sensitive search when you enter one or more uppercase characters.\nInside your vimrc, add:\nset ignorecase smartcase\nIf you have these texts:\nhello\nHELLO\nHello\n\n/hello matches hello, HELLO, and Hello.\n/HELLO matches only HELLO.\n/Hello matches only Hello.\n\nThere is one downside. What if you need to search for only a lowercase string? When you do /hello, Vim now does case insensitive search. You can use \\C pattern anywhere in your search term to tell Vim that the subsequent search term will be case sensitive. If you do /\\Chello, it will strictly match hello, not HELLO or Hello."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#first-and-last-character-in-a-line",
    "href": "chapters/ch12_search_and_substitute.md.html#first-and-last-character-in-a-line",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.2 First and Last Character in a Line",
    "text": "12.2 First and Last Character in a Line\nYou can use ^ to match the first character in a line and $ to match the last character in a line.\nIf you have this text:\nhello hello\nYou can target the first hello with /^hello. The character that follows ^ must be the first character in a line. To target the last hello, run /hello$. The character before $ must be the last character in a line.\nIf you have this text:\nhello hello friend\nRunning /hello$ will not match anything because friend is the last term in that line, not hello."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#repeating-search",
    "href": "chapters/ch12_search_and_substitute.md.html#repeating-search",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.3 Repeating Search",
    "text": "12.3 Repeating Search\nYou can repeat the previous search with //. If you have just searched for /hello, running // is equivalent to running /hello. This shortcut can save you some keystrokes especially if you just searched for a long string. Also recall that you can use n and N to repeat the last search with the same direction and opposite direction, respectively.\nWhat if you want to quickly recall n last search term? You can quickly traverse the search history by first pressing /, then press up/down arrow keys (or Ctrl-N/Ctrl-P) until you find the search term you need. To see all your search history, you can run :history /.\nWhen you reach the end of a file while searching, Vim throws an error: \"Search hit the BOTTOM without match for: {your-search}\". Sometimes this can be a good safeguard from oversearching, but other times you want to cycle the search back to the top again. You can use the set wrapscan option to make Vim to search back at the top of the file when you reach the end of the file. To turn this feature off, do set nowrapscan."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#searching-for-alternative-words",
    "href": "chapters/ch12_search_and_substitute.md.html#searching-for-alternative-words",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.4 Searching for Alternative Words",
    "text": "12.4 Searching for Alternative Words\nIt is common to search for multiple words at once. If you need to search for either hello vim or hola vim, but not salve vim or bonjour vim, you can use the | pattern.\nGiven this text:\nhello vim\nhola vim\nsalve vim\nbonjour vim\nTo match both hello and hola, you can do /hello\\|hola. You have to escape (\\) the or (|) operator, otherwise Vim will literally search for the string |.\nIf you don’t want to type \\| every time, you can use the magic syntax (\\v) at the start of the search: /\\vhello|hola. I will not cover magic in this guide, but with \\v, you don’t have to escape special characters anymore. To learn more about \\v, feel free to check out :h \\v."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#setting-the-start-and-end-of-a-match",
    "href": "chapters/ch12_search_and_substitute.md.html#setting-the-start-and-end-of-a-match",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.5 Setting the Start and End of a Match",
    "text": "12.5 Setting the Start and End of a Match\nMaybe you need to search for a text that is a part of a compound word. If you have these texts:\n11vim22\nvim22\n11vim\nvim\nIf you need to select vim but only when it starts with 11 and ends with 22, you can use \\zs (starting match) and \\ze (ending match) operators. Run:\n/11\\zsvim\\ze22\nVim still has to match the entire pattern 11vim22, but only highlights the pattern sandwiched between \\zs and \\ze. Another example:\nfoobar\nfoobaz\nIf you need to match the foo in foobaz but not in foobar, run:\n/foo\\zebaz"
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#searching-character-ranges",
    "href": "chapters/ch12_search_and_substitute.md.html#searching-character-ranges",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.6 Searching Character Ranges",
    "text": "12.6 Searching Character Ranges\nAll your search terms up to this point have been a literal word search. In real life, you may have to use a general pattern to find your text. The most basic pattern is the character range, [ ].\nIf you need to search for any digit, you probably don’t want to type /0\\|1\\|2\\|3\\|4\\|5\\|6\\|7\\|8\\|9\\|0 every single time. Instead, use /[0-9] to match for a single digit. The 0-9 expression represents a range of numbers 0-9 that Vim will try to match, so if you are looking for digits between 1 to 5 instead, use /[1-5].\nDigits are not the only data types Vim can look up. You can also do /[a-z] to search for lowercase alphas and /[A-Z] to search for uppercase alphas.\nYou can combine these ranges together. If you need to search for digits 0-9 and both lowercase and uppercase alphas from a to f (like a hex), you can do /[0-9a-fA-F].\nTo do a negative search, you can add ^ inside the character range brackets. To search for a non-digit, run /[^0-9]. Vim will match any character as long as it is not a digit. Beware that the caret (^) inside the range brackets is different from the beginning-of-a-line caret (ex: /^hello). If a caret is outside of a pair of brackets and is the first character in the search term, it means the first character in a line. If a caret is inside a pair of brackets and it is the first character inside the brackets, it means a negative search operator. /^abc matches the first abc in a line and /[^abc] matches any character except for an a, b, or c."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#searching-for-repeating-characters",
    "href": "chapters/ch12_search_and_substitute.md.html#searching-for-repeating-characters",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.7 Searching for Repeating Characters",
    "text": "12.7 Searching for Repeating Characters\nIf you need to search for double digits in this text:\n1aa\n11a\n111\nYou can use /[0-9][0-9] to match a two-digit character, but this method is unscalable. What if you need to match twenty digits? Typing [0-9] twenty times is not a fun experience. That’s why you need a count argument.\nYou can pass count to your search. It has the following syntax:\n{n,m}\nBy the way, these count braces need to be escaped when you use them in Vim. The count operator is placed after a single character you want to increment.\nHere are the four different variations of the count syntax: - {n} is an exact match. /[0-9]\\{2\\} matches the two digit numbers: 11 and the 11 in 111. - {n,m} is a range match. /[0-9]\\{2,3\\} matches between 2 and 3 digit numbers: 11 and 111. - {,m} is an up-to match. /[0-9]\\{,3\\} matches up to 3 digit numbers: 1, 11, and 111. - {n,} is an at-least match. /[0-9]\\{2,\\} matches at least a 2 or more digit numbers: 11 and 111.\nThe count arguments \\{0,\\} (zero or more) and \\{1,\\} (one or more) are common search patterns and Vim has special operators for them: * and + (+ needs to be escaped while * works fine without the escape). If you do /[0-9]*, it is the same as /[0-9]\\{0,\\}. It searches for zero or more digits. It will match “,1”, 123. By the way, it will also match non-digits like a, because there is technically zero digit in the letter a. Think carefully before using *. If you do /[0-9]\\+, it is the same as /[0-9]\\{1,\\}. It searches for one or more digits. It will match 1 and 12."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#predefined-character-ranges",
    "href": "chapters/ch12_search_and_substitute.md.html#predefined-character-ranges",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.8 Predefined Character Ranges",
    "text": "12.8 Predefined Character Ranges\nVim has predefined ranges for common characters like digits and alphas. I will not go through every single one here, but you can find the full list inside :h /character-classes. Here are the useful ones:\n\\d    Digit [0-9]\n\\D    Non-digit [^0-9]\n\\s    Whitespace character (space and tab)\n\\S    Non-whitespace character (everything except space and tab)\n\\w    Word character [0-9A-Za-z_]\n\\l    Lowercase alphas [a-z]\n\\u    Uppercase character [A-Z]\nYou can use them like you would use character ranges. To search for any single digit, instead of using /[0-9], you can use /\\d for a more concise syntax."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#search-example-capturing-a-text-between-a-pair-of-similar-characters",
    "href": "chapters/ch12_search_and_substitute.md.html#search-example-capturing-a-text-between-a-pair-of-similar-characters",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.9 Search Example: Capturing a Text Between a Pair of Similar Characters",
    "text": "12.9 Search Example: Capturing a Text Between a Pair of Similar Characters\nIf you want to search for a phrase surrounded by a pair of double quotes:\n\"Vim is awesome!\"\nRun this:\n/\"[^\"]\\+\"\nLet’s break it down: - \" is a literal double quote. It matches the first double quote. - [^\"] means any character except for a double quote. It matches any alphanumeric and whitespace character as long as it is not a double quote. - \\+ means one or more. Since it is preceded by [^\"], Vim looks for one or more character that is not a double quote. - \" is a literal double quote. It matches the closing double quote.\nWhen Vim sees the first \", it begins the pattern capture. The moment it sees the second double quote in a line, it matches the second \" pattern and stops the pattern capture. Meanwhile, all non-double-quote characters inbetween are captured by the [^\"]\\+ pattern, in this case, the phrase Vim is awesome!. This is a common pattern to capture a phrase surrounded by a pair of similar delimiters.\n\nTo capture a phrase surrounded by single quotes, you can use /'[^']\\+'.\nTo capture a phrase surrounded by zeroes, you can use /0[^0]\\+0."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#search-example-capturing-a-phone-number",
    "href": "chapters/ch12_search_and_substitute.md.html#search-example-capturing-a-phone-number",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.10 Search Example: Capturing a Phone Number",
    "text": "12.10 Search Example: Capturing a Phone Number\nIf you want to match a US phone number separated by a hyphen (-), like 123-456-7890, you can use:\n/\\d\\{3\\}-\\d\\{3\\}-\\d\\{4\\}\nUS Phone number consists of a set of three digit number, followed by another three digits, and finally by four digits. Let’s break it down: - \\d\\{3\\} matches a digit repeated exactly three times - - is a literal hyphen\nYou can avoid typing escapes with \\v:\n/\\v\\d{3}-\\d{3}-\\d{4}\nThis pattern is also useful to capture any repeating digits, such as IP addresses and zip codes.\nThat covers the search part of this chapter. Now let’s move to substitution."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#basic-substitution",
    "href": "chapters/ch12_search_and_substitute.md.html#basic-substitution",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.11 Basic Substitution",
    "text": "12.11 Basic Substitution\nVim’s substitute command is a useful command to quickly find and replace any pattern. The substitution syntax is:\n:s/{old-pattern}/{new-pattern}/\nLet’s start with a basic usage. If you have this text:\nvim is good\nLet’s substitute good with awesome because Vim is awesome. Run :s/good/awesome/. You should see:\nvim is awesome"
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#repeating-the-last-substitution",
    "href": "chapters/ch12_search_and_substitute.md.html#repeating-the-last-substitution",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.12 Repeating the Last Substitution",
    "text": "12.12 Repeating the Last Substitution\nYou can repeat the last substitute command with either the normal command & or by running :s. If you have just run :s/good/awesome/, running either & or :s will repeat it.\nAlso, earlier in this chapter I mentioned that you can use // to repeat the previous search pattern. This trick works with the substitution command. If /good was done recently and you leave the first substitute pattern argument blank, like in :s//awesome/, it works the same as running :s/good/awesome/."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#substitution-range",
    "href": "chapters/ch12_search_and_substitute.md.html#substitution-range",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.13 Substitution Range",
    "text": "12.13 Substitution Range\nJust like many Ex commands, you can pass a range argument into the substitute command. The syntax is:\n:[range]s/old/new/\nIf you have these expressions:\nlet one = 1;\nlet two = 2;\nlet three = 3;\nlet four = 4;\nlet five = 5;\nTo substitute the let into const on lines three to five, you can do:\n:3,5s/let/const/\nHere are some range variations you can pass:\n\n:,3s/let/const/ - if nothing is given before the comma, it represents the current line. Substitute from current line to line 3.\n:1,s/let/const/ - if nothing is given after the comma, it also represents the current line. Substitute from line 1 to current line.\n:3s/let/const/ - if only one value is given as range (no comma), it does substitution on that line only.\n\nIn Vim, % usually means the entire file. If you run :%s/let/const/, it will do substitution on all lines. Keep in mind of this range syntax. Many command-line commands that you will learn in the upcoming chapters will follow this form."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#pattern-matching",
    "href": "chapters/ch12_search_and_substitute.md.html#pattern-matching",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.14 Pattern Matching",
    "text": "12.14 Pattern Matching\nThe next few sections will cover basic regular expressions. A strong pattern knowledge is essential to master the substitute command.\nIf you have the following expressions:\nlet one = 1;\nlet two = 2;\nlet three = 3;\nlet four = 4;\nlet five = 5;\nTo add a pair of double quotes around the digits:\n:%s/\\d/\"\\0\"/\nThe result:\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\nlet four = \"4\";\nlet five = \"5\";\nLet’s break down the command: - :%s targets the entire file to perform substitution. - \\d is Vim’s predefined range for digits (similar to using [0-9]). - \"\\0\" here the double quotes are literal double quotes. \\0 is a special character representing the whole matched pattern. The matched pattern here is a single digit number, \\d.\nAlternatively, & also represents the whole matched pattern like \\0. :s/\\d/\"&\"/ would have also worked.\nLet’s consider another example. Given these expressions and you need to swap all the let with the variable names.\none let = \"1\";\ntwo let = \"2\";\nthree let = \"3\";\nfour let = \"4\";\nfive let = \"5\";\nTo do that, run:\n:%s/\\(\\w\\+\\) \\(\\w\\+\\)/\\2 \\1/\nThe command above contains too many backslashes and is hard to read. In this case it is more convenient to use the \\v operator:\n:%s/\\v(\\w+) (\\w+)/\\2 \\1/\nThe result:\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\nlet four = \"4\";\nlet five = \"5\";\nGreat! Let’s break down that command: - :%s targets all the lines in the file to perform substitution. - (\\w+) (\\w+) is a group match. \\w is one of Vim’s predefined ranges for a word character ([0-9A-Za-z_]). The ( ) surrounding it captures a word character match in a group. Notice the space between the two groupings. (\\w+) (\\w+) captures two groups. The first group captures one and the second group captures two. - \\2 \\1 returns the captured group in a reversed order. \\2 contains the captured string let and \\1 the string one. Having \\2 \\1 returns the string let one.\nRecall that \\0 represents the entire matched pattern. You can break the matched string into smaller groups with ( ). Each group is represented by \\1, \\2, \\3, etc.\nLet’s do one more example to solidify this group match concept. If you have these numbers:\n123\n456\n789\nTo reverse the order, run:\n:%s/\\v(\\d)(\\d)(\\d)/\\3\\2\\1/\nThe result is:\n321\n654\n987\nEach (\\d) matches each digit and creates a group. On the first line, the first (\\d) has a value of 1, the second (\\d) has a value of 2, and the third (\\d) has a value of 3. They are stored in the variables \\1, \\2, and \\3. In the second half of your substitution, the new pattern \\3\\2\\1 results in the 321 value on line one.\nIf you had run this instead:\n:%s/\\v(\\d\\d)(\\d)/\\2\\1/\nYou would have gotten a different result:\n312\n645\n978\nThis is because you now only have two groups. The first group, captured by (\\d\\d), is stored within \\1 and has the value of 12. The second group, captured by (\\d), is stored inside \\2 and has the value of 3. \\2\\1 then, returns 312."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#substitution-flags",
    "href": "chapters/ch12_search_and_substitute.md.html#substitution-flags",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.15 Substitution Flags",
    "text": "12.15 Substitution Flags\nIf you have the sentence:\nchocolate pancake, strawberry pancake, blueberry pancake\nTo substitute all the pancakes into donuts, you cannot just run:\n:s/pancake/donut\nThe command above will only substitute the first match, giving you:\nchocolate donut, strawberry pancake, blueberry pancake\nThere are two ways to solve this. You can either run the substitute command twice more or you can pass it a global (g) flag to substitute all of the matches in a line.\nLet’s talk about the global flag. Run:\n:s/pancake/donut/g\nVim substitutes all pancakes with donuts in one swift command. The global command is one of the several flags the substitute command accepts. You pass flags at the end of the substitute command. Here is a list of useful flags:\n&    Reuse the flags from the previous substitute command.\ng    Replace all matches in the line.\nc    Ask for substitution confirmation.\ne    Prevent error message from displaying when substitution fails.\ni    Perform case insensitive substitution.\nI    Perform case sensitive substitution.\nThere are more flags that I do not list above. To read about all the flags, check out :h s_flags.\nBy the way, the repeat-substitution commands (& and :s) do not retain the flags. Running & will only repeat :s/pancake/donut/ without g. To quickly repeat the last substitute command with all the flags, run :&&."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#changing-the-delimiter",
    "href": "chapters/ch12_search_and_substitute.md.html#changing-the-delimiter",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.16 Changing the Delimiter",
    "text": "12.16 Changing the Delimiter\nIf you need to replace a URL with a long path:\nhttps://mysite.com/a/b/c/d/e\nTo substitute it with the word hello, run:\n:s/https:\\/\\/mysite.com\\/a\\/b\\/c\\/d\\/e/hello/\nHowever, it is hard to tell which forward slashes (/) are part of the substitution pattern and which ones are the delimiters. You can change the delimiter with any single-byte characters (except for alphabets, numbers, or \", |, and \\). Let’s replace them with +. The substitution command above then can be rewritten as:\n:s+https:\\/\\/mysite.com\\/a\\/b\\/c\\/d\\/e+hello+\nIt is now easier to see where the delimiters are."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#special-replace",
    "href": "chapters/ch12_search_and_substitute.md.html#special-replace",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.17 Special Replace",
    "text": "12.17 Special Replace\nYou can also modify the case of the text you are substituting. Given the following expressions and your task is to uppercase the variables one, two, three, etc.\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\nlet four = \"4\";\nlet five = \"5\";\nRun:\n:%s/\\v(\\w+) (\\w+)/\\1 \\U\\2/\nYou will get:\nlet ONE = \"1\";\nlet TWO = \"2\";\nlet THREE = \"3\";\nlet FOUR = \"4\";\nlet FIVE = \"5\";\nThe breakdown: - (\\w+) (\\w+) captures the first two matched groups, such as let and one. - \\1 returns the value of the first group, let. - \\U\\2 uppercases (\\U) the second group (\\2).\nThe trick of this command is the expression \\U\\2. \\U instructs the following character to be uppercased.\nLet’s do one more example. Suppose you are writing a Vim guide and you need to capitalize the first letter of each word in a line.\nvim is the greatest text editor in the whole galaxy\nYou can run:\n:s/\\<./\\U&/g\nThe result:\nVim Is The Greatest Text Editor In The Whole Galaxy\nHere is the breakdowns: - :s substitutes the current line. - \\<. is comprised of two parts: \\< to match the start of a word and . to match any character. \\< operator makes the following character to be the first character of a word. Since . is the next character, it will match the first character of any word. - \\U& uppercases the subsequent symbol, &. Recall that & (or \\0) represents the whole match. It matches the first character of any word. - g the global flag. Without it, this command only substitutes the first match. You need to substitute every match on this line.\nTo learn more of substitution’s special replace symbols like \\U, check out :h sub-replace-special."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#alternative-patterns",
    "href": "chapters/ch12_search_and_substitute.md.html#alternative-patterns",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.18 Alternative Patterns",
    "text": "12.18 Alternative Patterns\nSometimes you need to match multiple patterns simultaneously. If you have the following greetings:\nhello vim\nhola vim\nsalve vim\nbonjour vim\nYou need to substitute the word vim with friend but only on the lines containing the word hello or hola. Recall from earlier this chapter, you can use | for multiple alternative patterns.\n:%s/\\v(hello|hola) vim/\\1 friend/g\nThe result:\nhello friend\nhola friend\nsalve vim\nbonjour vim\nHere is the breakdown: - %s runs the substitute command on each line in a file. - (hello|hola) matches either hello or hola and consider it as a group. - vim is the literal word vim. - \\1 is the first group, which is either the text hello or hola. - friend is the literal word friend."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#substituting-the-start-and-the-end-of-a-pattern",
    "href": "chapters/ch12_search_and_substitute.md.html#substituting-the-start-and-the-end-of-a-pattern",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.19 Substituting the Start and the End of a Pattern",
    "text": "12.19 Substituting the Start and the End of a Pattern\nRecall that you can use \\zs and \\ze to define the start and the end of a match. This technique works in substitution too. If you have:\nchocolate pancake\nstrawberry sweetcake\nblueberry hotcake\nTo substitute the cake in hotcake with dog to get a hotdog:\n:%s/hot\\zscake/dog/g\nResult:\nchocolate pancake\nstrawberry sweetcake\nblueberry hotdog"
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#greedy-and-non-greedy",
    "href": "chapters/ch12_search_and_substitute.md.html#greedy-and-non-greedy",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.20 Greedy and Non-greedy",
    "text": "12.20 Greedy and Non-greedy\nYou can substitute the nth match in a line with this trick:\nOne Mississippi, two Mississippi, three Mississippi, four Mississippi, five Mississippi.\nTo substitute the third Mississippi with Arkansas, run:\n:s/\\v(.{-}\\zsMississippi){3}/Arkansas/g\nThe breakdown: - :s/ the substitute command. - \\v is the magic keyword so you don’t have to escape special keywords. - . matches any single character. - {-} performs non-greedy match of 0 or more of the preceding atom. - \\zsMississippi makes Mississippi the start of the match. - (...){3} looks for the third match.\nYou have seen the {3} syntax earlier in this chapter. In this case, {3} will match exactly the third match. The new trick here is {-}. It is a non-greedy match. It finds the shortest match of the given pattern. In this case, (.{-}Mississippi) matches the least amount of Mississippi preceded by any character. Contrast this with (.*Mississippi) where it finds the longest match of the given pattern.\nIf you use (.{-}Mississippi), you get five matches: One Mississippi, Two Mississippi, etc. If you use (.*Mississippi), you get one match: the last Mississippi. * is a greedy matcher and {-} is a non-greedy matcher. To learn more check out :h /\\{- and :h non-greedy.\nLet’s do a simpler example. If you have the string:\nabc1de1\nYou can match abc1de1 (greedy) with:\n/a.*1\nYou can match abc1 (non-greedy) with:\n/a.\\{-}1\nSo if you need to uppercase the longest match (greedy), run:\n:s/a.*1/\\U&/g\nTo get:\nABC1DEFG1\nIf you need to uppercase the shortest match (non-greedy), run:\n:s/a.\\{-}1/\\U&/g\nTo get:\nABC1defg1\nIf you’re new to greedy vs non-greedy concept, it can get hard to wrap your head around it. Experiment around with different combinations until you understand it."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#substituting-across-multiple-files",
    "href": "chapters/ch12_search_and_substitute.md.html#substituting-across-multiple-files",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.21 Substituting Across Multiple Files",
    "text": "12.21 Substituting Across Multiple Files\nFinally, let’s learn how to substitute phrases across multiple files. For this section, assume that you have two files: food.txt and animal.txt.\nInside food.txt:\ncorndog\nhotdog\nchilidog\nInside animal.txt:\nlarge dog\nmedium dog\nsmall dog\nAssume your directory structure looks like this:\n- food.txt\n- animal.txt\nFirst, capture both food.txt and animal.txt inside :args. Recall from earlier chapters that :args can be used to create a list of file names. There are several ways to do this from inside Vim, one of them is by running this from inside Vim:\n:args *.txt                  captures all txt files in current location\nTo test it, when you run :args, you should see:\n[food.txt] animal.txt\nNow that all the relevant files are stored inside the argument list, you can perform a multi-file substitution with the :argdo command. Run:\n:argdo %s/dog/chicken/\nThis performs substitution against the all files inside the :args list. Finally, save the changed files with:\n:argdo update\n:args and :argdo are useful tools to apply command line commands across multiple files. Try it with other commands!"
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#substituting-across-multiple-files-with-macros",
    "href": "chapters/ch12_search_and_substitute.md.html#substituting-across-multiple-files-with-macros",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.22 Substituting Across Multiple Files With Macros",
    "text": "12.22 Substituting Across Multiple Files With Macros\nAlternatively, you can also run the substitute command across multiple files with macros. Run:\n:args *.txt\nqq\n:%s/dog/chicken/g\n:wnext\nq\n99@q\nThe breakdown: - :args *.txt adds all text files into the :args list. - qq starts the macro in the q register. - :%s/dog/chicken/g substitutes dog with chicken on all lines in the current file. - :wnext saves the file then go to the next file on the args list. - q stops the macro recording. - 99@q executes the macro ninety-nine times. Vim will stop the macro execution after it encounters the first error, so Vim won’t actually execute the macro ninety-nine times."
  },
  {
    "objectID": "chapters/ch12_search_and_substitute.md.html#learning-search-and-substitution-the-smart-way",
    "href": "chapters/ch12_search_and_substitute.md.html#learning-search-and-substitution-the-smart-way",
    "title": "12  Ch12. Search and Substitute",
    "section": "12.23 Learning Search and Substitution the Smart Way",
    "text": "12.23 Learning Search and Substitution the Smart Way\nThe ability to do search well is a necessary skill in editing. Mastering the search lets you to utilize the flexibility of regular expressions to search for any pattern in a file. Take your time to learn these. To get better with regular expression you need to be actively using regular expressions. I once read a book about regular expression without actually doing it and I forgot almost everything I read afterwards. Active coding is the best way to master any skill.\nA good way to improve your pattern matching skill is whenever you need to search for a pattern (like hello 123), instead of querying for the literal search term (/hello 123), try to come up with a pattern for it (something like /\\v(\\l+) (\\d+)). Many of these regular expression concepts are also applicable in general programming, not only when using Vim.\nNow that you learned about advanced search and substitution in Vim, let’s learn one of the most versatile commands, the global command."
  },
  {
    "objectID": "chapters/ch13_the_global_command.md.html#global-command-overview",
    "href": "chapters/ch13_the_global_command.md.html#global-command-overview",
    "title": "13  Ch13. the Global Command",
    "section": "13.1 Global Command Overview",
    "text": "13.1 Global Command Overview\nVim’s global command is used to run a command-line command on multiple lines simultaneously.\nBy the way, you may have heard of the term Ex Commands before. In this guide, I refer them as command-line commands. Both Ex commands and command-line commands are the same. They are the commands that start with a colon (:). The substitute command in the last chapter was an example of an Ex command. They are called Ex because they originally came from the Ex text editor. I will continue to refer to them as command-line commands in this guide. For a full list of Ex commands, check out :h ex-cmd-index.\nThe global command has the following syntax:\n:g/pattern/command\nThe pattern matches all lines containing that pattern, similar to the pattern in the substitute command. The command can be any command-line command. The global command works by executing command against each line that matches the pattern.\nIf you have the following expressions:\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\nTo remove all lines containing console, you can run:\n:g/console/d\nResult:\nconst one = 1;\n\nconst two = 2;\n\nconst three = 3;\nThe global command executes the delete command (d) on all lines that match the console pattern.\nWhen running the g command, Vim makes two scans across the file. On the first run, it scans each line and marks the line that matches the /console/ pattern. Once all the matching lines are marked, it goes for the second time and executes the d command on the marked lines.\nIf you want to delete all lines containing const instead, run:\n:g/const/d\nResult:\nconsole.log(\"one: \", one);\n\nconsole.log(\"two: \", two);\n\nconsole.log(\"three: \", three);"
  },
  {
    "objectID": "chapters/ch13_the_global_command.md.html#inverse-match",
    "href": "chapters/ch13_the_global_command.md.html#inverse-match",
    "title": "13  Ch13. the Global Command",
    "section": "13.2 Inverse Match",
    "text": "13.2 Inverse Match\nTo run the global command on non-matching lines, you can run:\n:g!/pattern/command\nor\n:v/pattern/command\nIf you run :v/console/d, it will delete all lines not containing console."
  },
  {
    "objectID": "chapters/ch13_the_global_command.md.html#pattern",
    "href": "chapters/ch13_the_global_command.md.html#pattern",
    "title": "13  Ch13. the Global Command",
    "section": "13.3 Pattern",
    "text": "13.3 Pattern\nThe global command uses the same pattern system as the substitute command, so this section will serve as a refresher. Feel free to skip to the next section or read along!\nIf you have these expressions:\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\nTo delete the lines containing either one or two, run:\n:g/one\\|two/d\nTo delete the lines containing any single digits, run either:\n:g/[0-9]/d\nor\n:g/\\d/d\nIf you have the expression:\nconst oneMillion = 1000000;\nconst oneThousand = 1000;\nconst one = 1;\nTo match the lines containing between three to six zeroes, run:\n:g/0\\{3,6\\}/d"
  },
  {
    "objectID": "chapters/ch13_the_global_command.md.html#passing-a-range",
    "href": "chapters/ch13_the_global_command.md.html#passing-a-range",
    "title": "13  Ch13. the Global Command",
    "section": "13.4 Passing a Range",
    "text": "13.4 Passing a Range\nYou can pass a range before the g command. Here are some ways you can do it: - :1,5g/console/d matches the string console between lines 1 and 5 and deletes them. - :,5g/console/d if there is no address before the comma, then it starts from the current line. It looks for the string console between the current line and line 5 and deletes them. - :3,g/console/d if there is no address after the comma, then it ends at the current line. It looks for the string console between line 3 and the current line and deletes them. - :3g/console/d if you only pass one address without a comma, it executes the command only on line 3. It looks on line 3 and deletes it if has the string console.\nIn addition to numbers, you can also use these symbols as range: - . means the current line. A range of .,3 means between the current line and line 3. - $ means the last line in the file. 3,$ range means between line 3 and the last line. - +n means n lines after the current line. You can use it with . or without. 3,+1 or 3,.+1 means between line 3 and the line after the current line.\nIf you don’t give it any range, by default it affects the entire file. This is actually not the norm. Most of Vim’s command-line commands run on only the current line if you don’t pass it any range. The two notable exceptions are the global (:g) and the save (:w) commands."
  },
  {
    "objectID": "chapters/ch13_the_global_command.md.html#normal-command",
    "href": "chapters/ch13_the_global_command.md.html#normal-command",
    "title": "13  Ch13. the Global Command",
    "section": "13.5 Normal Command",
    "text": "13.5 Normal Command\nYou can run a normal command with the global command with :normal command-line command.\nIf you have this text:\nconst one = 1\nconsole.log(\"one: \", one)\n\nconst two = 2\nconsole.log(\"two: \", two)\n\nconst three = 3\nconsole.log(\"three: \", three)\nTo add a ; to the end of each line, run:\n:g/./normal A;\nLet’s break it down: - :g is the global command. - /./ is a pattern for non-empty lines. It matches the lines with at least one character, so it matches the lines with const and console and it does not match empty lines. - normal A; runs the :normal command-line command. A; is the normal mode command to insert a ; at the end of the line."
  },
  {
    "objectID": "chapters/ch13_the_global_command.md.html#executing-a-macro",
    "href": "chapters/ch13_the_global_command.md.html#executing-a-macro",
    "title": "13  Ch13. the Global Command",
    "section": "13.6 Executing a Macro",
    "text": "13.6 Executing a Macro\nYou can also execute a macro with the global command. A macro can be executed with the normal command. If you have the expressions:\nconst one = 1\nconsole.log(\"one: \", one);\n\nconst two = 2\nconsole.log(\"two: \", two);\n\nconst three = 3\nconsole.log(\"three: \", three);\nNotice that the lines with const do not have semi-colons. Let’s create a macro to add a comma to the end of those lines in the register a:\nqaA;<Esc>q\nIf you need a refresher, check out the chapter on macro. Now run:\n:g/const/normal @a\nNow all lines with const will have a ; at the end.\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\nIf you followed this step-by-step, you will have two semi-colons on the first line. To avoid that, run the global command on line two onward, :2,$g/const/normal @a."
  },
  {
    "objectID": "chapters/ch13_the_global_command.md.html#recursive-global-command",
    "href": "chapters/ch13_the_global_command.md.html#recursive-global-command",
    "title": "13  Ch13. the Global Command",
    "section": "13.7 Recursive Global Command",
    "text": "13.7 Recursive Global Command\nThe global command itself is a type of a command-line command, so you can technically run the global command inside a global command.\nGiven the following expressions, if you want to delete the second console.log statement:\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\nIf you run:\n:g/console/g/two/d\nFirst, g will look for the lines containing the pattern console and will find 3 matches. Then the second g will look for the line containing the pattern two from those three matches. Finally, it will delete that match.\nYou can also combine g with v to find positive and negative patterns. For example:\n:g/console/v/two/d\nInstead of looking for the line containing the pattern two, it will look for the lines not containing the pattern two."
  },
  {
    "objectID": "chapters/ch13_the_global_command.md.html#changing-the-delimiter",
    "href": "chapters/ch13_the_global_command.md.html#changing-the-delimiter",
    "title": "13  Ch13. the Global Command",
    "section": "13.8 Changing the Delimiter",
    "text": "13.8 Changing the Delimiter\nYou can change the global command’s delimiter like the substitute command. The rules are the same: you can use any single byte character except for alphabets, numbers, \", |, and \\.\nTo delete the lines containing console:\n:g@console@d\nIf you are using the substitute command with the global command, you can have two different delimiters:\ng@one@s+const+let+g\nHere the global command will look for all lines containing one. The substitute command will substitute, from those matches, the string const with let."
  },
  {
    "objectID": "chapters/ch13_the_global_command.md.html#the-default-command",
    "href": "chapters/ch13_the_global_command.md.html#the-default-command",
    "title": "13  Ch13. the Global Command",
    "section": "13.9 The Default Command",
    "text": "13.9 The Default Command\nWhat happens if you don’t specify any command-line command in the global command?\nThe global command will use the print (:p) command to print the current line’s text. If you run:\n:g/console\nIt will print at the bottom of the screen all the lines containing console.\nBy the way, here is one interesting fact. Because the default command used by the global command is p, this makes the g syntax to be:\n:g/re/p\n\ng = the global command\nre = the regex pattern\np = the print command\n\nIt spells grep, the same grep from the command line. This is not a coincidence. The g/re/p command originally came from the Ed Editor, one of the original line text editors. The grep command got its name from Ed.\nYour computer probably still has the Ed editor. Run ed from the terminal (hint: to quit, type q)."
  },
  {
    "objectID": "chapters/ch13_the_global_command.md.html#reversing-the-entire-buffer",
    "href": "chapters/ch13_the_global_command.md.html#reversing-the-entire-buffer",
    "title": "13  Ch13. the Global Command",
    "section": "13.10 Reversing the Entire Buffer",
    "text": "13.10 Reversing the Entire Buffer\nTo reverse the entire file, run:\n:g/^/m 0\n^ is a pattern for the beginning of a line. Use ^ to match all lines, including empty lines.\nIf you need to reverse only a few lines, pass it a range. To reverse the lines between line five to line ten, run:\n:5,10g/^/m 0\nTo learn more about the move command, check out :h :move."
  },
  {
    "objectID": "chapters/ch13_the_global_command.md.html#aggregating-all-todos",
    "href": "chapters/ch13_the_global_command.md.html#aggregating-all-todos",
    "title": "13  Ch13. the Global Command",
    "section": "13.11 Aggregating All Todos",
    "text": "13.11 Aggregating All Todos\nWhen coding, sometimes I would write TODOs in the file I’m editing:\nconst one = 1;\nconsole.log(\"one: \", one);\n// TODO: feed the puppy\n\nconst two = 2;\n// TODO: feed the puppy automatically\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n// TODO: create a startup selling an automatic puppy feeder\nIt can be hard to keep track of all the created TODOs. Vim has a :t (copy) method to copy all matches to an address. To learn more about the copy method, check out :h :copy.\nTo copy all TODOs to the end of the file for easier introspection, run:\n:g/TODO/t $\nResult:\nconst one = 1;\nconsole.log(\"one: \", one);\n// TODO: feed the puppy\n\nconst two = 2;\n// TODO: feed the puppy automatically\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n// TODO: create a startup selling an automatic puppy feeder\n\n// TODO: feed the puppy\n// TODO: feed the puppy automatically\n// TODO: create a startup selling an automatic puppy feeder\nNow I can review all the TODOs I created, find a time to do them or delegate them to someone else, and continue to work on my next task.\nIf instead of copying them you want to move all the TODOs to the end, use the move command, :m:\n:g/TODO/m $\nResult:\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n\n// TODO: feed the puppy\n// TODO: feed the puppy automatically\n// TODO: create a startup selling an automatic puppy feeder"
  },
  {
    "objectID": "chapters/ch13_the_global_command.md.html#black-hole-delete",
    "href": "chapters/ch13_the_global_command.md.html#black-hole-delete",
    "title": "13  Ch13. the Global Command",
    "section": "13.12 Black Hole Delete",
    "text": "13.12 Black Hole Delete\nRecall from the register chapter that deleted texts are stored inside the numbered registers (granted they are sufficiently large ). Whenever you run :g/console/d, Vim stores the deleted lines in the numbered registers. If you delete many lines, you can quickly fill up all the numbered registers. To avoid this, you can always use the black hole register (\"_) to not store your deleted lines into the registers. Run:\n:g/console/d_\nBy passing _ after d, Vim won’t use up your scratch registers."
  },
  {
    "objectID": "chapters/ch13_the_global_command.md.html#reduce-multiple-empty-lines-to-one-empty-line",
    "href": "chapters/ch13_the_global_command.md.html#reduce-multiple-empty-lines-to-one-empty-line",
    "title": "13  Ch13. the Global Command",
    "section": "13.13 Reduce Multiple Empty Lines to One Empty Line",
    "text": "13.13 Reduce Multiple Empty Lines to One Empty Line\nIf you have a text with multiple empty lines:\nconst one = 1;\nconsole.log(\"one: \", one);\n\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\n\n\n\n\nconst three = 3;\nconsole.log(\"three: \", three);\nYou can quickly reduce the empty lines into one empty line with:\n:g/^$/,/./-1j\nResult:\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\nNormally the global command accepts the following form: :g/pattern/command. However, you can also run the global command with the following form: :g/pattern1/,/pattern2/command. With this, Vim will apply the command within pattern1 and pattern2.\nWith that in mind, let’s break down the command :g/^$/,/./-1j according to :g/pattern1/,/pattern2/command: - /pattern1/ is /^$/. It represents an empty line (a line with zero character). - /pattern2/ is /./ with -1 line modifier. /./ represents a non-empty line (a line with at least one character). The -1 means the line above that. - command is j, the join command (:j). In this context, this global command joins all the given lines.\nBy the way, if you want to reduce multiple empty lines to no lines, run this instead:\n:g/^$/,/./j\nA simpler alternative:\n:g/^$/-j\nYour text is now reduced to:\nconst one = 1;\nconsole.log(\"one: \", one);\nconst two = 2;\nconsole.log(\"two: \", two);\nconst three = 3;\nconsole.log(\"three: \", three);"
  },
  {
    "objectID": "chapters/ch13_the_global_command.md.html#advanced-sort",
    "href": "chapters/ch13_the_global_command.md.html#advanced-sort",
    "title": "13  Ch13. the Global Command",
    "section": "13.14 Advanced Sort",
    "text": "13.14 Advanced Sort\nVim has a :sort command to sort the lines within a range. For example:\nd\nb\na\ne\nc\nYou can sort them by running :sort. If you give it a range, it will sort only the lines within that range. For example, :3,5sort only sorts lines three and five.\nIf you have the following expressions:\nconst arrayB = [\n  \"i\",\n  \"g\",\n  \"h\",\n  \"b\",\n  \"f\",\n  \"d\",\n  \"e\",\n  \"c\",\n  \"a\",\n]\n\nconst arrayA = [\n  \"h\",\n  \"b\",\n  \"f\",\n  \"d\",\n  \"e\",\n  \"a\",\n  \"c\",\n]\nIf you need to sort the elements inside the arrays, but not the arrays themselves, you can run this:\n:g/\\[/+1,/\\]/-1sort\nResult:\nconst arrayB = [\n  \"a\",\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"g\",\n  \"h\",\n  \"i\",\n]\n\nconst arrayA = [\n  \"a\"\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"h\",\n]\nThis is great! But the command looks complicated. Let’s break it down. This command also follows the form :g/pattern1/,/pattern2/command.\n\n:g is the global command pattern.\n/\\[/+1 is the first pattern. It matches a literal left square bracket [. The +1 refers to the line below it.\n/\\]/-1 is the second pattern. It matches a literal right square bracket ]. The -1 refers to the line above it.\n/\\[/+1,/\\]/-1 then refers to any lines between [” and ”].\nsort is a command-line command to sort."
  },
  {
    "objectID": "chapters/ch13_the_global_command.md.html#learn-the-global-command-the-smart-way",
    "href": "chapters/ch13_the_global_command.md.html#learn-the-global-command-the-smart-way",
    "title": "13  Ch13. the Global Command",
    "section": "13.15 Learn the Global Command the Smart Way",
    "text": "13.15 Learn the Global Command the Smart Way\nThe global command executes the command-line command against all matching lines. With it, you only need to run a command once and Vim will do the rest for you. To become proficient at the global command, two things are required: a good vocabulary of command-line commands and a knowledge of regular expressions. As you spend more time using Vim, you will naturally learn more command-line commands. A regular expression knowledge will require a more active approach. But once you become comfortable with regular expressions, you will be ahead of many.\nSome of the examples here are complicated. Do not be intimidated. Really take your time to understand them. Learn to read the patterns. Do not give up.\nWhenever you need to run multiple commands, pause and see if you can use the g command. Identify the best command for the job and write a pattern to target as many things at once.\nNow that you know how powerful the global command is, let’s learn how to use the external commands to increase your tool arsenals."
  },
  {
    "objectID": "chapters/ch14_external_commands.md.html#the-bang-command",
    "href": "chapters/ch14_external_commands.md.html#the-bang-command",
    "title": "14  Ch14. External Commands",
    "section": "14.1 The Bang Command",
    "text": "14.1 The Bang Command\nVim has a bang (!) command that can do three things:\n\nRead the STDOUT of an external command into the current buffer.\nWrite the content of your buffer as the STDIN to an external command.\nExecute an external command from inside Vim.\n\nLet’s go through each of them."
  },
  {
    "objectID": "chapters/ch14_external_commands.md.html#reading-the-stdout-of-a-command-into-vim",
    "href": "chapters/ch14_external_commands.md.html#reading-the-stdout-of-a-command-into-vim",
    "title": "14  Ch14. External Commands",
    "section": "14.2 Reading the STDOUT of a Command Into Vim",
    "text": "14.2 Reading the STDOUT of a Command Into Vim\nThe syntax to read the STDOUT of an external command into the current buffer is:\n:r !cmd\n:r is Vim’s read command. If you use it without !, you can use it to get the content of a file. If you have a file file1.txt in the current directory and you run:\n:r file1.txt\nVim will put the content of file1.txt into the current buffer.\nIf you run the :r command followed by a ! and an external command, the output of that command will be inserted into the current buffer. To get the result of the ls command, run:\n:r !ls\nIt returns something like:\nfile1.txt\nfile2.txt\nfile3.txt\nYou can read the data from the curl command:\n:r !curl -s 'https://jsonplaceholder.typicode.com/todos/1'\nThe r command also accepts an address:\n:10r !cat file1.txt\nNow the STDOUT from running cat file1.txt will be inserted after line 10."
  },
  {
    "objectID": "chapters/ch14_external_commands.md.html#writing-the-buffer-content-into-an-external-command",
    "href": "chapters/ch14_external_commands.md.html#writing-the-buffer-content-into-an-external-command",
    "title": "14  Ch14. External Commands",
    "section": "14.3 Writing the Buffer Content Into an External Command",
    "text": "14.3 Writing the Buffer Content Into an External Command\nThe command :w, in addition to saving a file, can be used to pass the text in the current buffer as the STDIN for an external command. The syntax is:\n:w !cmd\nIf you have these expressions:\nconsole.log(\"Hello Vim\");\nconsole.log(\"Vim is awesome\");\nMake sure you have node installed in your machine, then run:\n:w !node\nVim will use node to execute the JavaScript expressions to print Hello Vim and Vim is awesome.\nWhen using the :w command, Vim uses all texts in the current buffer, similar to the global command (most command-line commands, if you don’t pass it a range, only executes the command against the current line). If you pass :w a specific address:\n:2w !node\nVim only uses the text from the second line into the node interpreter.\nThere is a subtle but significant difference between :w !node and :w! node. With :w !node, you are writing the text in the current buffer into the external command node. With :w! node, you are force-saving a file and naming the file node."
  },
  {
    "objectID": "chapters/ch14_external_commands.md.html#executing-an-external-command",
    "href": "chapters/ch14_external_commands.md.html#executing-an-external-command",
    "title": "14  Ch14. External Commands",
    "section": "14.4 Executing an External Command",
    "text": "14.4 Executing an External Command\nYou can execute an external command from inside Vim with the bang command. The syntax is:\n:!cmd\nTo see the content of the current directory in the long format, run:\n:!ls -ls\nTo kill a process that is running on PID 3456, you can run:\n:!kill -9 3456\nYou can run any external command without leaving Vim so you can stay focused on your task."
  },
  {
    "objectID": "chapters/ch14_external_commands.md.html#filtering-texts",
    "href": "chapters/ch14_external_commands.md.html#filtering-texts",
    "title": "14  Ch14. External Commands",
    "section": "14.5 Filtering Texts",
    "text": "14.5 Filtering Texts\nIf you give ! a range, it can be used to filter texts. Suppose you have the following texts:\nhello vim\nhello vim\nLet’s uppercase the current line using the tr (translate) command. Run:\n:.!tr '[:lower:]' '[:upper:]'\nThe result:\nHELLO VIM\nhello vim\nThe breakdown: - .! executes the filter command on the current line. - tr '[:lower:]' '[:upper:]' calls the tr command to replace all lowercase characters with uppercase ones.\nIt is imperative to pass a range to run the external command as a filter. If you try running the command above without the . (:!tr '[:lower:]' '[:upper:]'), you will see an error.\nLet’s assume that you need to remove the second column on both lines with the awk command:\n:%!awk \"{print $1}\"\nThe result:\nhello\nhello\nThe breakdown: - :%! executes the filter command on all lines (%). - awk \"{print $1}\" prints only the first column of the match.\nYou can chain multiple commands with the chain operator (|) just like in the terminal. Let’s say you have a file with these delicious breakfast items:\nname price\nchocolate pancake 10\nbuttermilk pancake 9\nblueberry pancake 12\nIf you need to sort them based on the price and display only the menu with an even spacing, you can run:\n:%!awk 'NR > 1' | sort -nk 3 | column -t\nThe result:\nbuttermilk pancake 9\nchocolate pancake 10\nblueberry pancake 12\nThe breakdown: - :%! applies the filter to all lines (%). - awk 'NR > 1' displays the texts only from row number two onwards. - | chains the next command. - sort -nk 3 sorts numerically (n) using the values from column 3 (k 3). - column -t organizes the text with even spacing."
  },
  {
    "objectID": "chapters/ch14_external_commands.md.html#normal-mode-command",
    "href": "chapters/ch14_external_commands.md.html#normal-mode-command",
    "title": "14  Ch14. External Commands",
    "section": "14.6 Normal Mode Command",
    "text": "14.6 Normal Mode Command\nVim has a filter operator (!) in the normal mode. If you have the following greetings:\nhello vim\nhola vim\nbonjour vim\nsalve vim\nTo uppercase the current line and the line below, you can run:\n!jtr '[a-z]' '[A-Z]'\nThe breakdown: - !j runs the normal command filter operator (!) targetting the current line and the line below it. Recall that because it is a normal mode operator, the grammar rule verb + noun applies. ! is the verb and j is the noun. - tr '[a-z]' '[A-Z]' replaces the lowercase letters with the uppercase letters.\nThe filter normal command only works on motions / text objects that are at least one line or longer. If you had tried running !iwtr '[a-z]' '[A-Z]' (execute tr on inner word), you will find that it applies the tr command on the entire line, not the word your cursor is on."
  },
  {
    "objectID": "chapters/ch14_external_commands.md.html#learn-external-commands-the-smart-way",
    "href": "chapters/ch14_external_commands.md.html#learn-external-commands-the-smart-way",
    "title": "14  Ch14. External Commands",
    "section": "14.7 Learn External Commands the Smart Way",
    "text": "14.7 Learn External Commands the Smart Way\nVim is not an IDE. It is a lightweight modal editor that is highly extensible by design. Because of this extensibility, you have an easy access to any external command in your system. Armed with these external commands, Vim is one step closer from becoming an IDE. Someone said that the Unix system is the first IDE ever.\nThe bang command is as useful as how many external commands you know. Don’t worry if your external command knowledge is limited. I still have a lot to learn too. Take this as a motivation for continuous learning. Whenever you need to modify a text, look if there is an external command that can solve your problem. Don’t worry about mastering everything, just learn the ones you need to complete the current task."
  },
  {
    "objectID": "chapters/ch15_command-line_mode.md.html#entering-and-exiting-the-command-line-mode",
    "href": "chapters/ch15_command-line_mode.md.html#entering-and-exiting-the-command-line-mode",
    "title": "15  Ch15. Command-line Mode",
    "section": "15.1 Entering and Exiting the Command-line Mode",
    "text": "15.1 Entering and Exiting the Command-line Mode\nThe command-line mode is a mode in itself, just like normal mode, insert mode, and visual mode. When you are in this mode, the cursor goes to the bottom of the screen where you can type in different commands.\nThere are 4 different commands you can use to enter the command-line mode: - Search patterns (/, ?) - Command-line commands (:) - External commands (!)\nYou can enter the command-line mode from the normal mode or the visual mode.\nTo leave the command-line mode, you can use <Esc>, Ctrl-C, or Ctrl-[.\nOther literatures might refer the Command-line command as Ex command and the External command as filter command or bang operator."
  },
  {
    "objectID": "chapters/ch15_command-line_mode.md.html#repeating-the-previous-command",
    "href": "chapters/ch15_command-line_mode.md.html#repeating-the-previous-command",
    "title": "15  Ch15. Command-line Mode",
    "section": "15.2 Repeating the Previous Command",
    "text": "15.2 Repeating the Previous Command\nYou can repeat the previous command-line command or external command with @:.\nIf you just ran :s/foo/bar/g, running @: repeats that substitution. If you just ran :.!tr '[a-z]' '[A-Z]', running @: repeats the last external command translation filter."
  },
  {
    "objectID": "chapters/ch15_command-line_mode.md.html#command-line-mode-shortcuts",
    "href": "chapters/ch15_command-line_mode.md.html#command-line-mode-shortcuts",
    "title": "15  Ch15. Command-line Mode",
    "section": "15.3 Command-line Mode Shortcuts",
    "text": "15.3 Command-line Mode Shortcuts\nWhile in the command-line mode, you can move to the left or to the right, one character at a time, with the Left or Right arrow.\nIf you need to move word-wise, use Shift-Left or Shift-Right (in some OS, you might have to use Ctrl instead of Shift).\nTo go to the start of the line, use Ctrl-B. To go to the end of the line, use Ctrl-E.\nSimilar to the insert mode, inside the command-line mode, you have three ways to delete characters:\nCtrl-H    Delete one character\nCtrl-W    Delete one word\nCtrl-U    Delete the entire line\nFinally, if you want to edit the command like you would a normal textfile use Ctrl-F.\nThis also allows you to search through the previous commands, edit them and rerun them by pressing <Enter> in command-line editing normal mode."
  },
  {
    "objectID": "chapters/ch15_command-line_mode.md.html#register-and-autocomplete",
    "href": "chapters/ch15_command-line_mode.md.html#register-and-autocomplete",
    "title": "15  Ch15. Command-line Mode",
    "section": "15.4 Register and Autocomplete",
    "text": "15.4 Register and Autocomplete\nWhile in the command-line mode, you can insert texts from Vim register with Ctrl-R the same way as the insert mode. If you have the string foo saved in the register a, you can insert it by running Ctrl-R a. Everything that you can get from the register in the insert mode, you can do the same from the command-line mode.\nIn addition, you can also get the word under the cursor with Ctrl-R Ctrl-W (Ctrl-R Ctrl-A for the WORD under cursor). To get the line under the cursor, use Ctrl-R Ctrl-L. To get the filename under the cursor, use Ctrl-R Ctrl-F.\nYou can also autocomplete existing commands. To autocomplete the echo command, while in the command-line mode, type ec, then press <Tab>. You should see on the bottom left Vim commands starting with ec (example: echo echoerr echohl echomsg econ). To go to the next option, press either <Tab> or Ctrl-N. To go the previous option, press either <Shift-Tab> or Ctrl-P.\nSome command-line commands accept file names as arguments. One example is edit. You can autocomplete here too. After typing the command, :e (don’t forget the space), press <Tab>. Vim will list all the relevant file names that you can choose from so you don’t have to type it from scratch."
  },
  {
    "objectID": "chapters/ch15_command-line_mode.md.html#history-window-and-command-line-window",
    "href": "chapters/ch15_command-line_mode.md.html#history-window-and-command-line-window",
    "title": "15  Ch15. Command-line Mode",
    "section": "15.5 History Window and Command-line Window",
    "text": "15.5 History Window and Command-line Window\nYou can view the history of command-line commands and search terms (this requires the +cmdline_hist feature).\nTo open the command-line history, run :his :. You should see something like the following:\n## Cmd history\n2  e file1.txt\n3  g/foo/d\n4  s/foo/bar/g\nVim lists the history of all the : commands you run. By default, Vim stores the last 50 commands. To change the amount of the entries that Vim remembers to 100, you run set history=100.\nA more useful use of the command-line history is through the command-line window,q:. This will open a searchable, editable history window. Suppose you have these expressions in the history when you press q::\n51  s/verylongsubstitutionpattern/pancake/g\n52  his :\n53  wq\nIf your current task is to do s/verylongsubstitutionpattern/donut/g, instead of typing the command from scratch, why don’t you reuse s/verylongsubstitutionpattern/pancake/g? After all, the only thing that’s different is the word substitute, donut vs pancake. Everything else is the same.\nAfter you ran q:, find that s/verylongsubstitutionpattern/pancake/g in the history (you can use the Vim navigation in this environment) and edit it directly! Change pancake to donut inside the history window, then press <Enter>. Boom! Vim executes s/verylongsubstitutionpattern/donut/g for you. Super convenient!\nSimilarly, to view the search history, run :his / or :his ?. To open the search history window where you can search and edit past history, run q/ or q?.\nTo quit this window, press Ctrl-C, Ctrl-W C, or type :quit."
  },
  {
    "objectID": "chapters/ch15_command-line_mode.md.html#more-command-line-commands",
    "href": "chapters/ch15_command-line_mode.md.html#more-command-line-commands",
    "title": "15  Ch15. Command-line Mode",
    "section": "15.6 More Command-line Commands",
    "text": "15.6 More Command-line Commands\nVim has hundreds of built-in commands. To see all the commands Vim have, check out :h ex-cmd-index or :h :index."
  },
  {
    "objectID": "chapters/ch15_command-line_mode.md.html#learn-command-line-mode-the-smart-way",
    "href": "chapters/ch15_command-line_mode.md.html#learn-command-line-mode-the-smart-way",
    "title": "15  Ch15. Command-line Mode",
    "section": "15.7 Learn Command-line Mode the Smart Way",
    "text": "15.7 Learn Command-line Mode the Smart Way\nCompared to the other three modes, the command-line mode is like the Swiss Army knife of text editing. You can edit text, modify files, and execute commands, just to name a few. This chapter is a collection of odds and ends of the command-line mode. It also brings Vim modes into closure. Now that you know how to use the normal, insert, visual, and command-line mode you can edit text with Vim faster than ever.\nIt’s time to move away from Vim modes and learn how to do an even faster navigation with Vim tags."
  },
  {
    "objectID": "chapters/ch16_tags.md.html#tag-overview",
    "href": "chapters/ch16_tags.md.html#tag-overview",
    "title": "16  Ch16. Tags",
    "section": "16.1 Tag Overview",
    "text": "16.1 Tag Overview\nSuppose someone handed you a new codebase:\none = One.new\none.donut\nOne? donut? Well, these might have been obvious to the developers writing the code way back then, but now those developers are no longer here and it is up to you to understand these obscure codes. One way to help understand this is to follow the source code where One and donut are defined.\nYou can search for them with either fzf or grep (or vimgrep), but in this case, tags are faster.\nThink of tags like an address book:\nName    Address\nIggy1   1234 Cool St, 11111\nIggy2   9876 Awesome Ave, 2222\nInstead of having a name-address pair, tags store definitions paired with addresses.\nLet’s assume that you have these two Ruby files inside the same directory:\n## one.rb\nclass One\n  def initialize\n    puts \"Initialized\"\n  end\n\n  def donut\n    puts \"Bar\"\n  end\nend\nand\n## two.rb\nrequire './one'\n\none = One.new\none.donut\nTo jump to a definition, you can use Ctrl-] in the normal mode. Inside two.rb, go to the line where one.donut is and move the cursor over donut. Press Ctrl-].\nWhoops, Vim could not find the tag file. You need to generate the tag file first."
  },
  {
    "objectID": "chapters/ch16_tags.md.html#tag-generator",
    "href": "chapters/ch16_tags.md.html#tag-generator",
    "title": "16  Ch16. Tags",
    "section": "16.2 Tag Generator",
    "text": "16.2 Tag Generator\nModern Vim does not come with tag generator, so you will have to download an external tag generator. There are several options to choose:\n\nctags = C only. Available almost everywhere.\nexuberant ctags = One of the most popular ones. Has many language support.\nuniversal ctags = Similar to exuberant ctags, but newer.\netags = For Emacs. Hmm…\nJTags = Java\nptags.py = Python\nptags = Perl\ngnatxref = Ada\n\nIf you look at Vim tutorials online, many will recommend exuberant ctags. It supports 41 programming languages. I used it and it worked great. However, because it has not been maintained since 2009, Universal ctags would be a better choice. It works similar to exuberant ctags and is currently being maintained.\nI won’t go into details on how to install the universal ctags. Check out the universal ctags repository for more instructions.\nAssuming you have the universal ctags installed, let’s generate a basic tag file. Run:\nctags -R .\nThe R option tells ctags to run a recursive scan from your current location (.). You should see a tags file in your current directory. Inside you will see something like this:\n!_TAG_FILE_FORMAT   2   /extended format; --format=1 will not append ;\" to lines/\n!_TAG_FILE_SORTED   1   /0=unsorted, 1=sorted, 2=foldcase/\n!_TAG_OUTPUT_FILESEP    slash   /slash or backslash/\n!_TAG_OUTPUT_MODE   u-ctags /u-ctags or e-ctags/\n!_TAG_PATTERN_LENGTH_LIMIT  96  /0 for no limit/\n!_TAG_PROGRAM_AUTHOR    Universal Ctags Team    //\n!_TAG_PROGRAM_NAME  Universal Ctags /Derived from Exuberant Ctags/\n!_TAG_PROGRAM_URL   <https://ctags.io/> /official site/\n!_TAG_PROGRAM_VERSION   0.0.0   /b43eb39/\nOne one.rb  /^class One$/;\" c\ndonut   one.rb  /^  def donut$/;\"   f   class:One\ninitialize  one.rb  /^  def initialize$/;\"  f   class:One\nYours might look a little different depending on your Vim setting and the ctags generator. A tag file is composed of two parts: the tag metadata and the tag list. These metadata (!TAG_FILE...) are usually controlled by the ctags generator. I won’t discuss it here, but feel free to check their docs for more! The tag list is a list of all the definitions indexed by ctags.\nNow go to two.rb, put the cursor on donut, and type Ctrl-]. Vim will take you to the file one.rb on the line where def donut is. Success! But how did Vim do this?"
  },
  {
    "objectID": "chapters/ch16_tags.md.html#tags-anatomy",
    "href": "chapters/ch16_tags.md.html#tags-anatomy",
    "title": "16  Ch16. Tags",
    "section": "16.3 Tags Anatomy",
    "text": "16.3 Tags Anatomy\nLet’s look at the donut tag item:\ndonut   one.rb  /^  def donut$/;\"   f   class:One\nThe above tag item is composed of four components: a tagname, a tagfile, a tagaddress, and tag options. - donut is the tagname. When your cursor is on donut, Vim searches the tag file for a line that has the donut string. - one.rb is the tagfile. Vim looks for a file one.rb. - /^ def donut$/ is the tagaddress. /.../ is a pattern indicator. ^ is a pattern for the first element on a line. It is followed by two spaces, then the string def donut. Finally, $ is a pattern for the last element on a line. - f class:One is the tag option that tells Vim that the function donut is a function (f) and is part of the One class.\nLet’s look at another item in the tag list:\nOne one.rb  /^class One$/;\" c\nThis line works the same way as the donut pattern:\n\nOne is the tagname. Note that with tags, the first scan is case sensitive. If you have One and one on the list, Vim will prioritize One over one.\none.rb is the tagfile. Vim looks for a file one.rb.\n/^class One$/ is the tagaddress pattern. Vim looks for a line that starts with (^) class and ends with ($) One.\nc is one of the possible tag options. Since One is a ruby class and not a procedure, it marks it with a c.\n\nDepending on which tag generator you use, the content of your tag file may look different. At minimum, a tag file must have either one of these formats:\n1.  {tagname} {TAB} {tagfile} {TAB} {tagaddress}\n2.  {tagname} {TAB} {tagfile} {TAB} {tagaddress} {term} {field} .."
  },
  {
    "objectID": "chapters/ch16_tags.md.html#the-tag-file",
    "href": "chapters/ch16_tags.md.html#the-tag-file",
    "title": "16  Ch16. Tags",
    "section": "16.4 The Tag File",
    "text": "16.4 The Tag File\nYou have learned that a new file, tags, is created after running ctags -R .. How does Vim know where to look for the tag file?\nIf you run :set tags?, you might see tags=./tags,tags (depending on your Vim settings, it might be different). Here Vim looks for all tags in the path of the current file in the case of ./tags and the current directory (your project root) in the case of tags.\nAlso in the case of ./tags, Vim will first look for a tag file inside the path of your current file regardless how nested it is, then it will look for a tag file of the current directory (project root). Vim stops after it finds the first match.\nIf your 'tags' file had said tags=./tags,tags,/user/iggy/mytags/tags, then Vim will also look at the /user/iggy/mytags directory for a tag file after Vim finishes searching ./tags and tags directory. You don’t have to store your tag file inside your project, you can keep them separate.\nTo add a new tag file location, use the following:\nset tags+=path/to/my/tags/file"
  },
  {
    "objectID": "chapters/ch16_tags.md.html#generating-tags-for-a-large-project",
    "href": "chapters/ch16_tags.md.html#generating-tags-for-a-large-project",
    "title": "16  Ch16. Tags",
    "section": "16.5 Generating Tags for a Large Project",
    "text": "16.5 Generating Tags for a Large Project\nIf you tried to run ctags in a large project, it may take a long time because Vim also looks inside every nested directories. If you are a Javascript developer, you know that node_modules can be very large. Imagine if you have a five sub-projects and each contains its own node_modules directory. If you run ctags -R ., ctags will try to scan through all 5 node_modules. You probably don’t need to run ctags on node_modules.\nTo run ctags excluding the node_modules, run:\nctags -R --exclude=node_modules .\nThis time it should take less than a second. By the way, you can use the exclude option multiple times:\nctags -R --exclude=.git --exclude=vendor --exclude=node_modules --exclude=db --exclude=log .\nThe point is, if you want to omit a directory, --exclude is your best friend."
  },
  {
    "objectID": "chapters/ch16_tags.md.html#tags-navigation",
    "href": "chapters/ch16_tags.md.html#tags-navigation",
    "title": "16  Ch16. Tags",
    "section": "16.6 Tags Navigation",
    "text": "16.6 Tags Navigation\nYou can get good mileage using only Ctrl-], but let’s learn a few more tricks. The tag jump key Ctrl-] has an command-line mode alternative: :tag {tag-name}. If you run:\n:tag donut\nVim will jump to the donut method, just like doing Ctrl-] on donut string. You can autocomplete the argument too, with <Tab>:\n:tag d<Tab>\nVim lists all tags that starts with d. In this case, donut.\nIn a real project, you may encounter multiple methods with the same name. Let’s update the two ruby files from earlier. Inside one.rb:\n## one.rb\nclass One\n  def initialize\n    puts \"Initialized\"\n  end\n\n  def donut\n    puts \"one donut\"\n  end\n\n  def pancake\n    puts \"one pancake\"\n  end\nend\nInside two.rb:\n## two.rb\nrequire './one.rb'\n\ndef pancake\n  \"Two pancakes\"\nend\n\none = One.new\none.donut\nputs pancake\nIf you are coding along, don’t forget to run ctags -R . again since you now have several new procedures. You have two instances of the pancake procedure. If you are inside two.rb and you pressed Ctrl-], what would happen?\nVim will jump to def pancake inside two.rb, not the def pancake inside one.rb. This is because Vim sees the pancake procedure inside two.rb as having a higher priority than the other pancake procedure."
  },
  {
    "objectID": "chapters/ch16_tags.md.html#tag-priority",
    "href": "chapters/ch16_tags.md.html#tag-priority",
    "title": "16  Ch16. Tags",
    "section": "16.7 Tag Priority",
    "text": "16.7 Tag Priority\nNot all tags are equal. Some tags have higher priorities. If Vim is presented with duplicate item names, Vim checks the priority of the keyword. The order is:\n\nA fully matched static tag in the current file.\nA fully matched global tag in the current file.\nA fully matched global tag in a different file.\nA fully matched static tag in another file.\nA case-insensitively matched static tag in the current file.\nA case-insensitively matched global tag in the current file.\nA case-insensitively matched global tag in the a different file.\nA case-insensitively matched static tag in the current file.\n\nAccording to the priority list, Vim prioritizes the exact match found on the same file. That’s why Vim chooses the pancake procedure inside two.rb over the pancake procedure inside one.rb. There are some exceptions to the priority list above depending on your 'tagcase', 'ignorecase', and 'smartcase' settings, but I will not discuss them here. If you are interested, check out :h tag-priority."
  },
  {
    "objectID": "chapters/ch16_tags.md.html#selective-tag-jumps",
    "href": "chapters/ch16_tags.md.html#selective-tag-jumps",
    "title": "16  Ch16. Tags",
    "section": "16.8 Selective Tag Jumps",
    "text": "16.8 Selective Tag Jumps\nIt would be nice if you can choose which tag items to jump to instead of always going to the highest priority tag item. Maybe you actually need to jump to the pancake method in one.rb and not the one in two.rb. To do that, you can use :tselect. Run:\n:tselect pancake\nYou will see, on the bottom of the screen:\n## pri kind tag               file\n1 F C f    pancake           two.rb\n             def pancake\n2 F   f    pancake           one.rb\n             class:One\n             def pancake\nIf you type 2, Vim will jump to the procedure in one.rb. If you type 1, Vim will jump to the procedure in two.rb.\nPay attention to the pri column. You have F C on the first match and F on the second match. This is what Vim uses to determine the tag priotity. F C means a fully-matched (F) global tag in the current (C) file. F means only a fully-matched (F) global tag. F C always have a higher priority than F.\nIf you run :tselect donut, Vim also prompts you to select which tag item to jump to, even though there is only one option to choose from. Is there a way for Vim to prompt the tag list only if there are multiple matches and to jump immediately if there is only one tag found?\nOf course! Vim has a :tjump method. Run:\n:tjump donut\nVim will immediately jump to the donut procedure in one.rb, much like running :tag donut. Now run:\n:tjump pancake\nVim will prompt you tag options to choose from, much like running :tselect pancake. With tjump you get the best of both methods.\nVim has a normal mode key for tjump: g Ctrl-]. I personally like g Ctrl-] better than Ctrl-]."
  },
  {
    "objectID": "chapters/ch16_tags.md.html#autocompletion-with-tags",
    "href": "chapters/ch16_tags.md.html#autocompletion-with-tags",
    "title": "16  Ch16. Tags",
    "section": "16.9 Autocompletion With Tags",
    "text": "16.9 Autocompletion With Tags\nTags can assist autocompletions. Recall from chapter 6, Insert Mode, that you can use Ctrl-X sub-mode to do various autocompletions. One autocompletion sub-mode that I did not mention was Ctrl-]. If you do Ctrl-X Ctrl-] while in the insert mode, Vim will use the tag file for autocompletion.\nIf you go into the insert mode and type Ctrl-x Ctrl-], you will see:\nOne\ndonut\ninitialize\npancake"
  },
  {
    "objectID": "chapters/ch16_tags.md.html#tag-stack",
    "href": "chapters/ch16_tags.md.html#tag-stack",
    "title": "16  Ch16. Tags",
    "section": "16.10 Tag Stack",
    "text": "16.10 Tag Stack\nVim keeps a list of all the tags you have jumped to and from in a tag stack. You can see this stack with :tags. If you had first tag-jumped to pancake, followed by donut, and run :tags, you will see:\n  # TO tag         FROM line  in file/text\n  1  1 pancake            10  ch16_tags/two.rb\n  2  1 donut               9  ch16_tags/two.rb\n>\nNote the > symbol above. It shows your current position in the stack. To pop the stack to go back to one previous stack, you can run :pop. Try it, then run :tags again:\n  # TO tag         FROM line  in file/text\n  1  1 pancake            10  puts pancake\n> 2  1 donut               9  one.donut\n\nNote that the > symbol is now on line two, where the donut is. pop one more time, then run :tags again:\n  # TO tag         FROM line  in file/text\n> 1  1 pancake            10  puts pancake\n  2  1 donut               9  one.donut\nIn normal mode, you can run Ctrl-t to achieve the same effect as :pop."
  },
  {
    "objectID": "chapters/ch16_tags.md.html#automatic-tag-generation",
    "href": "chapters/ch16_tags.md.html#automatic-tag-generation",
    "title": "16  Ch16. Tags",
    "section": "16.11 Automatic Tag Generation",
    "text": "16.11 Automatic Tag Generation\nOne of the biggest drawbacks of Vim tags is that each time you make a significant change, you have to regenerate the tag file. If you recently renamed the pancake procedure to the waffle procedure, the tag file did not know that the pancake procedure had been renamed. It still stored pancake in the list of tags. You have to run ctags -R . to create an updated tag file. Recreating a new tag file this way can be cumbersome.\nLuckily there are several methods you can employ to generate tags automatically."
  },
  {
    "objectID": "chapters/ch16_tags.md.html#generate-a-tag-on-save",
    "href": "chapters/ch16_tags.md.html#generate-a-tag-on-save",
    "title": "16  Ch16. Tags",
    "section": "16.12 Generate a Tag on Save",
    "text": "16.12 Generate a Tag on Save\nVim has an autocommand (autocmd) method to execute any command on an event trigger. You can use this to generate tags on each save. Run:\n:autocmd BufWritePost *.rb silent !ctags -R .\nBreakdown: - autocmd is a command-line command. It accepts an event, file pattern, and a command. - BufWritePost is an event for saving a buffer. Each time you save a file, you trigger a BufWritePost event. - .rb is a file pattern for ruby files. - silent is actually part of the command you are passing. Without this, Vim will display press ENTER or type command to continue each time you trigger the autocommand. - !ctags -R . is the command to execute. Recall that !cmd from inside Vim executes terminal command.\nNow each time you save from inside a ruby file, Vim will run ctags -R .."
  },
  {
    "objectID": "chapters/ch16_tags.md.html#using-plugins",
    "href": "chapters/ch16_tags.md.html#using-plugins",
    "title": "16  Ch16. Tags",
    "section": "16.13 Using Plugins",
    "text": "16.13 Using Plugins\nThere are several plugins to generate ctags automatically:\n\nvim-gutentags\nvim-tags\nvim-easytags\nvim-autotag\n\nI use vim-gutentags. It is simple to use and will work right out of the box."
  },
  {
    "objectID": "chapters/ch16_tags.md.html#ctags-and-git-hooks",
    "href": "chapters/ch16_tags.md.html#ctags-and-git-hooks",
    "title": "16  Ch16. Tags",
    "section": "16.14 Ctags and Git Hooks",
    "text": "16.14 Ctags and Git Hooks\nTim Pope, author of many great Vim plugins, wrote a blog suggesting to use git hooks. Check it out."
  },
  {
    "objectID": "chapters/ch16_tags.md.html#learn-tags-the-smart-way",
    "href": "chapters/ch16_tags.md.html#learn-tags-the-smart-way",
    "title": "16  Ch16. Tags",
    "section": "16.15 Learn Tags the Smart Way",
    "text": "16.15 Learn Tags the Smart Way\nA tag is useful once configured properly. Suppose you are faced with a new codebase and you want to understand what functionFood does, you can easily read it by jumping to its definition. Inside it, you learn that it also calls functionBreakfast. You follow it and you learn that it calls functionPancake. Your function call graph looks something like this:\nfunctionFood -> functionBreakfast -> functionPancake\nThis gives you insight that this code flow is related to having a pancake for breakfast.\nTo learn more about tags, check out :h tags. Now that you know how to use tags, let’s explore a different feature: folding."
  },
  {
    "objectID": "chapters/ch17_fold.md.html#manual-fold",
    "href": "chapters/ch17_fold.md.html#manual-fold",
    "title": "17  Ch17. Fold",
    "section": "17.1 Manual Fold",
    "text": "17.1 Manual Fold\nImagine that you are folding a sheet of paper to cover some text. The actual text does not go away, it is still there. Vim fold works the same way. It folds a range of text, hiding it from display without actually deleting it.\nThe fold operator is z (when a paper is folded, it is shaped like the letter z).\nSuppose you have this text:\nFold me\nHold me\nWith the cursor in the first line, type zfj. Vim folds both lines into one. You should see something like this:\n+-- 2 lines: Fold me -----\nHere is the breakdown: - zf is the fold operator. - j is the motion for the fold operator.\nYou can open a folded text with zo. To close the fold, use zc.\nFold is an operator, so it follows the grammar rule (verb + noun). You can pass the fold operator with a motion or text object. To fold an inner paragraph, run zfip. To fold to the end of a file, run zfG. To fold the texts between { and }, run zfa{.\nYou can fold from the visual mode. Highlight the area you want to fold (v, V, or Ctrl-v), then run zf.\nYou can execute a fold from the command-line mode with the :fold command. To fold the current line and the line after it, run:\n:,+1fold\n,+1 is the range. If you don’t pass parameters to the range, it defaults to the current line. +1 is the range indicator for the next line. To fold the lines 5 to 10, run :5,10fold. To fold from the current position to the end of the line, run :,$fold.\nThere are many other fold and unfold commands. I find them too many to remember when starting out. The most useful ones are: - zR to open all folds. - zM to close all folds. - za toggle a fold.\nYou can run zR and zM on any line, but za only works when you are on a folded / unfolded line. To learn more folding commands, check out :h fold-commands."
  },
  {
    "objectID": "chapters/ch17_fold.md.html#different-fold-methods",
    "href": "chapters/ch17_fold.md.html#different-fold-methods",
    "title": "17  Ch17. Fold",
    "section": "17.2 Different Fold Methods",
    "text": "17.2 Different Fold Methods\nThe section above covers Vim’s manual fold. There are six different folding methods in Vim: 1. Manual 2. Indent 3. Expression 4. Syntax 5. Diff 6. Marker\nTo see which folding method you are currently using, run :set foldmethod?. By default, Vim uses the manual method.\nIn the rest of the chapter, you will learn the other five folding methods. Let’s get started with the indent fold."
  },
  {
    "objectID": "chapters/ch17_fold.md.html#indent-fold",
    "href": "chapters/ch17_fold.md.html#indent-fold",
    "title": "17  Ch17. Fold",
    "section": "17.3 Indent Fold",
    "text": "17.3 Indent Fold\nTo use an indent fold, change the 'foldmethod' to indent:\n:set foldmethod=indent\nSuppose that you have the text:\nOne\n  Two\n  Two again\nIf you run :set foldmethod=indent, you will see:\nOne\n+-- 2 lines: Two -----\nWith indent fold, Vim looks at how many spaces each line has at the beginning and compares it with the 'shiftwidth' option to determine its foldability. 'shiftwidth' returns the number of spaces required for each step of the indent. If you run:\n:set shiftwidth?\nVim’s default 'shiftwidth' value is 2. On the text above, there are two spaces between the start of the line and the text Two and Two again. When Vim sees the number of spaces and that the 'shiftwidth' value is 2, Vim considers that line to have an indent fold level of one.\nSuppose this time you only one space between the start of the line and the text:\nOne\n Two\n Two again\nRight now if you run :set foldmethod=indent, Vim does not fold the indented line because there isn’t sufficient space on each line. One space is not considered an indentation. However, if you change the 'shiftwidth' to 1:\n:set shiftwidth=1\nThe text is now foldable. It is now considered an indentation.\nRestore the shiftwidth back to 2 and the spaces between the texts to two again. In addition, add two additional texts:\nOne\n  Two\n  Two again\n    Three\n    Three again\nRun fold (zM), you will see:\nOne\n+-- 4 lines: Two -----\nUnfold the folded lines (zR), then put your cursor on Three and toggle the text’s folding state (za):\nOne\n  Two\n  Two again\n+-- 2 lines: Three -----\nWhat’s this? A fold within a fold?\nNested folds are valid. The text Two and Two again have fold level of one. The text Three and Three again have fold level of two. If you have a foldable text with a higher fold level within a foldable text, you will have multiple fold layers."
  },
  {
    "objectID": "chapters/ch17_fold.md.html#expression-fold",
    "href": "chapters/ch17_fold.md.html#expression-fold",
    "title": "17  Ch17. Fold",
    "section": "17.4 Expression Fold",
    "text": "17.4 Expression Fold\nExpression fold allows you to define an expression to match for a fold. After you define the fold expressions, Vim scans each line for the value of 'foldexpr'. This is the variable that you have to configure to return the appropriate value. If the 'foldexpr' returns 0, then the line is not folded. If it returns 1, then that line has a fold level of 1. If it returns 2, then that line has a fold level of 2. There are more values other than integers, but I won’t go over them. If you are curious, check out :h fold-expr.\nFirst, let’s change the foldmethod:\n:set foldmethod=expr\nSuppose you have a list of breakfast foods and you want to fold all breakfast items starting with p:\ndonut\npancake\npop-tarts\nprotein bar\nsalmon\nscrambled eggs\nNext, change the foldexpr to capture the expressions starting with p:\n:set foldexpr=getline(v:lnum)[0]==\\\\\"p\\\\\"\nThe expression above looks complicated. Let’s break it down: - :set foldexpr sets up the 'foldexpr' option to accept a custom expression. - getline() is a Vimscript function that returns the content of any given line. If you run :echo getline(5), it will return the content of line 5. - v:lnum is Vim’s special variable for the 'foldexpr' expression. Vim scans each line and at that moment stores each line’s number in v:lnum variable. On line 5, v:lnum has value of 5. On line 10, v:lnum has value of 10. - [0] in the context of getline(v:lnum)[0] is the first character of each line. When Vim scans a line, getline(v:lnum) returns the content of each line. getline(v:lnum)[0] returns the first character of each line. On the first line of our list, donut, getline(v:lnum)[0] returns d. On the second line of our list, pancake, getline(v:lnum)[0] returns p. - ==\\\\\"p\\\\\" is the second half of the equality expression. It checks if the expression you just evaluated is equal to p. If it is true, it returns 1. If it is false, it returns 0. In Vim, 1 is truthy and 0 is falsy. So on the lines that start with an p, it returns 1. Recall if a 'foldexpr' has a value of 1, then it has a fold level of 1.\nAfter running this expression, you should see:\ndonut\n+-- 3 lines: pancake -----\nsalmon\nscrambled eggs"
  },
  {
    "objectID": "chapters/ch17_fold.md.html#syntax-fold",
    "href": "chapters/ch17_fold.md.html#syntax-fold",
    "title": "17  Ch17. Fold",
    "section": "17.5 Syntax Fold",
    "text": "17.5 Syntax Fold\nSyntax fold is determined by syntax language highlighting. If you use a language syntax plugin like vim-polyglot, the syntax fold will work right out of the box. Just change the fold method to syntax:\n:set foldmethod=syntax\nLet’s assume you are editing a JavaScript file and you have vim-polyglot installed. If you have an array like the following:\nconst nums = [\n  one,\n  two,\n  three,\n  four\n]\nIt will be folded with a syntax fold. When you define a syntax highlighting for a particular language (typically inside the syntax/ directory), you can add a fold attribute to make it foldable. Below is a snippet from vim-polyglot JavaScript syntax file. Notice the fold keyword at the end.\nsyntax region  jsBracket                      matchgroup=jsBrackets            start=/\\[/ end=/\\]/ contains=@jsExpression,jsSpreadExpression extend fold\nThis guide won’t cover the syntax feature. If you’re curious, check out :h syntax.txt."
  },
  {
    "objectID": "chapters/ch17_fold.md.html#diff-fold",
    "href": "chapters/ch17_fold.md.html#diff-fold",
    "title": "17  Ch17. Fold",
    "section": "17.6 Diff Fold",
    "text": "17.6 Diff Fold\nVim can do a diff procedure to compare two or more files.\nIf you have file1.txt:\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nAnd file2.txt:\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nemacs is ok\nRun vimdiff file1.txt file2.txt:\n+-- 3 lines: vim is awesome -----\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\n[vim is awesome] / [emacs is ok]\nVim automatically folds some of the identical lines. When you are running the vimdiff command, Vim automatically uses foldmethod=diff. If you run :set foldmethod?, it will return diff."
  },
  {
    "objectID": "chapters/ch17_fold.md.html#marker-fold",
    "href": "chapters/ch17_fold.md.html#marker-fold",
    "title": "17  Ch17. Fold",
    "section": "17.7 Marker Fold",
    "text": "17.7 Marker Fold\nTo use a marker fold, run:\n:set foldmethod=marker\nSuppose you have the text:\nHello\n\n{{{\nworld\nvim\n}}}\nRun zM, you will see:\nhello\n\n+-- 4 lines: -----\nVim sees {{{ and }}} as fold indicators and folds the texts between them. With the marker fold, Vim looks for special markers, defined by 'foldmarker' option, to mark folding areas. To see what markers Vim uses, run:\n:set foldmarker?\nBy default, Vim uses {{{ and }}} as indicators. If you want to change the indicator to another texts, like coffee1 and coffee2:\n:set foldmarker=coffee1,coffee2\nIf you have the text:\nhello\n\ncoffee1\nworld\nvim\ncoffee2\nNow Vim uses coffee1 and coffee2 as the new folding markers. As a side note, an indicator must be a literal string and cannot be a regex."
  },
  {
    "objectID": "chapters/ch17_fold.md.html#persisting-fold",
    "href": "chapters/ch17_fold.md.html#persisting-fold",
    "title": "17  Ch17. Fold",
    "section": "17.8 Persisting Fold",
    "text": "17.8 Persisting Fold\nYou loses all fold information when you close the Vim session. If you have this file, count.txt:\none\ntwo\nthree\nfour\nfive\nThen do a manual fold from line three down (:3,$fold):\none\ntwo\n+-- 3 lines: three ---\nWhen you exit Vim and reopen count.txt, the folds are no longer there!\nTo preserve the folds, after folding, run:\n:mkview\nThen when you open up count.txt, run:\n:loadview\nYour folds are restored. However, you have to manually run mkview and loadview. I know that one of these days, I will forget to run mkview before closing the file and I will lose all the folds. How can we automate this process?\nTo automatically run mkview when you close a .txt file and run loadview when you open a .txt file, add this in your vimrc:\nautocmd BufWinLeave *.txt mkview\nautocmd BufWinEnter *.txt silent loadview\nRecall that autocmd is used to execute a command on an event trigger. The two events here are: - BufWinLeave for when you remove a buffer from a window. - BufWinEnter for when you load a buffer in a window.\nNow after you fold inside a .txt file and exit Vim, the next time you open that file, your fold information will be restored.\nBy default, Vim saves the fold information when running mkview inside ~/.vim/view for the Unix system. For more information, check out :h 'viewdir'."
  },
  {
    "objectID": "chapters/ch17_fold.md.html#learn-fold-the-smart-way",
    "href": "chapters/ch17_fold.md.html#learn-fold-the-smart-way",
    "title": "17  Ch17. Fold",
    "section": "17.9 Learn Fold the Smart Way",
    "text": "17.9 Learn Fold the Smart Way\nWhen I first started Vim, I neglected to learn fold because I didn’t think it was useful. However, the longer I code, the more useful I find folding is. Strategically placed folds can give you a better overview of the text structure, like a book’s table of content.\nWhen you learn fold, start with the manual fold because that can be used on-the-go. Then gradually learn different tricks to do indent and marker folds. Finally, learn how to do syntax and expression folds. You can even use the latter two to write your own Vim plugins."
  },
  {
    "objectID": "chapters/ch18_git.md.html#diffing",
    "href": "chapters/ch18_git.md.html#diffing",
    "title": "18  Ch18. Git",
    "section": "18.1 Diffing",
    "text": "18.1 Diffing\nRecall in the previous chapter, you can run a vimdiff command to show the differences between multiple files.\nSuppose you have two files, file1.txt and file2.txt.\nInside file1.txt:\npancakes\nwaffles\napples\n\nmilk\napple juice\n\nyogurt\nInside file2.txt:\npancakes\nwaffles\noranges\n\nmilk\norange juice\n\nyogurt\nTo see the differences between both files, run:\nvimdiff file1.txt file2.txt\nAlternatively you could run:\nvim -d file1.txt file2.txt\nvimdiff displays two buffers side-by-side. On the left is file1.txt and on the right is file2.txt. The first differences (apples and oranges) are highlighted on both lines.\nSuppose you want to make the second buffer to have apples, not oranges. To transfer the content from your current position (you’re currently on file1.txt) to file2.txt, first go to the next diff with ]c (to jump to the previous diff window, use [c). The cursor should be on apples now. Run :diffput. Both files should now have apples.\nIf you need to transfer the text from the other buffer (orange juice, file2.txt) to replace the text on the current buffer (apple juice, file1.txt), with your cursor still on file1.txt window, first go to the next diff with ]c. Your cursor now should be on apple juice. Run :diffget to get the orange juice from another buffer to replace apple juice in our buffer.\n:diffput puts out the text from the current buffer to another buffer. :diffget gets the text from another buffer to the current buffer.\nIf you have multiple buffers, you can run :diffput fileN.txt and :diffget fileN.txt to target the the fileN buffer."
  },
  {
    "objectID": "chapters/ch18_git.md.html#vim-as-a-merge-tool",
    "href": "chapters/ch18_git.md.html#vim-as-a-merge-tool",
    "title": "18  Ch18. Git",
    "section": "18.2 Vim As a Merge Tool",
    "text": "18.2 Vim As a Merge Tool\n\nI love resolving merge conflicts! - Nobody\n\nI don’t know anyone who likes resolving merge conflicts. However, they are inevitable. In this section, you will learn how to leverage Vim as a merge conflict resolution tool.\nFirst, change the default merge tool to use vimdiff by running:\ngit config merge.tool vimdiff\ngit config merge.conflictstyle diff3\ngit config mergetool.prompt false\nAlternatively, you can modify the ~/.gitconfig directly (by default it should be in root, but yours might be in different place). The commands above should modify your gitconfig to look like the setting below, if you haven’t run them already, you can also manually edit your gitconfig.\n[core]\n  editor = vim\n[merge]\n  tool = vimdiff\n  conflictstyle = diff3\n[difftool]\n  prompt = false\nLet’s create a fake merge conflict to test this out. Create a directory /food and make it a git repository:\ngit init\nAdd a file, breakfast.txt. Inside:\npancakes\nwaffles\noranges\nAdd the file and commit it:\ngit add .\ngit commit -m \"Initial breakfast commit\"\nNext, create a new branch and call it apples branch:\ngit checkout -b apples\nChange the breakfast.txt:\npancakes\nwaffles\napples\nSave the file, then add and commit the change:\ngit add .\ngit commit -m \"Apples not oranges\"\nGreat. Now you have oranges in the master branch and apples in the apples branch. Let’s return to the master branch:\ngit checkout master\nInside breakfast.txt, you should see the base text, oranges. Let’s change it to grapes because they are in season right now:\npancakes\nwaffles\ngrapes\nSave, add, and commit:\ngit add .\ngit commit -m \"Grapes not oranges\"\nNow you are ready to merge the apples branch into the master branch:\ngit merge apples\nYou should see an error:\nAuto-merging breakfast.txt\nCONFLICT (content): Merge conflict in breakfast.txt\nAutomatic merge failed; fix conflicts and then commit the result.\nA conflict, great! Let’s resolve the conflict using our newly-configured mergetool. Run:\ngit mergetool\nVim displays four windows. Pay attention to the top three:\n\nLOCAL contains grapes. This is the change in local, what you are merging into.\nBASE contains oranges. This is the common ancestor between LOCAL and REMOTE to compare how they diverge.\nREMOTE contains apples. This is what is being merged into.\n\nAt the bottom (the fourth window) you see:\npancakes\nwaffles\n<<<<<<< HEAD\ngrapes\n||||||| db63958\noranges\n=======\napples\n>>>>>>> apples\nThe fourth window contains the merge conflict texts. With this setup, it is easier to see what change each environment has. You can see the content from LOCAL, BASE, and REMOTE at the same time.\nYour cursor should be on the fourth windows, on the highlighted area. To get the change from LOCAL (grapes), run :diffget LOCAL. To get the change from BASE (oranges), run :diffget BASE and to get the change from REMOTE (apples), run :diffget REMOTE.\nIn this case, let’s get the change from LOCAL. Run :diffget LOCAL. The fourth window will now have grapes. Save and exit all files (:wqall) when you are done. That wasn’t bad, right?\nIf you notice, you also have a file breakfast.txt.orig now. Git creates a backup file in case things don’t go well. If you don’t want git to create a backup during a merge, run:\ngit config --global mergetool.keepBackup false"
  },
  {
    "objectID": "chapters/ch18_git.md.html#git-inside-vim",
    "href": "chapters/ch18_git.md.html#git-inside-vim",
    "title": "18  Ch18. Git",
    "section": "18.3 Git Inside Vim",
    "text": "18.3 Git Inside Vim\nVim does not have a native git feature built-in. One way to run git commands from Vim is to use the bang operator, !, in the command-line mode.\nAny git command can be run with !:\n:!git status\n:!git commit\n:!git diff\n:!git push origin master\nYou can also use Vim’s % (current buffer) or # (other buffer) conventions:\n:!git add %         \" git add current file\n:!git checkout #    \" git checkout the other file\nOne Vim trick you can use to add multiple files in different Vim window is to run:\n:windo !git add %\nThen make a commit:\n:!git commit \"Just git-added everything in my Vim window, cool\"\nThe windo command is one of Vim’s do commands, similar to argdo that you saw previously. windo executes the command on each window.\nAlternatively, you can also use bufdo !git add % to git add all buffers or argdo !git add % to git add all the file arguments, depending on your workflow."
  },
  {
    "objectID": "chapters/ch18_git.md.html#plugins",
    "href": "chapters/ch18_git.md.html#plugins",
    "title": "18  Ch18. Git",
    "section": "18.4 Plugins",
    "text": "18.4 Plugins\nThere are many Vim plugins for git support. Below is a list of some of the popular git-related plugins for Vim (there is probably more at the time you read this):\n\nvim-gitgutter\nvim-signify\nvim-fugitive\ngv.vim\nvimagit\nvim-twiggy\nrhubarb\n\nOne of the most popular ones is vim-fugitive. For the remaining of the chapter, I will go over a several git workflow using this plugin."
  },
  {
    "objectID": "chapters/ch18_git.md.html#vim-fugitive",
    "href": "chapters/ch18_git.md.html#vim-fugitive",
    "title": "18  Ch18. Git",
    "section": "18.5 Vim-fugitive",
    "text": "18.5 Vim-fugitive\nThe vim-fugitive plugin allows you to run the git CLI without leaving the Vim editor. You will find that some commands are better when executed from inside Vim.\nTo get started, install the vim-fugitive with a Vim plugin manager (vim-plug, vundle, dein.vim, etc)."
  },
  {
    "objectID": "chapters/ch18_git.md.html#git-status",
    "href": "chapters/ch18_git.md.html#git-status",
    "title": "18  Ch18. Git",
    "section": "18.6 Git Status",
    "text": "18.6 Git Status\nWhen you run the :Git command without any parameters, vim-fugitive displays a git summary window. It shows the untracked, unstaged, and staged file(s). While in this git status mode, you can do several things: - Ctrl-N / Ctrl-P to go up or down the file list. - - to stage or unstage the file name under the cursor. - s to stage the file name under the cursor. - u to unstage the file name under the cursor. - > / < to display or hide an inline diff of the file name under the cursor.\nFor more, check out :h fugitive-staging-maps."
  },
  {
    "objectID": "chapters/ch18_git.md.html#git-blame",
    "href": "chapters/ch18_git.md.html#git-blame",
    "title": "18  Ch18. Git",
    "section": "18.7 Git Blame",
    "text": "18.7 Git Blame\nWhen you run the :Git blame command from the current file, vim-fugitive displays a split blame window. This can be useful to find the person responsible for writing that buggy line of code so you can yell at him / her (just kidding).\nSome things you can do while in this \"git blame\" mode: - q to close the blame window. - A to resize the author column. - C to resize the commit column. - D to resize the date / time column.\nFor more, check out :h :Git_blame."
  },
  {
    "objectID": "chapters/ch18_git.md.html#gdiffsplit",
    "href": "chapters/ch18_git.md.html#gdiffsplit",
    "title": "18  Ch18. Git",
    "section": "18.8 Gdiffsplit",
    "text": "18.8 Gdiffsplit\nWhen you run the :Gdiffsplit command, vim-fugitive runs a vimdiff of the current file’s latest changes against the index or work tree. If you run :Gdiffsplit <commit>, vim-fugitive runs a vimdiff against that file inside <commit>.\nBecause you are in a vimdiff mode, you can get or put the diff with :diffput and :diffget."
  },
  {
    "objectID": "chapters/ch18_git.md.html#gwrite-and-gread",
    "href": "chapters/ch18_git.md.html#gwrite-and-gread",
    "title": "18  Ch18. Git",
    "section": "18.9 Gwrite and Gread",
    "text": "18.9 Gwrite and Gread\nWhen you run the :Gwrite command in a file after you make changes, vim-fugitive stages the changes. It is like running git add <current-file>.\nWhen you run the :Gread command in a file after you make changes, vim-fugitive restores the file to the state prior to the changes. It is like running git checkout <current-file>. One advantage of running :Gread is the action is undo-able. If, after you run :Gread, you change your mind and want to keep the old change, you can just run undo (u) and Vim will undo the :Gread action. This would not have been possible if you had run git checkout <current-file> from the CLI."
  },
  {
    "objectID": "chapters/ch18_git.md.html#gclog",
    "href": "chapters/ch18_git.md.html#gclog",
    "title": "18  Ch18. Git",
    "section": "18.10 Gclog",
    "text": "18.10 Gclog\nWhen you run the :Gclog command, vim-fugitive displays the commit history. It is like running the git log command. Vim-fugitive uses Vim’s quickfix to accomplish this, so you can use :cnext and :cprevious to traverse to the next or previous log information. You can open and close the log list with :copen and :cclose.\nWhile in this \"git log\" mode, you can do two things: - View the tree. - Visit the parent (the previous commit).\nYou can pass to :Gclog arguments just like the git log command. If your project has a long commit history and you only need to view the last three commits, you can run :Gclog -3. If you need to filter it based on the committer’s date, you can run something like :Gclog --after=\"January 1\" --before=\"March 14\"."
  },
  {
    "objectID": "chapters/ch18_git.md.html#more-vim-fugitive",
    "href": "chapters/ch18_git.md.html#more-vim-fugitive",
    "title": "18  Ch18. Git",
    "section": "18.11 More Vim-fugitive",
    "text": "18.11 More Vim-fugitive\nThese are only a few examples of what vim-fugitive can do. To learn more about vim-fugitive, check out :h fugitive.txt. Most of the popular git commands are probably optimized with vim-fugitive. You just have to look for them in the documentation.\nIf you are inside one of vim-fugitive’s special mode (for example, inside :Git or :Git blame mode) and you want to learn what shortcuts are available, press g?. Vim-fugitive will display the appropriate :help window for the mode you are in. Neat!"
  },
  {
    "objectID": "chapters/ch18_git.md.html#learn-vim-and-git-the-smart-way",
    "href": "chapters/ch18_git.md.html#learn-vim-and-git-the-smart-way",
    "title": "18  Ch18. Git",
    "section": "18.12 Learn Vim and Git the Smart Way",
    "text": "18.12 Learn Vim and Git the Smart Way\nYou may find vim-fugitive to be a good compliment to your workflow (or not). Regardless, I would strongly encourage you to check out all the plugins listed above. There are probably others I didn’t list. Go try them out.\nOne obvious way to get better with Vim-git integration is to read more about git. Git, on its own, is a vast topic and I am only showing a fraction of it. With that, let’s git going (pardon the pun) and talk about how to use Vim to compile your code!"
  },
  {
    "objectID": "chapters/ch19_compile.md.html#compile-from-the-command-line",
    "href": "chapters/ch19_compile.md.html#compile-from-the-command-line",
    "title": "19  Ch19. Compile",
    "section": "19.1 Compile From the Command Line",
    "text": "19.1 Compile From the Command Line\nYou can use the bang operator (!) to compile. If you need to compile your .cpp file with g++, run:\n:!g++ hello.cpp -o hello\nHowever, having to manually type the filename and the output filename each time is error-prone and tedious. A makefile is the way to go."
  },
  {
    "objectID": "chapters/ch19_compile.md.html#the-make-command",
    "href": "chapters/ch19_compile.md.html#the-make-command",
    "title": "19  Ch19. Compile",
    "section": "19.2 The Make Command",
    "text": "19.2 The Make Command\nVim has a :make command to run a makefile. When you run it, Vim looks for a makefile in the current directory to execute.\nCreate a file named makefile in the current directory and put these inside:\nall:\n    echo \"Hello all\"\nfoo:\n    echo \"Hello foo\"\nlist_pls:\n    ls\nRun this from Vim:\n:make\nVim executes it the same way as when you’re running it from the terminal. The :make command accepts parameter just like the terminal make command. Run:\n:make foo\n\" Outputs \"Hello foo\"\n\n:make list_pls\n\" Outputs the ls command result\nThe :make command uses Vim’s quickfix to store any error if you run a bad command. Let’s run a nonexisting target:\n:make dontexist\nYou should see an error running that command. To view that error, run the quickfix command :copen to view the quickfix window:\n|| make: *** No rule to make target `dontexist'.  Stop."
  },
  {
    "objectID": "chapters/ch19_compile.md.html#compiling-with-make",
    "href": "chapters/ch19_compile.md.html#compiling-with-make",
    "title": "19  Ch19. Compile",
    "section": "19.3 Compiling With Make",
    "text": "19.3 Compiling With Make\nLet’s use the makefile to compile a basic .cpp program. First, let’s create a hello.cpp file:\n#include <iostream>\n\nint main() {\n    std::cout << \"Hello!\\\\n\";\n    return 0;\n}\nUpdate your makefile to build and run a .cpp file:\nall:\n    echo \"build, run\"\nbuild:\n    g++ hello.cpp -o hello\nrun:\n    ./hello\nNow run:\n:make build\nThe g++ compiles ./hello.cpp and creates ./hello. Then run:\n:make run\nYou should see \"Hello!\" printed on the terminal."
  },
  {
    "objectID": "chapters/ch19_compile.md.html#different-make-program",
    "href": "chapters/ch19_compile.md.html#different-make-program",
    "title": "19  Ch19. Compile",
    "section": "19.4 Different Make Program",
    "text": "19.4 Different Make Program\nWhen you run :make, Vim actually runs whatever command that is set under the makeprg option. If you run :set makeprg?, you’ll see:\nmakeprg=make\nThe default :make command is the make external command. To change the :make command to execute g++ {your-file-name} each time you run it, run:\n:set makeprg=g++\\ %\nThe \\ is to escape the space after g++. The % symbol in Vim represents the current file. The command g++\\\\ % is equivalent to running g++ hello.cpp.\nGo to ./hello.cpp then run :make. Vim compiles hello.cpp and creates a.out because you didn’t specify the output. Let’s refactor it so it will name the compiled output with the name of the original file minus the extension. Run or add this to vimrc:\nset makeprg=g++\\ %\\ -o\\ %<\nThe breakdown: - g++\\ % is the same as above. It is equivalent to running g++ <your-file>. - -o is the output option. - %< in Vim represents the current file name without an extension (hello.cpp becomes hello).\nWhen you run :make from inside ./hello.cpp, it is compiled into ./hello. To quickly execute ./hello from inside ./hello.cpp, run :!./%<. Again, this is the same as running :!./{current-file-name-minus-the-extension}.\nFor more, check out :h :compiler and :h write-compiler-plugin."
  },
  {
    "objectID": "chapters/ch19_compile.md.html#auto-compile-on-save",
    "href": "chapters/ch19_compile.md.html#auto-compile-on-save",
    "title": "19  Ch19. Compile",
    "section": "19.5 Auto-compile on Save",
    "text": "19.5 Auto-compile on Save\nYou can make life even easier by automating compilation. Recall that you can use Vim’s autocmd to trigger automatic actions based on certain events. To automatically compile .cpp files on each save add this on your vimrc:\nautocmd BufWritePost *.cpp make\nEach time you save inside a .cpp file, Vim executes the make command."
  },
  {
    "objectID": "chapters/ch19_compile.md.html#switching-compiler",
    "href": "chapters/ch19_compile.md.html#switching-compiler",
    "title": "19  Ch19. Compile",
    "section": "19.6 Switching Compiler",
    "text": "19.6 Switching Compiler\nVim has a :compiler command to quickly switch compilers. Your Vim build probably comes with several pre-built compiler configurations. To check what compilers you have, run:\n:e $VIMRUNTIME/compiler/<Tab>\nYou should see a list of compilers for different programming languages.\nTo use the :compiler command, suppose you have a ruby file, hello.rb and inside it has:\nputs \"Hello ruby\"\nRecall that if you run :make, Vim executes whatever command is assigned to makeprg (default is make). If you run:\n:compiler ruby\nVim runs the $VIMRUNTIME/compiler/ruby.vim script and changes the makeprg to use the ruby command. Now if you run :set makeprg?, it should say makeprg=ruby (this depends on what is inside your $VIMRUNTIME/compiler/ruby.vim file or if you have another custom ruby compilers. Yours might be different). The :compiler {your-lang} command allows you to switch to different compilers quickly. This is useful if your project uses multiple languages.\nYou don’t have to use the :compiler and makeprg to compile a program. You can run a test script, lint a file, send a signal, or anything you want."
  },
  {
    "objectID": "chapters/ch19_compile.md.html#creating-a-custom-compiler",
    "href": "chapters/ch19_compile.md.html#creating-a-custom-compiler",
    "title": "19  Ch19. Compile",
    "section": "19.7 Creating a Custom Compiler",
    "text": "19.7 Creating a Custom Compiler\nLet’s create a simple Typescript compiler. Install Typescript (npm install -g typescript) to your machine. You should now have the tsc command. If you haven’t played with typescript before, tsc compiles a Typescript file into a Javascript file. Suppose that you have a file, hello.ts:\nconst hello = \"hello\";\nconsole.log(hello);\nIf you run tsc hello.ts, it will compile into hello.js. However, if you have the following expressions inside hello.ts:\nconst hello = \"hello\";\nhello = \"hello again\";\nconsole.log(hello);\nThis will throw an error because you can’t mutate a const variable. Running tsc hello.ts will throw an error:\nhello.ts:2:1 - error TS2588: Cannot assign to 'person' because it is a constant.\n\n2 person = \"hello again\";\n  ~~~~~~\n\n\nFound 1 error.\nTo create a simple Typescript compiler, in your ~/.vim/ directory, add a compiler directory (~/.vim/compiler/), then create a typescript.vim file (~/.vim/compiler/typescript.vim). Put this inside:\nCompilerSet makeprg=tsc\nCompilerSet errorformat=%f:\\ %m\nThe first line sets the makeprg to run the tsc command. The second line sets the error format to display the file (%f), followed by a literal colon (:) and an escaped space (\\), followed by the error message (%m). To learn more about the error formatting, check out :h errorformat.\nYou should also read some of the pre-made compilers to see how others do it. Check out :e $VIMRUNTIME/compiler/<some-language>.vim.\nBecause some plugins may interfere with the Typescript file, let’s open the hello.ts without any plugin, using the --noplugin flag:\nvim --noplugin hello.ts\nCheck the makeprg:\n:set makeprg?\nIt should say the default make program. To use the new Typescript compiler, run:\n:compiler typescript\nWhen you run :set makeprg?, it should say tsc now. Let’s put it to the test. Run:\n:make %\nRecall that % means the current file. Watch your Typescript compiler work as expected! To see the list of error(s), run :copen."
  },
  {
    "objectID": "chapters/ch19_compile.md.html#async-compiler",
    "href": "chapters/ch19_compile.md.html#async-compiler",
    "title": "19  Ch19. Compile",
    "section": "19.8 Async Compiler",
    "text": "19.8 Async Compiler\nSometimes compiling can take a long time. You don’t want to be staring at a frozen Vim while waiting for your compilation process to finish. Wouldn’t it be nice if you can compile asynchronously so you can still use Vim during compilation?\nLuckily there are plugins to run async processes. The two big ones are:\n\nvim-dispatch\nasyncrun.vim\n\nIn the remaining of this chapter, I will go over vim-dispatch, but I would strongly encourage you to try all of them out there.\nVim and NeoVim actually supports async jobs, but they are beyond the scope of this chapter. If you’re curious, check out :h job-channel-overview.txt."
  },
  {
    "objectID": "chapters/ch19_compile.md.html#plugin-vim-dispatch",
    "href": "chapters/ch19_compile.md.html#plugin-vim-dispatch",
    "title": "19  Ch19. Compile",
    "section": "19.9 Plugin: Vim-dispatch",
    "text": "19.9 Plugin: Vim-dispatch\nVim-dispatch has several commands, but the two main ones are :Make and :Dispatch commands.\n\n19.9.1 Async Make\nVim-dispatch’s :Make command is similar to Vim’s :make, but it runs asynchronously. If you are in a Javascript project and you need to run npm t, you might attempt to set your makeprg to be:\n:set makeprg=npm\\\\ t\nIf you run:\n:make\nVim will execute npm t, but you will be staring at the frozen screen while your JavaScript test runs. With vim-dispatch, you can just run:\n:Make\nVim will run npm t asynchronously. This way, while npm t is running on a background process, you can continue doing whatever you were doing. Awesome!\n\n\n19.9.2 Async Dispatch\nThe :Dispatch command is like the :compiler and the :! command. It can run any external command asynchronously in Vim.\nAssume that you are inside a ruby spec file and you need to run a test. Run:\n:Dispatch bundle exec rspec %\nVim will asynchronously run the rspec command against the current file (%).\n\n\n19.9.3 Automating Dispatch\nVim-dispatch has b:dispatch buffer variable that you can configure to evaluate specific command automatically. You can leverage it with autocmd. If you add this in your vimrc:\nautocmd BufEnter *_spec.rb let b:dispatch = 'bundle exec rspec %'\nNow each time you enter a file (BufEnter) that ends with _spec.rb, running :Dispatch automatically executes bundle exec rspec {your-current-ruby-spec-file}."
  },
  {
    "objectID": "chapters/ch19_compile.md.html#learn-compile-the-smart-way",
    "href": "chapters/ch19_compile.md.html#learn-compile-the-smart-way",
    "title": "19  Ch19. Compile",
    "section": "19.10 Learn Compile the Smart Way",
    "text": "19.10 Learn Compile the Smart Way\nIn this chapter, you learned that you can use the make and compiler commands to run any process from inside Vim asynchronously to complement your programming workflow. Vim’s ability to extend itself with other programs makes it powerful."
  },
  {
    "objectID": "chapters/ch20_views_sessions_viminfo.md.html#view",
    "href": "chapters/ch20_views_sessions_viminfo.md.html#view",
    "title": "20  Ch20. Views, Sessions, and Viminfo",
    "section": "20.1 View",
    "text": "20.1 View\nA View is the smallest subset of the three (View, Session, Viminfo). It is a collection of settings for one window. If you spend a long time working on a window and you want to preserve the maps and folds, you can use a View.\nLet’s create a file called foo.txt:\nfoo1\nfoo2\nfoo3\nfoo4\nfoo5\nfoo6\nfoo7\nfoo8\nfoo9\nfoo10\nIn this file, create three changes: 1. On line 1, create a manual fold zf4j (fold the next 4 lines). 2. Change the number setting: setlocal nonumber norelativenumber. This will remove the number indicators on the left side of the window. 3. Create a local mapping to go down two lines each time you press j instead of one: :nnoremap <buffer> j jj.\nYour file should look like this:\n+-- 5 lines: foo1 -----\nfoo6\nfoo7\nfoo8\nfoo9\nfoo10\n\n20.1.1 Configuring View Attributes\nRun:\n:set viewoptions?\nBy default it should say (yours may look different depending on your vimrc):\nviewoptions=folds,cursor,curdir\nLet’s configure viewoptions. The three attributes you want to preserve are the folds, the maps, and the local set options. If your setting looks like mine, you already have the folds option. You need to tell View to remember the localoptions. Run:\n:set viewoptions+=localoptions\nTo learn what other options are available for viewoptions, check out :h viewoptions. Now if you run :set viewoptions?, you should see:\nviewoptions=folds,cursor,curdir,localoptions\n\n\n20.1.2 Saving the View\nWith the foo.txt window properly folded and having nonumber norelativenumber options, let’s save the View. Run:\n:mkview\nVim creates a View file.\n\n\n20.1.3 View Files\nYou might wonder, Where did Vim save this View file? To see where Vim saves it, run:\n:set viewdir?\nIn Unix based OS the default should say ~/.vim/view (if you have a different OS, it might show a different path. Check out :h viewdir for more). If you are running a Unix based OS and want to change it to a different path, add this into your vimrc:\nset viewdir=$HOME/else/where\n\n\n20.1.4 Loading the View File\nClose the foo.txt if you haven’t, then open foo.txt again. You should see the original text without the changes. That’s expected.\nTo restore the state, you need to load the View file. Run:\n:loadview\nNow you should see:\n+-- 5 lines: foo1 -----\nfoo6\nfoo7\nfoo8\nfoo9\nfoo10\nThe folds, local settings, and local mappings are restored. If you notice, your cursor should also be on the line where you left it when you ran :mkview. As long as you have the cursor option, View also remembers your cursor position.\n\n\n20.1.5 Multiple Views\nVim lets you save 9 numbered Views (1-9).\nSuppose you want to make an additional fold (say you want to fold the last two lines) with :9,10 fold. Let’s save this as View 1. Run:\n:mkview 1\nIf you want to make one more fold with :6,7 fold and save it as a different View, run:\n:mkview 2\nClose the file. When you open foo.txt and you want to load View 1, run:\n:loadview 1\nTo load View 2, run:\n:loadview 2\nTo load the original View, run:\n:loadview\n\n\n20.1.6 Automating View Creation\nOne of the worst things that can happen is, after spending countless hours organizing a large file with folds, you accidentally close the window and lose all fold information. To prevent this, you might want to automatically create a View each time you close a buffer. Add this in your vimrc:\nautocmd BufWinLeave *.txt mkview\nAdditionally, it might be nice to load View when you open a buffer:\nautocmd BufWinEnter *.txt silent loadview\nNow you don’t have to worry about creating and loading View anymore when you are working with txt files. Keep in mind that over time, your ~/.vim/view might start to accumulate View files. It’s good to clean it up once every few months."
  },
  {
    "objectID": "chapters/ch20_views_sessions_viminfo.md.html#sessions",
    "href": "chapters/ch20_views_sessions_viminfo.md.html#sessions",
    "title": "20  Ch20. Views, Sessions, and Viminfo",
    "section": "20.2 Sessions",
    "text": "20.2 Sessions\nIf a View saves the settings of a window, a Session saves the information of all windows (including the layout).\n\n20.2.1 Creating a New Session\nSuppose you are working with these 3 files in a foobarbaz project:\nInside foo.txt:\nfoo1\nfoo2\nfoo3\nfoo4\nfoo5\nfoo6\nfoo7\nfoo8\nfoo9\nfoo10\nInside bar.txt:\nbar1\nbar2\nbar3\nbar4\nbar5\nbar6\nbar7\nbar8\nbar9\nbar10\nInside baz.txt:\nbaz1\nbaz2\nbaz3\nbaz4\nbaz5\nbaz6\nbaz7\nbaz8\nbaz9\nbaz10\nNow let’s say that you split your windows with :split and :vsplit. To preserve this look, you need to save the Session. Run:\n:mksession\nUnlike mkview where it saves to ~/.vim/view by default, mksession saves a Session file (Session.vim) in the current directory. Check out the file if you’re curious what’s inside.\nIf you want to save the Session file somewhere else, you can pass an argument to mksession:\n:mksession ~/some/where/else.vim\nIf you want to overwrite the existing Session file, call the command with a ! (:mksession! ~/some/where/else.vim).\n\n\n20.2.2 Loading a Session\nTo load a Session, run:\n:source Session.vim\nNow Vim looks like just the way you left it, including the split windows! Alternatively, you can also load a Session file from the terminal:\nvim -S Session.vim\n\n\n20.2.3 Configuring Session Attributes\nYou can configure the attributes Session saves. To see what is currently being saved, run:\n:set sessionoptions?\nMine says:\nblank,buffers,curdir,folds,help,tabpages,winsize,terminal\nIf you don’t want to save terminal when you save a Session, remove it from the session options. Run:\n:set sessionoptions-=terminal\nIf you want to add an options when you save a Session, run:\n:set sessionoptions+=options\nHere are some attributes that sessionoptions can store: - blank stores empty windows - buffers stores buffers - folds stores folds - globals stores global variables (must start with an uppercase letter and contain at least one lowercase letter) - options stores options and mappings - resize stores window lines and columns - winpos stores window position - winsize stores window sizes - tabpages stores tabs - unix stores files in Unix format\nFor the complete list check out :h 'sessionoptions'.\nSession is a useful tool to preserve your project’s external attributes. However, some internal attributes aren’t saved by Session, like local marks, registers, histories, etc. To save them, you need to use Viminfo!"
  },
  {
    "objectID": "chapters/ch20_views_sessions_viminfo.md.html#viminfo",
    "href": "chapters/ch20_views_sessions_viminfo.md.html#viminfo",
    "title": "20  Ch20. Views, Sessions, and Viminfo",
    "section": "20.3 Viminfo",
    "text": "20.3 Viminfo\nIf you notice, after yanking a word into register a and quitting Vim, the next time you open Vim you still have that text stored in register a. This is actually a work of Viminfo. Without it, Vim won’t remember the register after you close Vim.\nIf you use Vim 8 or higher, Vim enables Viminfo by default, so you may have been using Viminfo this whole time without knowing it!\nYou might ask: What does Viminfo save? How does it differ from Session?\nTo use Viminfo, first you need to have +viminfo feature available (:version). Viminfo stores: - The command-line history. - The search string history. - The input-line history. - Contents of non-empty registers. - Marks for several files. - File marks, pointing to locations in files. - Last search / substitute pattern (for n and &). - The buffer list. - Global variables.\nIn general, Session stores the external attributes and Viminfo the internal attributes.\nUnlike Session where you can have one Session file per project, you normally will use one Viminfo file per computer. Viminfo is project-agnostic.\nThe default Viminfo location for Unix is $HOME/.viminfo (~/.viminfo). If you use a different OS, your Viminfo location might be different. Check out :h viminfo-file-name. Each time you make internal changes, like yanking a text into a register, Vim automatically updates the Viminfo file.\nMake sure that you have nocompatible option set (set nocompatible), otherwise your Viminfo will not work.\n\n20.3.1 Writing and Reading Viminfo\nAlthough you will use only one Viminfo file, you can create multiple Viminfo files. To write a Viminfo file, use the :wviminfo command (:wv for short).\n:wv ~/.viminfo_extra\nTo overwrite an existing Viminfo file, add a bang to the wv command:\n:wv! ~/.viminfo_extra\nBy default Vim will read from ~/.viminfo file. To read from a different Viminfo file, run :rviminfo, or :rv for short:\n:rv ~/.viminfo_extra\nTo start Vim with a different Viminfo file from the terminal, use the i flag:\nvim -i viminfo_extra\nIf you use Vim for different tasks, like coding and writing, you can create a Viminfo optimized for writing and another for coding.\nvim -i viminfo_writing\n\nvim -i viminfo_coding\n\n\n20.3.2 Starting Vim Without Viminfo\nTo start Vim without Viminfo, you can run from the terminal:\nvim -i NONE\nTo make it permanent, you can add this in your vimrc file:\nset viminfo=\"NONE\"\n\n\n20.3.3 Configuring Viminfo Attributes\nSimilar to viewoptions and sessionoptions, you can instruct what attributes to save with the viminfo option. Run:\n:set viminfo?\nYou will get:\n!,'100,<50,s10,h\nThis looks cryptic. Let’s break it down: - ! saves global variables that start with an uppercase letter and don’t contain lowercase letters. Recall that g: indicates a global variable. For example, if at some point you wrote the assignment let g:FOO = \"foo\", Viminfo will save the global variable FOO. However if you did let g:Foo = \"foo\", Viminfo will not save this global variable because it contains lowercase letters. Without !, Vim won’t save those global variables. - '100 represents marks. In this case, Viminfo will save the local marks (a-z) of the last 100 files. Be aware that if you tell Viminfo to save too many files, Vim can start slowing down. 1000 is a good number to have. - <50 tells Viminfo how many maximum lines are saved for each register (50 in this case). If I yank 100 lines of text into register a (\"ay99j) and close Vim, the next time I open Vim and paste from register a (\"ap), Vim will only paste 50 lines max. If you don’t give maximum line number, all lines will be saved. If you give it 0, nothing will be saved. - s10 sets a size limit (in kb) for a register. In this case, any register greater than 10kb size will be excluded. - h disables highlighting (from hlsearch) when Vim starts.\nThere are other options that you can pass. To learn more, check out :h 'viminfo'."
  },
  {
    "objectID": "chapters/ch20_views_sessions_viminfo.md.html#using-views-sessions-and-viminfo-the-smart-way",
    "href": "chapters/ch20_views_sessions_viminfo.md.html#using-views-sessions-and-viminfo-the-smart-way",
    "title": "20  Ch20. Views, Sessions, and Viminfo",
    "section": "20.4 Using Views, Sessions, and Viminfo the Smart Way",
    "text": "20.4 Using Views, Sessions, and Viminfo the Smart Way\nVim has View, Session, and Viminfo to take different level of your Vim environment snapshots. For micro projects, use Views. For larger projects, use Sessions. You should take your time to check out all the options that View, Session, and Viminfo offers.\nCreate your own View, Session, and Viminfo for your own editing style. If you ever need to use Vim outside of your computer, you can just load your settings and you will immediately feel at home!"
  },
  {
    "objectID": "chapters/ch21_multiple_file_operations.md.html#different-ways-to-execute-a-command-in-multiple-files",
    "href": "chapters/ch21_multiple_file_operations.md.html#different-ways-to-execute-a-command-in-multiple-files",
    "title": "21  Multiple File Operations",
    "section": "21.1 Different Ways to Execute a Command in Multiple Files",
    "text": "21.1 Different Ways to Execute a Command in Multiple Files\nVim has eight ways to execute commands across multiple files: - arg list (argdo) - buffer list (bufdo) - window list (windo) - tab list (tabdo) - quickfix list (cdo) - quickfix list filewise (cfdo) - location list (ldo) - location list filewise (lfdo)\nPractically speaking, you will probably only use one or two most of the time (I personally use cdo and argdo more than others), but it’s good to learn about all the available options and use the ones that match your editing style.\nLearning eight commands might sound daunting. But in reality, these commands work similarly. After learning one, learning the rest will get easier. They all share the same big idea: make a list of their respective categories then pass them the command that you want to run."
  },
  {
    "objectID": "chapters/ch21_multiple_file_operations.md.html#argument-list",
    "href": "chapters/ch21_multiple_file_operations.md.html#argument-list",
    "title": "21  Multiple File Operations",
    "section": "21.2 Argument List",
    "text": "21.2 Argument List\nThe argument list is the most basic list. It creates a list of files. To create a list of file1, file2, and file3, you can run:\n:args file1 file2 file3\nYou can also pass it a wildcard (*), so if you want to make a list of all .js files in the current directory, run:\n:args *.js\nIf you want to make a list of all Javascript files that start with a in the current directory, run:\n:args a*.js\nThe wildcard matches one or more of any filename character in the current directory, but what if you need to search recursively in any directory? You can use the double wildcard (**). To get all Javascript files inside the directories within your current location, run:\n:args **/*.js\nOnce you run the args command, your current buffer will be switched to the first item on the list. To view the list of files you just created, run :args. Once you’ve created your list, you can traverse them. :first will put you on the first item on the list. :last will put you on the last list. To move the list forward one file at a time, run :next. To move the list backward one file at a time, run :prev. To move forward / backward one file at a time and save the changes, run :wnext and :wprev. There are plenty more navigation commands. Check out :h arglist for more.\nThe arg list is useful if you need to target a specific type of file or a few files. Maybe you need to update all the donut into pancake inside all yml files, you can do:\n:args **/*.yml\n:argdo %s/donut/pancake/g | update\n\nIf you run the args command again, it will replace the previous list. For example, if you previously ran:\n:args file1 file2 file3\nAssuming these files exist, you now have a list of file1, file2, and file3. Then you run this:\n:args file4 file5\nYour initial list of file1, file2, and file3 is replaced with file4 and file5. If you have file1, file2, and file3 in your arg list and you want to add file4 and file5 into your initial files list, use the :arga command. Run:\n:arga file4 file5\nNow you have file1, file2, file3, file4, and file5 in your arg list.\nIf you run :arga without any argument, Vim will add your current buffer into the current arg list. If you already have file1, file2, and file3 in your arg list and your current buffer is on file5, running :arga adds file5 into the list.\nOnce you have the list, you can pass it with any command-line commands of your choosing. You’ve seen it being done with substitution (:argdo %s/donut/pancake/g). Some other examples: - To delete all lines that contain dessert across the arg list, run :argdo g/dessert/d. - To execute macro a (assuming you have recorded something in macro a) across the arg list, run :argdo norm @a. - To write hello followed by the filename on the first line, run :argdo 0put='hello ' .. @:.\nOnce you’re done, don’t forget to save them with :update.\nSometimes you need to run the commands only on the first n items of the argument list. If that’s the case, just pass to the argdo command an address. For example, to run the substitute command only on the first 3 items from the list, run :1,3argdo %s/donut/pancake/g."
  },
  {
    "objectID": "chapters/ch21_multiple_file_operations.md.html#buffer-list",
    "href": "chapters/ch21_multiple_file_operations.md.html#buffer-list",
    "title": "21  Multiple File Operations",
    "section": "21.3 Buffer List",
    "text": "21.3 Buffer List\nThe buffer list will be organically created when you edit new files because each time you create a new file / open a file, Vim saves it in a buffer (unless you explicitly delete it). So if you already opened 3 files: file1.rb file2.rb file3.rb, you already have 3 items in your buffer list. To display the buffer list, run :buffers (alternatively: :ls or :files). To traverse forward and backward, use :bnext and :bprev. To go to the first and last buffer from the list, use :bfirst and :blast (having a blast yet? :D).\nBy the way, here’s a cool buffer trick unrelated to this chapter: if you have a number of items in your buffer list, you can show all of them with :ball (buffer all). The ball command displays all buffers horizontally. To display them vertically, run :vertical ball.\nBack to the topic, the mechanics to run operation across all buffers is similar to the arg list. Once you have created your buffer list, you just need to prepend the command(s) that you want to run with :bufdo instead of :argdo. So if you want to substitute all donut with pancake across all buffers then save the changes, run :bufdo %s/donut/pancake/g | update."
  },
  {
    "objectID": "chapters/ch21_multiple_file_operations.md.html#window-and-tab-list",
    "href": "chapters/ch21_multiple_file_operations.md.html#window-and-tab-list",
    "title": "21  Multiple File Operations",
    "section": "21.4 Window and Tab List",
    "text": "21.4 Window and Tab List\nThe windows and tabs list are also similar to the arg and buffer list. The only differences are their context and syntax.\nWindow operations are performed on each open window and performed with :windo. Tab operations are performed on each tab you have opened and performed with :tabdo. For more, check out :h list-repeat, :h :windo, and :h :tabdo.\nFor example, if you have three windows opened (you can open new windows with Ctrl-W v for a vertical window and Ctrl-W s for a horizontal window) and you run :windo 0put ='hello' . @%, Vim will output hello + filename to all open windows."
  },
  {
    "objectID": "chapters/ch21_multiple_file_operations.md.html#quickfix-list",
    "href": "chapters/ch21_multiple_file_operations.md.html#quickfix-list",
    "title": "21  Multiple File Operations",
    "section": "21.5 Quickfix List",
    "text": "21.5 Quickfix List\nIn the previous chapters (Ch3 and Ch19), I have spoken about quickfixes. Quickfix has many uses. Many popular plugins use quickfixes, so it’s good to spend more time to understand them.\nIf you’re new to Vim, quickfix might be a new concept. Back in the old days when you actually have to explicitly compile your code, during the compilation phase you would encounter errors. To display these errors, you need a special window. That’s where quickfix comes in. When you compile your code, Vim displays error messages in the quickfix window so you can fix them later. Many modern languages don’t require an explicit compile anymore, but that doesn’t make quickfix obsolete. Nowadays, people use quickfix for all sorts of things, like displaying a virtual terminal output and storing search results. Let’s focus on the latter one, storing search results.\nIn addition to the compile commands, certain Vim commands rely on quickfix interfaces. One type of command that use quickfixes heavily are the search commands. Both :vimgrep and :grep use quickfixes by default.\nFor example, if you need to search for donut in all Javascript files recursively, you can run:\n:vimgrep /donut/ **/*.js\nThe result for the donut search is stored in the quickfix window. To see these match results’ quickfix window, run:\n:copen\nTo close it, run:\n:cclose\nTo traverse the quickfix list forward and backward, run:\n:cnext\n:cprev\nTo go to the first and the last item in the match, run:\n:cfirst\n:clast\nEarlier I mentioned that there were two quickfix commands: cdo and cfdo. How do they differ? cdo executes command for each item in the quickfix list while cfdo executes command for each file in the quickfix list.\nLet me clarify. Suppose that after running the vimgrep command above, you found: - 1 result in file1.js - 10 results in file2.js\nIf you run :cfdo %s/donut/pancake/g, this will effectively run %s/donut/pancake/g once in file1.js and once in file2.js. It runs as many times as there are files in the match. Since there are two files in the results, Vim executes the substitute command once on file1.js and once more on file2.js, despite the fact that there are 10 matches in the second file. cfdo only cares about how many total files are in the quickfix list.\nIf you run :cdo %s/donut/pancake/g, this will effectively run %s/donut/pancake/g once in file1.js and ten times in file2.js. It runs as many times as there are actual items in the quickfix list. Since there is only one match found in file1.js and 10 matches found in file2.js, it will run a total of 11 times.\nSince you ran %s/donut/pancake/g, it would make sense to use cfdo. It did not make sense to use cdo because it would run %s/donut/pancake/g ten times in file2.js (%s is a file-wide substitution). Running %s once per file is enough. If you used cdo, it would make more sense to pass it with s/donut/pancake/g instead.\nWhen deciding whether to use cfdo or cdo, think of the command scope that you are passing it to. Is this a file-wide command (like :%s or :g) or is this a line-wise command (like :s or :!)?"
  },
  {
    "objectID": "chapters/ch21_multiple_file_operations.md.html#location-list",
    "href": "chapters/ch21_multiple_file_operations.md.html#location-list",
    "title": "21  Multiple File Operations",
    "section": "21.6 Location List",
    "text": "21.6 Location List\nLocation list is similar to quickfix list in a sense that Vim also uses a special window to display messages. The difference between a quickfix list and a location list is that at any time, you may only have one quickfix list, whereas you can have as many location list as windows.\nSuppose that you have two windows opened, one window displaying food.txt and another displaying drinks.txt. From inside food.txt, you run a location-list search command :lvimgrep (the location variant for the :vimgrep command):\n:lvim /bagel/ **/*.md\nVim will create a location list of all the bagel search matches for that food.txt window. You can see the location list with :lopen. Now go to the other window drinks.txt and run:\n:lvimgrep /milk/ **/*.md\nVim will create a separate location list with all the milk search results for that drinks.txt window.\nFor each location-command you run in each window, Vim creates a distinct location list. If you have 10 different windows, you can have up to 10 different location lists. Contrast this with the quickfix list where you can only have one at any time. If you have 10 different windows, you still get only one quickfix list.\nMost of the location list commands are similar to quickfix commands except that they are prefixed with l- instead. For example: :lvimgrep, :lgrep, and :lmake vs :vimgrep, :grep, and :make. To manipulate the location list window, again, the commands look similar to the quickfix commands :lopen, :lclose, :lfirst, :llast, :lnext, and :lprev vs :copen, :cclose, :cfirst, :clast, :cnext, and :cprev.\nThe two location list multi-file commands are also similar to quickfix multi-file commands: :ldo and :lfdo. :ldo executes the location command in each location list while :lfdo executes the location list command for each file in the location list. For more, check out :h location-list."
  },
  {
    "objectID": "chapters/ch21_multiple_file_operations.md.html#running-multiple-file-operations-in-vim",
    "href": "chapters/ch21_multiple_file_operations.md.html#running-multiple-file-operations-in-vim",
    "title": "21  Multiple File Operations",
    "section": "21.7 Running Multiple-File Operations in Vim",
    "text": "21.7 Running Multiple-File Operations in Vim\nKnowing how to do a multiple file operation is a useful skill to have in editing. Whenever you need to change a variable name across multiple files, you want to execute them in one swoop. Vim has eight different ways you can do this.\nPractically speaking, you probably won’t use all eight equally. You will gravitate towards one or two. When you are starting out, pick one (I personally suggest starting with the arg list :argdo) and master it. Once you are comfortable with one, then learn the next one. You will find that learning the second, third, fourth gets easier. Be creative. Use it with different combinations. Keep practicing until you can do this effortlessly and without much thinking. Make it part of your muscle memory.\nWith that being said, you’ve mastered Vim editing. Congratulations!"
  },
  {
    "objectID": "chapters/ch22_vimrc.md.html#how-vim-finds-vimrc",
    "href": "chapters/ch22_vimrc.md.html#how-vim-finds-vimrc",
    "title": "22  Ch22. Vimrc",
    "section": "22.1 How Vim Finds Vimrc",
    "text": "22.1 How Vim Finds Vimrc\nThe conventional wisdom for vimrc is to add a .vimrc dotfile in the home directory ~/.vimrc (it might be different depending on your OS).\nBehind the scene, Vim looks at multiple places for a vimrc file. Here are the places that Vim checks: - $VIMINIT - $HOME/.vimrc - $HOME/.vim/vimrc - $EXINIT - $HOME/.exrc - $VIMRUNTIME/defaults.vim\nWhen you start Vim, it will check the above six locations in that order for a vimrc file. The first found vimrc file will be used and the rest is ignored.\nFirst Vim will look for a $VIMINIT. If there is nothing there, Vim will check for $HOME/.vimrc. If there is nothing there, Vim will check for $HOME/.vim/vimrc. If Vim finds it, it will stop looking and use $HOME/.vim/vimrc.\nThe first location, $VIMINIT, is an environment variable. By default it is undefined. If you want to use ~/dotfiles/testvimrc as your $VIMINIT value, you can create an environment variable containing the path of that vimrc. After you run export VIMINIT='let $MYVIMRC=\"$HOME/dotfiles/testvimrc\" | source $MYVIMRC', Vim will now use ~/dotfiles/testvimrc as your vimrc file.\nThe second location, $HOME/.vimrc, is the conventional path for many Vim users. $HOME in many cases is your home directory (~). If you have a ~/.vimrc file, Vim will use this as your vimrc file.\nThe third, $HOME/.vim/vimrc, is located inside the ~/.vim directory. You might have the ~/.vim directory already for your plugins, custom scripts, or View files. Note that there is no dot in vimrc file name ($HOME/.vim/.vimrc won’t work, but $HOME/.vim/vimrc will).\nThe fourth, $EXINIT works similar to $VIMINIT.\nThe fifth, $HOME/.exrc works similar to $HOME/.vimrc.\nThe sixth, $VIMRUNTIME/defaults.vim is the default vimrc that comes with your Vim build. In my case, I have Vim 8.2 installed using Homebrew, so my path is (/usr/local/share/vim/vim82). If Vim does not find any of the previous six vimrc files, it will use this file.\nFor the remaining of this chapter, I am assuming that the vimrc uses the ~/.vimrc path."
  },
  {
    "objectID": "chapters/ch22_vimrc.md.html#what-to-put-in-my-vimrc",
    "href": "chapters/ch22_vimrc.md.html#what-to-put-in-my-vimrc",
    "title": "22  Ch22. Vimrc",
    "section": "22.2 What to Put in My Vimrc?",
    "text": "22.2 What to Put in My Vimrc?\nA question I asked when I started was, What should I put in my vimrc?\nThe answer is, anything you want. The temptation to copy-paste other people’s vimrc is real, but you should resist it. If you insist to use someone else’s vimrc, make sure that you know what it does, why and how s/he uses it, and most importantly, if it is relevant to you. Just because someone uses it doesn’t mean you’ll use it too."
  },
  {
    "objectID": "chapters/ch22_vimrc.md.html#basic-vimrc-content",
    "href": "chapters/ch22_vimrc.md.html#basic-vimrc-content",
    "title": "22  Ch22. Vimrc",
    "section": "22.3 Basic Vimrc Content",
    "text": "22.3 Basic Vimrc Content\nIn the nutshell, a vimrc is a collection of: - Plugins - Settings - Custom Functions - Custom Commands - Mappings\nThere are other things not mentioned above, but in general, this covers most use cases.\n\n22.3.1 Plugins\nIn the previous chapters, I have mentioned different plugins, like fzf.vim, vim-mundo, and vim-fugitive.\nTen years ago, managing plugins was a nightmare. However, with the rise of modern plugin managers, installing plugins can now be done in seconds. I am currently using vim-plug as my plugin manager, so I will use it in this section. The concept should be similar with other popular plugin managers. I would strongly recommend you to check out different ones, such as: - vundle.vim - vim-pathogen - dein.vim\nThere are more plugin managers than the ones listed above, feel free to look around. To install vim-plug, if you have a Unix machine, run:\ncurl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\nTo add new plugins, drop your plugin names (Plug 'github-username/repository-name') between the call plug#begin() and the call plug#end() lines. So if you want to install emmet-vim and nerdtree, put the following snippet down in your vimrc:\ncall plug#begin('~/.vim/plugged')\n  Plug 'mattn/emmet-vim'\n  Plug 'preservim/nerdtree'\ncall plug#end()\nSave the changes, source it (:source %), and run :PlugInstall to install them.\nIn the future if you need to remove unused plugins, you just need to remove the plugin names from the call block, save and source, and run the :PlugClean command to remove it from your machine.\nVim 8 has its own built-in package managers. You can check out :h packages for more information. In the next chapter, I will show you how to use it.\n\n\n22.3.2 Settings\nIt is common to see a lot of set options in any vimrc. If you run the set command from the command-line mode, it is not permanent. You will lose it when you close Vim. For example, instead of running :set relativenumber number from the Command-line mode each time you run Vim, you could just put these inside vimrc:\nset relativenumber number\nSome settings require you to pass it a value, like set tabstop=2. Check out the help page for each setting to learn what kind of values it accepts.\nYou can also use a let instead of set (make sure to prepend it with &). With let, you can use an expression as a value. For example, to set the 'dictionary' option to a path only if the path exists:\nlet s:english_dict = \"/usr/share/dict/words\"\n\nif filereadable(s:english_dict)\n  let &dictionary=s:english_dict\nendif\nYou will learn about Vimscript assignments and conditionals in later chapters.\nFor a list of all possible options in Vim, check out :h E355.\n\n\n22.3.3 Custom Functions\nVimrc is a good place for custom functions. You will learn how to write your own Vimscript functions in a later chapter.\n\n\n22.3.4 Custom Commands\nYou can create a custom Command-line command with command.\nTo create a basic command GimmeDate to display today’s date:\n:command! GimmeDate echo call(\"strftime\", [\"%F\"])\nWhen you run :GimmeDate, Vim will display a date like 2021-01-1.\nTo create a basic command with an input, you can use <args>. If you want to pass to GimmeDate a specific time/date format:\n:command! GimmeDate echo call(\"strftime\", [<args>])\n\n:GimmeDate \"%F\"\n\" 2020-01-01\n\n:GimmeDate \"%H:%M\"\n\" 11:30\nIf you want to restrict the number of arguments, you can pass it -nargs flag. Use -nargs=0 to pass no argument, -nargs=1 to pass one argument, -nargs=+ to pass at least one argument, -nargs=* to pass any number of arguments, and -nargs=? to pass 0 or one arguments. If you want to pass nth argument, use -nargs=n (where n is any integer).\n<args> has two variants: <f-args> and <q-args>. The former is used to pass arguments to Vimscript functions. The latter is used to automatically convert user input to strings.\nUsing args:\n:command! -nargs=1 Hello echo \"Hello \" . <args>\n:Hello \"Iggy\"\n\" returns 'Hello Iggy'\n\n:Hello Iggy\n\" Undefined variable error\nUsing q-args:\n:command! -nargs=1 Hello echo \"Hello \" . <q-args>\n:Hello Iggy\n\" returns 'Hello Iggy'\nUsing f-args:\n:function! PrintHello(person1, person2)\n:  echo \"Hello \" . a:person1 . \" and \" . a:person2\n:endfunction\n\n:command! -nargs=* Hello call PrintHello(<f-args>)\n\n:Hello Iggy1 Iggy2\n\" returns \"Hello Iggy1 and Iggy2\"\nThe functions above will make a lot more sense once you get to the Vimscript functions chapter.\nTo learn more about command and args, check out :h command and :args.\n\n\n22.3.5 Maps\nIf you find yourself repeatedly performing the same complex task, it is a good indicator that you should create a mapping for that task.\nFor example, I have these two mappings in my vimrc:\nnnoremap <silent> <C-f> :GFiles<CR>\n\nnnoremap <Leader>tn :call ToggleNumber()<CR>\nOn the first one, I map Ctrl-F to fzf.vim plugin’s :Gfiles command (quickly search for Git files). On the second one, I map <Leader>tn to call a custom function ToggleNumber (toggles norelativenumber and relativenumber options). The Ctrl-F mapping overwrites Vim’s native page scroll. Your mapping will overwrite Vim controls if they collide. Because I almost never used that feature, I decided that it is safe to overwrite it.\nBy the way, what is this leader key in <Leader>tn?\nVim has a leader key to help with mappings. For example, I mapped <Leader>tn to run the ToggleNumber() function. Without the leader key, I would be using tn, but Vim already has t (the till search navigation). With the leader key, I can now press the key assigned as a leader, then tn without interfering with existing commands. The leader key is a key that you can setup to start your mapping combo. By default Vim uses the backslash as the leader key (so <Leader>tn becomes backslash-t-n).\nI personally like to use <Space> as the leader key instead of the backslash default. To change your leader key, add this in your vimrc:\nlet mapleader = \"\\<space>\"\nThe nnoremap command used above can be broken down into three parts: - n represents the normal mode. - nore means non-recursive. - map is the map command.\nAt minimum, you could have used nmap instead of nnoremap (nmap <silent> <C-f> :Gfiles<CR>). However, it is a good practice to use the non-recursive variant to avoid potential infinite loop.\nHere’s what could happen if you don’t map non-recursively. Suppose you want to add a mapping to B to add a semi-colon at the end of the line, then go back one WORD (recall that B n Vim is a normal-mode navigation key to go backward one WORD).\nnmap B A;<esc>B\nWhen you press B… oh no! Vim adds ; uncontrollably (interrupt it with Ctrl-C). Why did that happen? Because in the mapping A;<esc>B, the B does not refer to Vim’s native B function (go back one WORD), but it refers to the mapped function. What you have is actually this:\nA;<esc>A;<esc>A;<esc>A;esc>...\nTo solve this problem, you need to add a non-recursive map:\nnnoremap B A;<esc>B\nNow try calling B again. This time it successfully adds a ; at the end of the line and go back one WORD. The B in this mapping represents Vim’s original B functionality.\nVim has different maps for different modes. If you want to create a map for insert mode to exit insert mode when you press jk:\ninoremap jk <esc>\nThe other map modes are: map (Normal, Visual, Select, and Operator-pending), vmap (Visual and Select), smap (Select), xmap (Visual), omap (Operator-pending), map! (Insert and Command-line), lmap (Insert, Command-line, Lang-arg), cmap (Command-line), and tmap (terminal-job). I won’t cover them in detail. To learn more, check out :h map.txt.\nCreate a map that’s most intuitive, consistent, and easy-to-remember."
  },
  {
    "objectID": "chapters/ch22_vimrc.md.html#organizing-vimrc",
    "href": "chapters/ch22_vimrc.md.html#organizing-vimrc",
    "title": "22  Ch22. Vimrc",
    "section": "22.4 Organizing Vimrc",
    "text": "22.4 Organizing Vimrc\nOver time, your vimrc will grow large and become convoluted. There are two ways to keep your vimrc to look clean: - Split your vimrc into several files. - Fold your vimrc file.\n\n22.4.1 Splitting Your Vimrc\nYou can split your vimrc to multiple files using Vim’s source command. This command reads command-line commands from the given file argument.\nLet’s create a file inside the ~/.vim directory and name it /settings (~/.vim/settings). The name itself is arbitrary and you can name it whatever you like.\nYou are going to split it into four components: - Third-party plugins (~/.vim/settings/plugins.vim). - General settings (~/.vim/settings/configs.vim). - Custom functions (~/.vim/settings/functions.vim). - Key mappings (~/.vim/settings/mappings.vim) .\nInside ~/.vimrc:\nsource $HOME/.vim/settings/plugins.vim\nsource $HOME/.vim/settings/configs.vim\nsource $HOME/.vim/settings/functions.vim\nsource $HOME/.vim/settings/mappings.vim\nYou can edit these files by putting your cursor under the path and press gf.\nInside ~/.vim/settings/plugins.vim:\ncall plug#begin('~/.vim/plugged')\n  Plug 'mattn/emmet-vim'\n  Plug 'preservim/nerdtree'\ncall plug#end()\nInside ~/.vim/settings/configs.vim:\nset nocompatible\nset relativenumber\nset number\nInside ~/.vim/settings/functions.vim:\nfunction! ToggleNumber()\n  if(&relativenumber == 1)\n    set norelativenumber\n  else\n    set relativenumber\n  endif\nendfunc\nInside ~/.vim/settings/mappings.vim:\ninoremap jk <esc>\nnnoremap <silent> <C-f> :GFiles<CR>\nnnoremap <Leader>tn :call ToggleNumber()<CR>\nYour vimrc should works as usual, but now it is only four lines long!\nWith this setup, you easily know where to go. If you need to add more mappings, add them to the /mappings.vim file. In the future, you can always add more directories as your vimrc grows. For example, if you need to create a setting for your colorschemes, you can add a ~/.vim/settings/themes.vim.\n\n\n22.4.2 Keeping One Vimrc File\nIf you prefer to keep one vimrc file to keep it portable, you can use the marker folds to keep it organized. Add this at the top of your vimrc:\n\" setup folds {{{\naugroup filetype_vim\n  autocmd!\n  autocmd FileType vim setlocal foldmethod=marker\naugroup END\n\" }}}\nVim can detect what kind of filetype the current buffer has (:set filetype?). If it is a vim filetype, you can use a marker fold method. Recall that a marker fold uses {{{ and }}} to indicate the starting and ending folds.\nAdd {{{ and }}} folds to the rest of your vimrc (don’t forget to comment them with \"):\n\" setup folds {{{\naugroup filetype_vim\n  autocmd!\n  autocmd FileType vim setlocal foldmethod=marker\naugroup END\n\" }}}\n\n\" plugins {{{\ncall plug#begin('~/.vim/plugged')\n  Plug 'mattn/emmet-vim'\n  Plug 'preservim/nerdtree'\ncall plug#end()\n\" }}}\n\n\" configs {{{\nset nocompatible\nset relativenumber\nset number\n\" }}}\n\n\" functions {{{\nfunction! ToggleNumber()\n  if(&relativenumber == 1)\n    set norelativenumber\n  else\n    set relativenumber\n  endif\nendfunc\n\" }}}\n\n\" mappings {{{\ninoremap jk <esc>\nnnoremap <silent> <C-f> :GFiles<CR>\nnnoremap <Leader>tn :call ToggleNumber()<CR>\n\" }}}\nYour vimrc should look like this:\n+-- 6 lines: setup folds -----\n\n+-- 6 lines: plugins ---------\n\n+-- 5 lines: configs ---------\n\n+-- 9 lines: functions -------\n\n+-- 5 lines: mappings --------"
  },
  {
    "objectID": "chapters/ch22_vimrc.md.html#running-vim-with-or-without-vimrc-and-plugins",
    "href": "chapters/ch22_vimrc.md.html#running-vim-with-or-without-vimrc-and-plugins",
    "title": "22  Ch22. Vimrc",
    "section": "22.5 Running Vim With or Without Vimrc and Plugins",
    "text": "22.5 Running Vim With or Without Vimrc and Plugins\nIf you need to run Vim without both vimrc and plugins, run:\nvim -u NONE\nIf you need to launch Vim without vimrc but with plugins, run:\nvim -u NORC\nIf you need to run Vim with vimrc but without plugins, run:\nvim --noplugin\nIf you need to run Vim with a different vimrc, say ~/.vimrc-backup, run:\nvim -u ~/.vimrc-backup\nIf you need to run Vim with only defaults.vim and without plugins, which is helpful to fix broken vimrc, run:\nvim --clean"
  },
  {
    "objectID": "chapters/ch22_vimrc.md.html#configure-vimrc-the-smart-way",
    "href": "chapters/ch22_vimrc.md.html#configure-vimrc-the-smart-way",
    "title": "22  Ch22. Vimrc",
    "section": "22.6 Configure Vimrc the Smart Way",
    "text": "22.6 Configure Vimrc the Smart Way\nVimrc is an important component of Vim customization. A good way to start building your vimrc is by reading other people’s vimrcs and gradually build it over time. The best vimrc is not the one that developer X uses, but the one that is tailored exactly to fit your thinking framework and editing style."
  },
  {
    "objectID": "chapters/ch23_vim_packages.md.html#pack-directory",
    "href": "chapters/ch23_vim_packages.md.html#pack-directory",
    "title": "23  Ch23. Vim Packages",
    "section": "23.1 Pack Directory",
    "text": "23.1 Pack Directory\nCheck if you have a ~/.vim/ directory in the root path. If you don’t, create one. Inside it, create a directory called pack (~/.vim/pack/). Vim automatically knows to search inside this directory for packages."
  },
  {
    "objectID": "chapters/ch23_vim_packages.md.html#two-types-of-loading",
    "href": "chapters/ch23_vim_packages.md.html#two-types-of-loading",
    "title": "23  Ch23. Vim Packages",
    "section": "23.2 Two Types of Loading",
    "text": "23.2 Two Types of Loading\nVim package has two loading mechanisms: automatic and manual loading.\n\n23.2.1 Automatic Loading\nTo load plugins automatically when Vim starts, you need to put them in the start/ directory. The path looks like this:\n~/.vim/pack/*/start/\nNow you may ask, What is the * between pack/ and start/? * is an arbitrary name and can be anything you want. let’s name it packdemo/:\n~/.vim/pack/packdemo/start/\nKeep in mind that if you skip it and do something like this instead:\n~/.vim/pack/start/\nThe package system won’t work. It is imperative to put a name between pack/ and start/.\nFor this demo, let’s try to install the NERDTree plugin. Go all the way to the start/ directory (cd ~/.vim/pack/packdemo/start/) and clone the NERDTree repository:\ngit clone https://github.com/preservim/nerdtree.git\nThat’s it! You are all set. The next time you start Vim, you can immediately execute NERDTree commands like :NERDTreeToggle.\nYou can clone as many plugin repositories as you want inside the ~/.vim/pack/*/start/ path. Vim will automatically load each one. If you remove the cloned repository (rm -rf nerdtree/), that plugin will not be available anymore.\n\n\n23.2.2 Manual Loading\nTo load plugins manually when Vim starts, you need to put them in the opt/ directory. Similar to automatic loading, the path looks like this:\n~/.vim/pack/*/opt/\nLet’s use the same packdemo/ directory from earlier:\n~/.vim/pack/packdemo/opt/\nThis time, let’s install the killersheep game (this requires Vim 8.2). Go to the opt/ directory (cd ~/.vim/pack/packdemo/opt/) and clone the repository:\ngit clone https://github.com/vim/killersheep.git\nStart Vim. The command to execute the game is :KillKillKill. Try running it. Vim will complain that it is not a valid editor command. You need to manually load the plugin first. Let’s do that:\n:packadd killersheep\nNow try running the command again :KillKillKill. The command should work now.\nYou may wonder, Why would I ever want to manually load packages? Isn’t it better to automatically load everything at the start?\nGreat question. Sometimes there are plugins that you won’t use all the time, like that KillerSheep game. You probably don’t need to load 10 different games and slow down Vim startup time. However, once in a while, when you are bored, you might want to play a few games. Use manual loading for nonessential plugins.\nYou can also use this to conditionally add plugins. Maybe you use both Neovim and Vim and there are plugins optimized for Neovim. You can add something like this in your vimrc:\nif has('nvim')\n  packadd! neovim-only-plugin\nelse\n  packadd! generic-vim-plugin\nendif"
  },
  {
    "objectID": "chapters/ch23_vim_packages.md.html#organizing-packages",
    "href": "chapters/ch23_vim_packages.md.html#organizing-packages",
    "title": "23  Ch23. Vim Packages",
    "section": "23.3 Organizing Packages",
    "text": "23.3 Organizing Packages\nRecall that the requirement to use Vim’s package system is to have either:\n~/.vim/pack/*/start/\nOr:\n~/.vim/pack/*/opt/\nThe fact that * can be any name can be used to organize your packages. Suppose you want to group your plugins based on categories (colors, syntax, and games):\n~/.vim/pack/colors/\n~/.vim/pack/syntax/\n~/.vim/pack/games/\nYou can still use start/ and opt/ inside each of the directories.\n~/.vim/pack/colors/start/\n~/.vim/pack/colors/opt/\n\n~/.vim/pack/syntax/start/\n~/.vim/pack/syntax/opt/\n\n~/.vim/pack/games/start/\n~/.vim/pack/games/opt/"
  },
  {
    "objectID": "chapters/ch23_vim_packages.md.html#adding-packages-the-smart-way",
    "href": "chapters/ch23_vim_packages.md.html#adding-packages-the-smart-way",
    "title": "23  Ch23. Vim Packages",
    "section": "23.4 Adding Packages the Smart Way",
    "text": "23.4 Adding Packages the Smart Way\nYou may wonder if Vim package will make popular plugin managers like vim-pathogen, vundle.vim, dein.vim, and vim-plug obsolete.\nThe answer is, as always, it depends.\nI still use vim-plug because it makes it easy to add, remove or update plugins. If you use many plugins, it may be more convenient to use plugin managers because it is easy to update many simultaneously. Some plugin managers also offer asynchronous functionalities.\nIf you are a minimalist, try out Vim packages. If you a heavy plugin user, you may want to consider using a plugin manager."
  },
  {
    "objectID": "chapters/ch24_vim_runtime.md.html#runtime-path",
    "href": "chapters/ch24_vim_runtime.md.html#runtime-path",
    "title": "24  Ch24. Vim Runtime",
    "section": "24.1 Runtime Path",
    "text": "24.1 Runtime Path\nIn a Unix machine, one of your Vim runtime paths is $HOME/.vim/ (if you have a different OS like Windows, your path might be different). To see what the runtime paths for different OS are, check out :h 'runtimepath'. In this chapter, I will use ~/.vim/ as the default runtime path."
  },
  {
    "objectID": "chapters/ch24_vim_runtime.md.html#plugin-scripts",
    "href": "chapters/ch24_vim_runtime.md.html#plugin-scripts",
    "title": "24  Ch24. Vim Runtime",
    "section": "24.2 Plugin Scripts",
    "text": "24.2 Plugin Scripts\nVim has a plugin runtime path that executes any scripts in this directory once each time Vim starts. Do not confuse the name plugin with Vim external plugins (like NERDTree, fzf.vim, etc).\nGo to ~/.vim/ directory and create a plugin/ directory. Create two files: donut.vim and chocolate.vim.\nInside ~/.vim/plugin/donut.vim:\necho \"donut!\"\nInside ~/.vim/plugin/chocolate.vim:\necho \"chocolate!\"\nNow close Vim. The next time you start Vim, you will see both \"donut!\" and \"chocolate!\" echoed. The plugin runtime path can be used for initializations scripts."
  },
  {
    "objectID": "chapters/ch24_vim_runtime.md.html#filetype-detection",
    "href": "chapters/ch24_vim_runtime.md.html#filetype-detection",
    "title": "24  Ch24. Vim Runtime",
    "section": "24.3 Filetype Detection",
    "text": "24.3 Filetype Detection\nBefore you start, to ensure that these detections work, make sure that your vimrc contains at least the following line:\nfiletype plugin indent on\nCheck out :h filetype-overview for more context. Essentially this turns on Vim’s filetype detection.\nWhen you open a new file, Vim usually knows what kind of file it is. If you have a file hello.rb, running :set filetype? returns the correct response filetype=ruby.\nVim knows how to detect common file types (Ruby, Python, Javascript, etc). But what if you have a custom file? You need to teach Vim to detect it and assign it with the correct file type.\nThere are two methods of detection: using file name and file content.\n\n24.3.1 File Name Detection\nFile name detection detects a file type using the name of that file. When you open the hello.rb file, Vim knows it is a Ruby file from the .rb extension.\nThere are two ways you can do file name detection: using ftdetect/ runtime directory and using filetype.vim runtime file. Let’s explore both.\n\n24.3.1.1 ftdetect/\nLet’s create an obscure (yet tasty) file, hello.chocodonut. When you open it and you run :set filetype?, since it is not a common file name extension Vim doesn’t know what to make of it. It returns filetype=.\nYou need to instruct Vim to set all files ending with .chocodonut as a chocodonut file type. Create a directory named ftdetect/ in the runtime root (~/.vim/). Inside, create a file and name it chocodonut.vim (~/.vim/ftdetect/chocodonut.vim). Inside this file, add:\nautocmd BufNewFile,BufRead *.chocodonut set filetype=chocodonut\nBufNewFile and BufRead are triggered whenever you create a new buffer and open a new buffer. *.chocodonut means that this event will only be triggered if the opened buffer has a .chocodonut filename extension. Finally, set filetype=chocodonut command sets the file type to be a chocodonut type.\nRestart Vim. Now open hello.chocodonut file and run :set filetype?. It returns filetype=chocodonut.\nScrumptious! You can put as many files as you want inside ftdetect/. In the future, you can maybe add ftdetect/strawberrydonut.vim, ftdetect/plaindonut.vim, etc., if you ever decide to expand your donut file types.\nThere are actually two ways to set a file type in Vim. One is what you just used set filetype=chocodonut. The other way is to run setfiletype chocodonut. The former command set filetype=chocodonut will always set the file type to chocodonut type, while the latter command setfiletype chocodonut will only set the file type if no file type was set yet.\n\n\n24.3.1.2 Filetype File\nThe second file detection method requires you to create a filetype.vim in the root directory (~/.vim/filetype.vim). Add this inside:\nautocmd BufNewFile,BufRead *.plaindonut set filetype=plaindonut\nCreate a hello.plaindonut file. When you open it and run :set filetype?, Vim displays the correct custom file type filetype=plaindonut.\nHoly pastry, it works! By the way, if you play around with filetype.vim, you may notice that this file is being run multiple times when you open hello.plaindonut. To prevent this, you can add a guard so the main script is run only once. Update the filetype.vim:\nif exists(\"did_load_filetypes\")\n  finish\nendif\n\naugroup donutfiletypedetection\n  autocmd! BufRead,BufNewFile *.plaindonut setfiletype plaindonut\naugroup END\nfinish is a Vim command to stop running the rest of the script. The \"did_load_filetypes\" expression is not a built-in Vim function. It is actually a global variable from inside $VIMRUNTIME/filetype.vim. If you’re curious, run :e $VIMRUNTIME/filetype.vim. You will find these lines inside:\nif exists(\"did_load_filetypes\")\n  finish\nendif\n\nlet did_load_filetypes = 1\nWhen Vim calls this file, it defines did_load_filetypes variable and sets is to 1. 1 is truthy in Vim. You should read the rest of the filetype.vim too. See if you can understand what it does when Vim calls it.\n\n\n\n24.3.2 File Type Script\nLet’s learn how to detect and assign a file type based on the file content.\nSuppose you have a collection of files without an agreeable extension. The only thing these files have in common is that they all start with the word donutify on the first line. You want to assign these files to a donut file type. Create new files named sugardonut, glazeddonut, and frieddonut (without extension). Inside each file, add this line:\ndonutify\nWhen you run the :set filetype? from inside sugardonut, Vim doesn’t know what file type to assign this file with. It returns filetype=.\nIn the runtime root path, add a scripts.vim file (~/.vim/scripts.vim). Inside it, add these:\nif did_filetype()\n  finish\nendif\n\nif getline(1) =~ '^\\\\<donutify\\\\>'\n  setfiletype donut\nendif\nThe function getline(1) returns the text on the first line. It checks if the first line starts with the word donutify. The function did_filetype() is a Vim built-in function. It will return true when a file type related event is triggered at least once. It is used as a guard to stop re-running file type event.\nOpen the sugardonut file and run :set filetype?, Vim now returns filetype=donut. If you open another donut files (glazeddonut and frieddonut), Vim also identifies their file types as donut types.\nNote that scripts.vim is only run when Vim opens a file with an unknown file type. If Vim opens a file with a known file type, scripts.vim won’t run."
  },
  {
    "objectID": "chapters/ch24_vim_runtime.md.html#file-type-plugin",
    "href": "chapters/ch24_vim_runtime.md.html#file-type-plugin",
    "title": "24  Ch24. Vim Runtime",
    "section": "24.4 File Type Plugin",
    "text": "24.4 File Type Plugin\nWhat if you want Vim to run chocodonut-specific scripts when you open a chocodonut file and to not run those scripts when opening plaindonut file?\nYou can do this with file type plugin runtime path (~/.vim/ftplugin/). Vim looks inside this directory for a file with the same name as the file type you just opened. Create a chocodonut.vim (~/.vim/ftplugin/chocodonut.vim):\necho \"Calling from chocodonut ftplugin\"\nCreate another ftplugin file, plaindonut.vim (~/.vim/ftplugin/plaindonut.vim):\necho \"Calling from plaindonut ftplugin\"\nNow each time you open a chocodonut file type, Vim runs the scripts from ~/.vim/ftplugin/chocodonut.vim. Each time you open a plaindonut file type, Vim runs the scripts from ~/.vim/ftplugin/plaindonut.vim.\nOne warning: these files are run each time a buffer file type is set (set filetype=chocodonut for example). If you open 3 different chocodonut files, the scripts will be run a total of three times."
  },
  {
    "objectID": "chapters/ch24_vim_runtime.md.html#indent-files",
    "href": "chapters/ch24_vim_runtime.md.html#indent-files",
    "title": "24  Ch24. Vim Runtime",
    "section": "24.5 Indent Files",
    "text": "24.5 Indent Files\nVim has an indent runtime path that works similar to ftplugin, where Vim looks for a file named the same as the opened file type. The purpose of these indent runtime paths is to store indent-related codes. If you have the file ~/.vim/indent/chocodonut.vim, it will be executed only when you open a chocodonut file type. You can store indent-related codes for chocodonut files here."
  },
  {
    "objectID": "chapters/ch24_vim_runtime.md.html#colors",
    "href": "chapters/ch24_vim_runtime.md.html#colors",
    "title": "24  Ch24. Vim Runtime",
    "section": "24.6 Colors",
    "text": "24.6 Colors\nVim has a colors runtime path (~/.vim/colors/) to store color schemes. Any file that goes inside the directory will be displayed in the :color command-line command.\nIf you have a ~/.vim/colors/beautifulprettycolors.vim file, when you run :color and press Tab, you will see beautifulprettycolors as one of the color options. If you prefer to add your own color scheme, this is the place to go.\nIf you want to check out the color schemes other people made, a good place to visit is vimcolors."
  },
  {
    "objectID": "chapters/ch24_vim_runtime.md.html#syntax-highlighting",
    "href": "chapters/ch24_vim_runtime.md.html#syntax-highlighting",
    "title": "24  Ch24. Vim Runtime",
    "section": "24.7 Syntax Highlighting",
    "text": "24.7 Syntax Highlighting\nVim has a syntax runtime path (~/.vim/syntax/) to define syntax highlighting.\nSuppose you have a hello.chocodonut file, inside it you have the following expressions:\n(donut \"tasty\")\n(donut \"savory\")\nAlthough Vim now knows the correct file type, all texts have the same color. Let’s add a syntax highlighting rule to highlight the donut keyword. Create a new chocodonut syntax file, ~/.vim/syntax/chocodonut.vim. Inside it add:\nsyntax keyword donutKeyword donut\n\nhighlight link donutKeyword Keyword\nNow reopen hello.chocodonut file. The donut keywords are now highlighted.\nThis chapter won’t go over syntax highlighting in depth. It is a vast topic. If you are curious, check out :h syntax.txt.\nThe vim-polyglot plugin is a great plugin that provides highlights for many popular programming languages."
  },
  {
    "objectID": "chapters/ch24_vim_runtime.md.html#documentation",
    "href": "chapters/ch24_vim_runtime.md.html#documentation",
    "title": "24  Ch24. Vim Runtime",
    "section": "24.8 Documentation",
    "text": "24.8 Documentation\nIf you create a plugin, you will have to create your own documentation. You use the doc runtime path for that.\nLet’s create a basic documentation for chocodonut and plaindonut keywords. Create a donut.txt (~/.vim/doc/donut.txt). Inside, add these texts:\n*chocodonut* Delicious chocolate donut\n\n*plaindonut* No choco goodness but still delicious nonetheless\nIf you try to search for chocodonut and plaindonut (:h chocodonut and :h plaindonut), you won’t find anything.\nFirst, you need to run :helptags to generate new help entries. Run :helptags ~/.vim/doc/\nNow if you run :h chocodonut and :h plaindonut, you will find these new help entries. Notice that the file is now read-only and has a help file type."
  },
  {
    "objectID": "chapters/ch24_vim_runtime.md.html#lazy-loading-scripts",
    "href": "chapters/ch24_vim_runtime.md.html#lazy-loading-scripts",
    "title": "24  Ch24. Vim Runtime",
    "section": "24.9 Lazy Loading Scripts",
    "text": "24.9 Lazy Loading Scripts\nAll of the runtime paths that you learned in this chapter were run automatically. If you want to manually load a script, use the autoload runtime path.\nCreate an autoload directory (~/.vim/autoload/). Inside that directory, create a new file and name it tasty.vim (~/.vim/autoload/tasty.vim). Inside it:\necho \"tasty.vim global\"\n\nfunction tasty#donut()\n  echo \"tasty#donut\"\nendfunction\nNote that the function name is tasty#donut, not donut(). The pound sign (#) is required when using the autoload feature. The function naming convention for the autoload feature is:\nfunction fileName#functionName()\n  ...\nendfunction\nIn this case, the file name is tasty.vim and the function name is (technically) donut.\nTo invoke a function, you need the call command. Let’s call that function with :call tasty#donut().\nThe first time you call the function, you should see both echo messages (tasty.vim global and tasty#donut). The subsequent calls totasty#donut function will only display testy#donut echo.\nWhen you open a file in Vim, unlike the previous runtime paths, autoload scripts aren’t loaded automatically. Only when you explicitly call tasty#donut(), Vim looks for the tasty.vim file and loads everything inside it, including the tasty#donut() function. Autoload is the perfect mechanism for functions that use extensive resources but you don’t use often.\nYou can add as many nested directories with autoload as you want. If you have the runtime path ~/.vim/autoload/one/two/three/tasty.vim, you can call the function with :call one#two#three#tasty#donut()."
  },
  {
    "objectID": "chapters/ch24_vim_runtime.md.html#after-scripts",
    "href": "chapters/ch24_vim_runtime.md.html#after-scripts",
    "title": "24  Ch24. Vim Runtime",
    "section": "24.10 After Scripts",
    "text": "24.10 After Scripts\nVim has an after runtime path (~/.vim/after/) that mirrors the structure of ~/.vim/. Anything in this path is executed last, so developers usually use these paths for script overrides.\nFor example, if you want to overwrite the scripts from plugin/chocolate.vim, you can create ~/.vim/after/plugin/chocolate.vim to put the override scripts. Vim will run the ~/.vim/after/plugin/chocolate.vim after ~/.vim/plugin/chocolate.vim."
  },
  {
    "objectID": "chapters/ch24_vim_runtime.md.html#vimruntime",
    "href": "chapters/ch24_vim_runtime.md.html#vimruntime",
    "title": "24  Ch24. Vim Runtime",
    "section": "24.11 $VIMRUNTIME",
    "text": "24.11 $VIMRUNTIME\nVim has an environment variable $VIMRUNTIME for default scripts and support files. You can check it out by running :e $VIMRUNTIME.\nThe structure should look familiar. It contains many runtime paths you learned in this chapter.\nRecall in Chapter 21, you learned that when you open Vim, it looks for a vimrc files in seven different locations. I said that the last location Vim checks is $VIMRUNTIME/defaults.vim. If Vim fails to find any user vimrc files, Vim uses a defaults.vim as vimrc.\nHave you ever tried running Vim without syntax plugin like vim-polyglot and yet your file is still syntatically highlighted? That is because when Vim fails to find a syntax file from the runtime path, Vim looks for a syntax file from $VIMRUNTIME syntax directory.\nTo learn more, check out :h $VIMRUNTIME."
  },
  {
    "objectID": "chapters/ch24_vim_runtime.md.html#runtimepath-option",
    "href": "chapters/ch24_vim_runtime.md.html#runtimepath-option",
    "title": "24  Ch24. Vim Runtime",
    "section": "24.12 Runtimepath Option",
    "text": "24.12 Runtimepath Option\nTo check your runtimepath, run :set runtimepath?\nIf you use Vim-Plug or popular external plugin managers, it should display a list of directories. For example, mine shows:\nruntimepath=~/.vim,~/.vim/plugged/vim-signify,~/.vim/plugged/base16-vim,~/.vim/plugged/fzf.vim,~/.vim/plugged/fzf,~/.vim/plugged/vim-gutentags,~/.vim/plugged/tcomment_vim,~/.vim/plugged/emmet-vim,~/.vim/plugged/vim-fugitive,~/.vim/plugged/vim-sensible,~/.vim/plugged/lightline.vim, ...\nOne of the things plugin managers does is adding each plugin into the runtime path. Each runtime path can have its own directory structure similar to ~/.vim/.\nIf you have a directory ~/box/of/donuts/ and you want to add that directory to your runtime path, you can add this to your vimrc:\nset rtp+=$HOME/box/of/donuts/\nIf inside ~/box/of/donuts/, you have a plugin directory (~/box/of/donuts/plugin/hello.vim) and a ftplugin (~/box/of/donuts/ftplugin/chocodonut.vim), Vim will run all scripts from plugin/hello.vim when you open Vim. Vim will also run ftplugin/chocodonut.vim when you open a chocodonut file.\nTry this yourself: create an arbitrary path and add it to your runtimepath. Add some of the runtime paths you learned from this chapter. Make sure they work as expected."
  },
  {
    "objectID": "chapters/ch24_vim_runtime.md.html#learn-runtime-the-smart-way",
    "href": "chapters/ch24_vim_runtime.md.html#learn-runtime-the-smart-way",
    "title": "24  Ch24. Vim Runtime",
    "section": "24.13 Learn Runtime the Smart Way",
    "text": "24.13 Learn Runtime the Smart Way\nTake your time reading it and play around with these runtime paths. To see how runtime paths are being used in the wild, go to the repository of one of your favorite Vim plugins and study its directory structure. You should be able to understand most of them now. Try to follow along and discern the big picture. Now that you understand Vim directory structure, you’re ready to learn Vimscript."
  },
  {
    "objectID": "chapters/ch25_vimscript_basic_data_types.md.html#data-types",
    "href": "chapters/ch25_vimscript_basic_data_types.md.html#data-types",
    "title": "25  Ch25. Vimscript Basic Data Types",
    "section": "25.1 Data Types",
    "text": "25.1 Data Types\nVim has 10 different data types: - Number - Float - String - List - Dictionary - Special - Funcref - Job - Channel - Blob\nI will cover the first six data types here. In Ch. 27, you will learn about Funcref. For more about Vim data types, check out :h variables."
  },
  {
    "objectID": "chapters/ch25_vimscript_basic_data_types.md.html#following-along-with-ex-mode",
    "href": "chapters/ch25_vimscript_basic_data_types.md.html#following-along-with-ex-mode",
    "title": "25  Ch25. Vimscript Basic Data Types",
    "section": "25.2 Following Along With Ex Mode",
    "text": "25.2 Following Along With Ex Mode\nVim technically does not have a built-in REPL, but it has a mode, Ex mode, that can be used like one. You can go to the Ex mode with Q or gQ. The Ex mode is like an extended command-line mode (it’s like typing command-line mode commands non-stop). To quit the Ex mode, type :visual.\nYou can use either :echo or :echom on this chapter and the subsequent Vimscript chapters to code along. They are like console.log in JS or print in Python. The :echo command prints the evaluated expression you give. The :echom command does the same, but in addition, it stores the result in the message history.\n:echom \"hello echo message\"\nYou can view the message history with:\n:messages\nTo clear your message history, run:\n:messages clear"
  },
  {
    "objectID": "chapters/ch25_vimscript_basic_data_types.md.html#number",
    "href": "chapters/ch25_vimscript_basic_data_types.md.html#number",
    "title": "25  Ch25. Vimscript Basic Data Types",
    "section": "25.3 Number",
    "text": "25.3 Number\nVim has 4 different number types: decimal, hexadecimal, binary, and octal. By the way, when I say number data type, often this means an integer data type. In this guide, I will use the terms number and integer interchangeably.\n\n25.3.1 Decimal\nYou should be familiar with the decimal system. Vim accepts positive and negative decimals. 1, -1, 10, etc. In Vimscript programming, you will probably be using the decimal type most of the time.\n\n\n25.3.2 Hexadecimal\nHexadecimals start with 0x or 0X. Mnemonic: Hexadecimal.\n\n\n25.3.3 Binary\nBinaries start with 0b or 0B. Mnemonic: Binary.\n\n\n25.3.4 Octal\nOctals start with 0, 0o, and 0O. Mnemonic: Octal.\n\n\n25.3.5 Printing Numbers\nIf you echo either a hexadecimal, a binary, or an octal number, Vim automatically converts them to decimals.\n:echo 42\n\" returns 42\n\n:echo 052\n\" returns 42\n\n:echo 0b101010\n\" returns 42\n\n:echo 0x2A\n\" returns 42\n\n\n25.3.6 Truthy and Falsy\nIn Vim, a 0 value is falsy and all non-0 values are truthy.\nThe following will not echo anything.\n:if 0\n:  echo \"Nope\"\n:endif\nHowever, this will:\n:if 1\n:  echo \"Yes\"\n:endif\nAny values other than 0 is truthy, including negative numbers. 100 is truthy. -1 is truthy.\n\n\n25.3.7 Number Arithmetic\nNumbers can be used to run arithmetic expressions:\n:echo 3 + 1\n\" returns 4\n\n: echo 5 - 3\n\" returns 2\n\n:echo 2 * 2\n\" returns 4\n\n:echo 4 / 2\n\" returns 2\nWhen dividing a number with a remainder, Vim drops the remainder.\n:echo 5 / 2\n\" returns 2 instead of 2.5\nTo get a more accurate result, you need to use a float number."
  },
  {
    "objectID": "chapters/ch25_vimscript_basic_data_types.md.html#float",
    "href": "chapters/ch25_vimscript_basic_data_types.md.html#float",
    "title": "25  Ch25. Vimscript Basic Data Types",
    "section": "25.4 Float",
    "text": "25.4 Float\nFloats are numbers with trailing decimals. There are two ways to represent floating numbers: dot point notation (like 31.4) and exponent (3.14e01). Similar to numbers, you can use positive and negative signs:\n:echo +123.4\n\" returns 123.4\n\n:echo -1.234e2\n\" returns -123.4\n\n:echo 0.25\n\" returns 0.25\n\n:echo 2.5e-1\n\" returns 0.25\nYou need to give a float a dot and trailing digits. 25e-2 (no dot) and 1234. (has a dot, but no trailing digits) are both invalid float numbers.\n\n25.4.1 Float Arithmetic\nWhen doing an arithmetic expression between a number and a float, Vim coerces the result to a float.\n:echo 5 / 2.0\n\" returns 2.5\nFloat and float arithmetic gives you another float.\n:echo 1.0 + 1.0\n\" returns 2.0"
  },
  {
    "objectID": "chapters/ch25_vimscript_basic_data_types.md.html#string",
    "href": "chapters/ch25_vimscript_basic_data_types.md.html#string",
    "title": "25  Ch25. Vimscript Basic Data Types",
    "section": "25.5 String",
    "text": "25.5 String\nStrings are characters surrounded by either double-quotes (\"\") or single-quotes (''). Hello, 123, and 123.4 are examples of strings.\n\n25.5.1 String Concatenation\nTo concatenate a string in Vim, use the . operator.\n:echo \"Hello\" . \" world\"\n\" returns \"Hello world\"\n\n\n25.5.2 String Arithmetic\nWhen you run arithmetic operators (+ - * /) with a number and a string, Vim coerces the string into a number.\n:echo \"12 donuts\" + 3\n\" returns 15\nWhen Vim sees 12 donuts, it extracts the 12 from the string and converts it into the number 12. Then it performs addition, returning 15. For this string-to-number coercion to work, the number character needs to be the first character in the string.\nThe following won’t work because 12 is not the first character in the string:\n:echo \"donuts 12\" + 3\n\" returns 3\nThis also won’t work because an empty space is the first character of the string:\n:echo \" 12 donuts\" + 3\n\" returns 3\nThis coercion works even with two strings:\n:echo \"12 donuts\" + \"6 pastries\"\n\" returns 18\nThis works with any arithmetic operator, not only +:\n:echo \"12 donuts\" * \"5 boxes\"\n\" returns 60\n\n:echo \"12 donuts\" - 5\n\" returns 7\n\n:echo \"12 donuts\" / \"3 people\"\n\" returns 4\nA neat trick to force a string-to-number conversion is to just add 0 or multiply by 1:\n:echo \"12\" + 0\n\" returns 12\n\n:echo \"12\" * 1\n\" returns 12\nWhen arithmetic is done against a float in a string, Vim treats it like an integer, not a float:\n:echo \"12.0 donuts\" + 12\n\" returns 24, not 24.0\n\n\n25.5.3 Number and String Concatenation\nYou can coerce a number into a string with a dot operator (.):\n:echo 12 . \"donuts\"\n\" returns \"12donuts\"\nThe coercion only works with number data type, not float. This won’t work:\n:echo 12.0 . \"donuts\"\n\" does not return \"12.0donuts\" but throws an error\n\n\n25.5.4 String Conditionals\nRecall that 0 is falsy and all non-0 numbers are truthy. This is also true when using string as conditionals.\nIn the following if statement, Vim coerces 12donuts into 12, which is truthy:\n:if \"12donuts\"\n:  echo \"Yum\"\n:endif\n\" returns \"Yum\"\nOn the other hand, this is falsy:\n:if \"donuts12\"\n:  echo \"Nope\"\n:endif\n\" rerturns nothing\nVim coerces donuts12 into 0, because the first character is not a number.\n\n\n25.5.5 Double vs Single Quotes\nDouble quotes behave differently than single quotes. Single quotes display characters literally while double quotes accept special characters.\nWhat are special characters? Check out the newline and double-quotes display:\n:echo \"hello\\nworld\"\n\" returns\n\" hello\n\" world\n\n:echo \"hello \\\"world\\\"\"\n\" returns \"hello \"world\"\"\nCompare that with single-quotes:\n:echo 'hello\\nworld'\n\" returns 'hello\\nworld'\n\n:echo 'hello \\\"world\\\"'\n\" returns 'hello \\\"world\\\"'\nSpecial characters are special string characters that when escaped, behave differently. \\n acts like a newline. \\\" behaves like a literal \". For a list of other special characters, check out :h expr-quote.\n\n\n25.5.6 String Procedures\nLet’s look at some built-in string procedures.\nYou can get the length of a string with strlen().\n:echo strlen(\"choco\")\n\" returns 5\nYou can convert string to a number with str2nr():\n:echo str2nr(\"12donuts\")\n\" returns 12\n\n:echo str2nr(\"donuts12\")\n\" returns 0\nSimilar to the string-to-number coercion earlier, if the number is not the first character, Vim won’t catch it.\nThe good news is that Vim has a method that transforms a string to a float, str2float():\n:echo str2float(\"12.5donuts\")\n\" returns 12.5\nYou can substitute a pattern in a string with the substitute() method:\n:echo substitute(\"sweet\", \"e\", \"o\", \"g\")\n\" returns \"swoot\"\nThe last parameter, g, is the global flag. With it, Vim will substitute all matching occurrences. Without it, Vim will only substitute the first match.\n:echo substitute(\"sweet\", \"e\", \"o\", \"\")\n\" returns \"swoet\"\nThe substitute command can be combined with getline(). Recall that the function getline() gets the text on the given line number. Suppose you have the text chocolate donut on line 5. You can use the procedure:\n:echo substitute(getline(5), \"chocolate\", \"glazed\", \"g\")\n\" returns glazed donut\nThere are many other string procedures. Check out :h string-functions."
  },
  {
    "objectID": "chapters/ch25_vimscript_basic_data_types.md.html#list",
    "href": "chapters/ch25_vimscript_basic_data_types.md.html#list",
    "title": "25  Ch25. Vimscript Basic Data Types",
    "section": "25.6 List",
    "text": "25.6 List\nA Vimscript list is like an Array in Javascript or List in Python. It is an ordered sequence of items. You can mix-and-match the content with different data types:\n[1,2,3]\n['a', 'b', 'c']\n[1,'a', 3.14]\n[1,2,[3,4]]\n\n25.6.1 Sublists\nVim list is zero-indexed. You can access a particular item in a list with [n], where n is the index.\n:echo [\"a\", \"sweet\", \"dessert\"][0]\n\" returns \"a\"\n\n:echo [\"a\", \"sweet\", \"dessert\"][2]\n\" returns \"dessert\"\nIf you go over the maximum index number, Vim will throw an error saying that the index is out of range:\n:echo [\"a\", \"sweet\", \"dessert\"][999]\n\" returns an error\nWhen you go below zero, Vim will start the index from the last element. Going past the minimum index number will also throw you an error:\n:echo [\"a\", \"sweet\", \"dessert\"][-1]\n\" returns \"dessert\"\n\n:echo [\"a\", \"sweet\", \"dessert\"][-3]\n\" returns \"a\"\n\n:echo [\"a\", \"sweet\", \"dessert\"][-999]\n\" returns an error\nYou can slice several elements from a list with [n:m], where n is the starting index and m is the ending index.\n:echo [\"chocolate\", \"glazed\", \"plain\", \"strawberry\", \"lemon\", \"sugar\", \"cream\"][2:4]\n\" returns [\"plain\", \"strawberry\", \"lemon\"]\nIf you don’t pass m ([n:]), Vim will return the rest of the elements starting from the nth element. If you don’t pass n ([:m]), Vim will return the first element up to the mth element.\n:echo [\"chocolate\", \"glazed\", \"plain\", \"strawberry\", \"lemon\", \"sugar\", \"cream\"][2:]\n\" returns ['plain', 'strawberry', 'lemon', 'sugar', 'cream']\n\n:echo [\"chocolate\", \"glazed\", \"plain\", \"strawberry\", \"lemon\", \"sugar\", \"cream\"][:4]\n\" returns ['chocolate', 'glazed', 'plain', 'strawberry', 'lemon']\nYou can pass an index that exceeds the maximum items when slicing an array.\n:echo [\"chocolate\", \"glazed\", \"plain\", \"strawberry\", \"lemon\", \"sugar\", \"cream\"][2:999]\n\" returns ['plain', 'strawberry', 'lemon', 'sugar', 'cream']\n\n\n25.6.2 Slicing String\nYou can slice and target strings just like lists:\n:echo \"choco\"[0]\n\" returns \"c\"\n\n:echo \"choco\"[1:3]\n\" returns \"hoc\"\n\n:echo \"choco\"[:3]\n\" returns choc\n\n:echo \"choco\"[1:]\n\" returns hoco\n\n\n25.6.3 List Arithmetic\nYou can use + to concatenate and mutate a list:\n:let sweetList = [\"chocolate\", \"strawberry\"]\n:let sweetList += [\"sugar\"]\n:echo sweetList\n\" returns [\"chocolate\", \"strawberry\", \"sugar\"]\n\n\n25.6.4 List Functions\nLet’s explore Vim’s built-in list functions.\nTo get the length of a list, use len():\n:echo len([\"chocolate\", \"strawberry\"])\n\" returns 2\nTo prepend an element to a list, you can use insert():\n:let sweetList = [\"chocolate\", \"strawberry\"]\n:call insert(sweetList, \"glazed\")\n\n:echo sweetList\n\" returns [\"glazed\", \"chocolate\", \"strawberry\"]\nYou can also pass insert() the index where you want to prepend the element to. If you want to prepend an item before the second element (index 1):\n:let sweeterList = [\"glazed\", \"chocolate\", \"strawberry\"]\n:call insert(sweeterList, \"cream\", 1)\n\n:echo sweeterList\n\" returns ['glazed', 'cream', 'chocolate', 'strawberry']\nTo remove a list item, use remove(). It accepts a list and the element index you want to remove.\n:let sweeterList = [\"glazed\", \"chocolate\", \"strawberry\"]\n:call remove(sweeterList, 1)\n\n:echo sweeterList\n\" returns ['glazed', 'strawberry']\nYou can use map() and filter() on a list. To filter out element containing the phrase choco:\n:let sweeterList = [\"glazed\", \"chocolate\", \"strawberry\"]\n:call filter(sweeterList, 'v:val !~ \"choco\"')\n:echo sweeterList\n\" returns [\"glazed\", \"strawberry\"]\n\n:let sweetestList = [\"chocolate\", \"glazed\", \"sugar\"]\n:call map(sweetestList, 'v:val . \" donut\"')\n:echo sweetestList\n\" returns ['chocolate donut', 'glazed donut', 'sugar donut']\nThe v:val variable is a Vim special variable. It is available when iterating a list or a dictionary using map() or filter(). It represents each iterated item.\nFor more, check out :h list-functions.\n\n\n25.6.5 List Unpacking\nYou can unpack a list and assign variables to the list items:\n:let favoriteFlavor = [\"chocolate\", \"glazed\", \"plain\"]\n:let [flavor1, flavor2, flavor3] = favoriteFlavor\n\n:echo flavor1\n\" returns \"chocolate\"\n\n:echo flavor2\n\" returns \"glazed\"\nTo assign the rest of list items, you can use ; followed with a variable name:\n:let favoriteFruits = [\"apple\", \"banana\", \"lemon\", \"blueberry\", \"raspberry\"]\n:let [fruit1, fruit2; restFruits] = favoriteFruits\n\n:echo fruit1\n\" returns \"apple\"\n\n:echo restFruits\n\" returns ['lemon', 'blueberry', 'raspberry']\n\n\n25.6.6 Modifying List\nYou can modify a list item directly:\n:let favoriteFlavor = [\"chocolate\", \"glazed\", \"plain\"]\n:let favoriteFlavor[0] = \"sugar\"\n:echo favoriteFlavor\n\" returns ['sugar', 'glazed', 'plain']\nYou can mutate multiple list items directly:\n:let favoriteFlavor = [\"chocolate\", \"glazed\", \"plain\"]\n:let favoriteFlavor[2:] = [\"strawberry\", \"chocolate\"]\n:echo favoriteFlavor\n\" returns ['chocolate', 'glazed', 'strawberry', 'chocolate']"
  },
  {
    "objectID": "chapters/ch25_vimscript_basic_data_types.md.html#dictionary",
    "href": "chapters/ch25_vimscript_basic_data_types.md.html#dictionary",
    "title": "25  Ch25. Vimscript Basic Data Types",
    "section": "25.7 Dictionary",
    "text": "25.7 Dictionary\nA Vimscript dictionary is an associative, unordered list. A non-empty dictionary consists of at least a key-value pair.\n{\"breakfast\": \"waffles\", \"lunch\": \"pancakes\"}\n{\"meal\": [\"breakfast\", \"second breakfast\", \"third breakfast\"]}\n{\"dinner\": 1, \"dessert\": 2}\nA Vim dictionary data object uses string for key. If you try to use a number, Vim will coerce it into a string.\n:let breakfastNo = {1: \"7am\", 2: \"9am\", \"11ses\": \"11am\"}\n\n:echo breakfastNo\n\" returns {'1': '7am', '2': '9am', '11ses': '11am'}\nIf you are too lazy to put quotes around each key, you can use the #{} notation:\n:let mealPlans = #{breakfast: \"waffles\", lunch: \"pancakes\", dinner: \"donuts\"}\n\n:echo mealPlans\n\" returns {'lunch': 'pancakes', 'breakfast': 'waffles', 'dinner': 'donuts'}\nThe only requirement for using the #{} syntax is that each key must be either:\n\nASCII character.\nDigit.\nAn underscore (_).\nA hyphen (-).\n\nJust like list, you can use any data type as values.\n:let mealPlan = {\"breakfast\": [\"pancake\", \"waffle\", \"hash brown\"], \"lunch\": WhatsForLunch(), \"dinner\": {\"appetizer\": \"gruel\", \"entree\": \"more gruel\"}}\n\n25.7.1 Accessing Dictionary\nTo access a value from a dictionary, you can call the key with either the square brackets (['key']) or the dot notation (.key).\n:let meal = {\"breakfast\": \"gruel omelettes\", \"lunch\": \"gruel sandwiches\", \"dinner\": \"more gruel\"}\n\n:let breakfast = meal['breakfast']\n:let lunch = meal.lunch\n\n:echo breakfast\n\" returns \"gruel omelettes\"\n\n:echo lunch\n\" returns \"gruel sandwiches\"\n\n\n25.7.2 Modifying Dictionary\nYou can modify or even add a dictionary content:\n:let meal = {\"breakfast\": \"gruel omelettes\", \"lunch\": \"gruel sandwiches\"}\n\n:let meal.breakfast = \"breakfast tacos\"\n:let meal[\"lunch\"] = \"tacos al pastor\"\n:let meal[\"dinner\"] = \"quesadillas\"\n\n:echo meal\n\" returns {'lunch': 'tacos al pastor', 'breakfast': 'breakfast tacos', 'dinner': 'quesadillas'}\n\n\n25.7.3 Dictionary Functions\nLet’s explore some of Vim’s built-in functions to handle dictionaries.\nTo check the length of a dictionary, use len().\n:let mealPlans = #{breakfast: \"waffles\", lunch: \"pancakes\", dinner: \"donuts\"}\n\n:echo len(meaPlans)\n\" returns 3\nTo see if a dictionary contains a specific key, use has_key().\n:let mealPlans = #{breakfast: \"waffles\", lunch: \"pancakes\", dinner: \"donuts\"}\n\n:echo has_key(mealPlans, \"breakfast\")\n\" returns 1\n\n:echo has_key(mealPlans, \"dessert\")\n\" returns 0\nTo see if a dictionary has any item, use empty(). The empty() procedure works with all data types: list, dictionary, string, number, float, etc.\n:let mealPlans = #{breakfast: \"waffles\", lunch: \"pancakes\", dinner: \"donuts\"}\n:let noMealPlan = {}\n\n:echo empty(noMealPlan)\n\" returns 1\n\n:echo empty(mealPlans)\n\" returns 0\nTo remove an entry from a dictionary, use remove().\n:let mealPlans = #{breakfast: \"waffles\", lunch: \"pancakes\", dinner: \"donuts\"}\n\n:echo \"removing breakfast: \" . remove(mealPlans, \"breakfast\")\n\" returns \"removing breakfast: 'waffles'\"\"\n\n:echo mealPlans\n\" returns {'lunch': 'pancakes', 'dinner': 'donuts'}\nTo convert a dictionary into a list of lists, use items():\n:let mealPlans = #{breakfast: \"waffles\", lunch: \"pancakes\", dinner: \"donuts\"}\n\n:echo items(mealPlans)\n\" returns [['lunch', 'pancakes'], ['breakfast', 'waffles'], ['dinner', 'donuts']]\nfilter() and map() are also available.\n:let breakfastNo = {1: \"7am\", 2: \"9am\", \"11ses\": \"11am\"}\n:call filter(breakfastNo, 'v:key > 1')\n\n:echo breakfastNo\n\" returns {'2': '9am', '11ses': '11am'}\nSince a dictionary contains key-value pairs, Vim provides v:key special variable that works similar to v:val. When iterating through a dictionary, v:key will hold the value of the current iterated key.\nIf you have a mealPlans dictionary, you can map it using v:key.\n:let mealPlans = #{breakfast: \"waffles\", lunch: \"pancakes\", dinner: \"donuts\"}\n:call map(mealPlans, 'v:key . \" and milk\"')\n\n:echo mealPlans\n\" returns {'lunch': 'lunch and milk', 'breakfast': 'breakfast and milk', 'dinner': 'dinner and milk'}\nSimilarly, you can map it using v:val:\n:let mealPlans = #{breakfast: \"waffles\", lunch: \"pancakes\", dinner: \"donuts\"}\n:call map(mealPlans, 'v:val . \" and milk\"')\n\n:echo mealPlans\n\" returns {'lunch': 'pancakes and milk', 'breakfast': 'waffles and milk', 'dinner': 'donuts and milk'}\nTo see more dictionary functions, check out :h dict-functions."
  },
  {
    "objectID": "chapters/ch25_vimscript_basic_data_types.md.html#special-primitives",
    "href": "chapters/ch25_vimscript_basic_data_types.md.html#special-primitives",
    "title": "25  Ch25. Vimscript Basic Data Types",
    "section": "25.8 Special Primitives",
    "text": "25.8 Special Primitives\nVim has special primitives:\n\nv:false\nv:true\nv:none\nv:null\n\nBy the way, v: is Vim’s built-in variable. They will be covered more in a later chapter.\nIn my experience, you won’t use these special primitives often. If you need a truthy / falsy value, you can just use 0 (falsy) and non-0 (truthy). If you need an empty string, just use \"\". But it is still good to know, so let’s quickly go over them.\n\n25.8.1 True\nThis is equivalent to true. It is equivalent to a number with value of non-0 . When decoding json with json_encode(), it is interpreted as true.\n:echo json_encode({\"test\": v:true})\n\" returns {\"test\": true}\n\n\n25.8.2 False\nThis is equivalent to false. It is equivalent to a number with value of 0. When decoding json with json_encode(), it is interpreted as false.\n:echo json_encode({\"test\": v:false})\n\" returns {\"test\": false}\n\n\n25.8.3 None\nIt is equivalent to an empty string. When decoding json with json_encode(), it is interpreted as an empty item (null).\n:echo json_encode({\"test\": v:none})\n\" returns {\"test\": null}\n\n\n25.8.4 Null\nSimilar to v:none.\n:echo json_encode({\"test\": v:null})\n\" returns {\"test\": null}"
  },
  {
    "objectID": "chapters/ch25_vimscript_basic_data_types.md.html#learn-data-types-the-smart-way",
    "href": "chapters/ch25_vimscript_basic_data_types.md.html#learn-data-types-the-smart-way",
    "title": "25  Ch25. Vimscript Basic Data Types",
    "section": "25.9 Learn Data Types the Smart Way",
    "text": "25.9 Learn Data Types the Smart Way\nIn this chapter, you learned about Vimscript’s basic data types: number, float, string, list, dictionary, and special. Learning these is the first step to start Vimscript programming.\nIn the next chapter, you will learn how to combine them for writing expressions like equalities, conditionals, and loops."
  },
  {
    "objectID": "chapters/ch26_vimscript_conditionals_and_loops.md.html#relational-operators",
    "href": "chapters/ch26_vimscript_conditionals_and_loops.md.html#relational-operators",
    "title": "26  Ch26. Vimscript Conditionals and Loops",
    "section": "26.1 Relational Operators",
    "text": "26.1 Relational Operators\nVimscript relational operators are similar to many programming languages:\na == b      equal to\na != b      not equal to\na >  b      greater than\na >= b      greater than or equal to\na <  b      less than\na <= b      less than or equal to\nFor example:\n:echo 5 == 5\n:echo 5 != 5\n:echo 10 > 5\n:echo 10 >= 5\n:echo 10 < 5\n:echo 5 <= 5\nRecall that strings are coerced into numbers in an arithmetic expression. Here Vim also coerces strings into numbers in an equality expression. 5foo is coerced into 5 (truthy):\n:echo 5 == \"5foo\"\n\" returns true\nAlso recall that if you start a string with a non-numerical character like foo5, the string is converted into number 0 (falsy).\necho 5 == \"foo5\"\n\" returns false\n\n26.1.1 String Logic Operators\nVim has more relational operators for comparing strings:\na =~ b\na !~ b\nFor examples:\nlet str = \"hearty breakfast\"\n\necho str =~ \"hearty\"\n\" returns true\n\necho str =~ \"dinner\"\n\" returns false\n\necho str !~ \"dinner\"\n\" returns true\nThe =~ operator performs a regex match against the given string. In the example above, str =~ \"hearty\" returns true because str contains the hearty pattern. You can always use == and !=, but using them will compare the expression against the entire string. =~ and !~ are more flexible choices.\necho str == \"hearty\"\n\" returns false\n\necho str == \"hearty breakfast\"\n\" returns true\nLet’s try this one. Note the uppercase H:\necho str =~ \"Hearty\"\n\" true\nIt returns true even though Hearty is capitalized. Interesting… It turns out that my Vim setting is set to ignore case (set ignorecase), so when Vim checks for equality, it uses my Vim setting and ignores the case. If I were to turn off ignore case (set noignorecase), the comparison now returns false.\nset noignorecase\necho str =~ \"Hearty\"\n\" returns false because case matters\n\nset ignorecase\necho str =~ \"Hearty\"\n\" returns true because case doesn't matter\nIf you are writing a plugin for others, this is a tricky situation. Does the user use ignorecase or noignorecase? You definitely do not want to force your users to change their ignore case option. So what do you do?\nLuckily, Vim has an operator that can always ignore or match case. To always match case, add a # at the end.\nset ignorecase\necho str =~# \"hearty\"\n\" returns true\n\necho str =~# \"HearTY\"\n\" returns false\n\nset noignorecase\necho str =~# \"hearty\"\n\" true\n\necho str =~# \"HearTY\"\n\" false\n\necho str !~# \"HearTY\"\n\" true\nTo always ignore case when comparing, append it with ?:\nset ignorecase\necho str =~? \"hearty\"\n\" true\n\necho str =~? \"HearTY\"\n\" true\n\nset noignorecase\necho str =~? \"hearty\"\n\" true\n\necho str =~? \"HearTY\"\n\" true\n\necho str !~? \"HearTY\"\n\" false\nI prefer to use # to always match the case and be on the safe side."
  },
  {
    "objectID": "chapters/ch26_vimscript_conditionals_and_loops.md.html#if",
    "href": "chapters/ch26_vimscript_conditionals_and_loops.md.html#if",
    "title": "26  Ch26. Vimscript Conditionals and Loops",
    "section": "26.2 If",
    "text": "26.2 If\nNow that you have seen Vim’s equality expressions, let’s touch a fundamental conditional operator, the if statement.\nAt minimum, the syntax is:\nif {clause}\n  {some expression}\nendif\nYou can extend the case analysis with elseif and else.\nif {predicate1}\n  {expression1}\nelseif {predicate2}\n  {expression2}\nelseif {predicate3}\n  {expression3}\nelse\n  {expression4}\nendif\nFor example, the plugin vim-signify uses a different installation method depending on your Vim settings. Below is the installation instruction from their readme, using the if statement:\nif has('nvim') || has('patch-8.0.902')\n  Plug 'mhinz/vim-signify'\nelse\n  Plug 'mhinz/vim-signify', { 'branch': 'legacy' }\nendif"
  },
  {
    "objectID": "chapters/ch26_vimscript_conditionals_and_loops.md.html#ternary-expression",
    "href": "chapters/ch26_vimscript_conditionals_and_loops.md.html#ternary-expression",
    "title": "26  Ch26. Vimscript Conditionals and Loops",
    "section": "26.3 Ternary Expression",
    "text": "26.3 Ternary Expression\nVim has a ternary expression for a one-liner case analysis:\n{predicate} ? expressiontrue : expressionfalse\nFor example:\necho 1 ? \"I am true\" : \"I am false\"\nSince 1 is truthy, Vim echoes I am true. Suppose you want to conditionally set the background to dark if you are using Vim past a certain hour. Add this to vimrc:\nlet &background = strftime(\"%H\") < 18 ? \"light\" : \"dark\"\n&background is the 'background' option in Vim. strftime(\"%H\") returns the current time in hours. If it is not yet 6 PM, use a light background. Otherwise, use a dark background."
  },
  {
    "objectID": "chapters/ch26_vimscript_conditionals_and_loops.md.html#or",
    "href": "chapters/ch26_vimscript_conditionals_and_loops.md.html#or",
    "title": "26  Ch26. Vimscript Conditionals and Loops",
    "section": "26.4 or",
    "text": "26.4 or\nThe logical or (||) works like many programming languages.\n{Falsy expression}  || {Falsy expression}   false\n{Falsy expression}  || {Truthy expression}  true\n{Truthy expression} || {Falsy expression}   true\n{Truthy expression} || {Truthy expression}  true\nVim evaluates the expression and return either 1 (truthy) or 0 (falsy).\necho 5 || 0\n\" returns 1\n\necho 5 || 5\n\" returns 1\n\necho 0 || 0\n\" returns 0\n\necho \"foo5\" || \"foo5\"\n\" returns 0\n\necho \"5foo\" || \"foo5\"\n\" returns 1\nIf the current expression evaluates to truthy, the subsequent expression won’t be evaluated.\nlet one_dozen = 12\n\necho one_dozen || two_dozen\n\" returns 1\n\necho two_dozen || one_dozen\n\" returns error\nNote that two_dozen is never defined. The expression one_dozen || two_dozen doesn’t throw any error because one_dozen is evaluated first found to be truthy, so Vim doesn’t evaluate two_dozen."
  },
  {
    "objectID": "chapters/ch26_vimscript_conditionals_and_loops.md.html#and",
    "href": "chapters/ch26_vimscript_conditionals_and_loops.md.html#and",
    "title": "26  Ch26. Vimscript Conditionals and Loops",
    "section": "26.5 and",
    "text": "26.5 and\nThe logical and (&&) is the complement of the logical or.\n{Falsy Expression}  && {Falsy Expression}   false\n{Falsy expression}  && {Truthy expression}  false\n{Truthy Expression} && {Falsy Expression}   false\n{Truthy expression} && {Truthy expression}  true\nFor example:\necho 0 && 0\n\" returns 0\n\necho 0 && 10\n\" returns 0\n&& evaluates an expression until it sees the first falsy expression. For example, if you have true && true, it will evaluate both and return true. If you have true && false && true, it will evaluate the first true and stop at the first false. It will not evaluate the third true.\nlet one_dozen = 12\necho one_dozen && 10\n\" returns 1\n\necho one_dozen && v:false\n\" returns 0\n\necho one_dozen && two_dozen\n\" returns error\n\necho exists(\"one_dozen\") && one_dozen == 12\n\" returns 1"
  },
  {
    "objectID": "chapters/ch26_vimscript_conditionals_and_loops.md.html#for",
    "href": "chapters/ch26_vimscript_conditionals_and_loops.md.html#for",
    "title": "26  Ch26. Vimscript Conditionals and Loops",
    "section": "26.6 for",
    "text": "26.6 for\nThe for loop is commonly used with the list data type.\nlet breakfasts = [\"pancakes\", \"waffles\", \"eggs\"]\n\nfor breakfast in breakfasts\n  echo breakfast\nendfor\nIt works with nested list:\nlet meals = [[\"breakfast\", \"pancakes\"], [\"lunch\", \"fish\"], [\"dinner\", \"pasta\"]]\n\nfor [meal_type, food] in meals\n  echo \"I am having \" . food . \" for \" . meal_type\nendfor\nYou can technically use the for loop with a dictionary using the keys() method.\nlet beverages = #{breakfast: \"milk\", lunch: \"orange juice\", dinner: \"water\"}\nfor beverage_type in keys(beverages)\n  echo \"I am drinking \" . beverages[beverage_type] . \" for \" . beverage_type\nendfor"
  },
  {
    "objectID": "chapters/ch26_vimscript_conditionals_and_loops.md.html#while",
    "href": "chapters/ch26_vimscript_conditionals_and_loops.md.html#while",
    "title": "26  Ch26. Vimscript Conditionals and Loops",
    "section": "26.7 While",
    "text": "26.7 While\nAnother common loop is the while loop.\nlet counter = 1\nwhile counter < 5\n  echo \"Counter is: \" . counter\n  let counter += 1\nendwhile\nTo get the content of the current line to the last line:\nlet current_line = line(\".\")\nlet last_line = line(\"$\")\n\nwhile current_line <= last_line\n  echo getline(current_line)\n  let current_line += 1\nendwhile"
  },
  {
    "objectID": "chapters/ch26_vimscript_conditionals_and_loops.md.html#error-handling",
    "href": "chapters/ch26_vimscript_conditionals_and_loops.md.html#error-handling",
    "title": "26  Ch26. Vimscript Conditionals and Loops",
    "section": "26.8 Error Handling",
    "text": "26.8 Error Handling\nOften your program doesn’t run the way you expect it to. As a result, it throws you for a loop (pun intended). What you need is a proper error handling.\n\n26.8.1 Break\nWhen you use break inside a while or for loop, it stops the loop.\nTo get the texts from the start of the file to the current line, but stop when you see the word donut:\nlet line = 0\nlet last_line = line(\"$\")\nlet total_word = \"\"\n\nwhile line <= last_line\n  let line += 1\n  let line_text = getline(line)\n  if line_text =~# \"donut\"\n    break\n  endif\n  echo line_text\n  let total_word .= line_text . \" \"\nendwhile\n\necho total_word\nIf you have the text:\none\ntwo\nthree\ndonut\nfour\nfive\nRunning the above while loop gives one two three and not the rest of the text because the loop breaks once it matches donut.\n\n\n26.8.2 Continue\nThe continue method is similar to break, where it is invoked during a loop. The difference is that instead of breaking out of the loop, it just skips that current iteration.\nSuppose you have the same text but instead of break, you use continue:\nlet line = 0\nlet last_line = line(\"$\")\nlet total_word = \"\"\n\nwhile line <= last_line\n  let line += 1\n  let line_text = getline(line)\n  if line_text =~# \"donut\"\n    continue\n  endif\n  echo line_text\n  let total_word .= line_text . \" \"\nendwhile\n\necho total_word\nThis time it returns one two three four five. It skips the line with the word donut, but the loop continues.\n\n\n26.8.3 try, finally, and catch\nVim has a try, finally, and catch to handle errors. To simulate an error, you can use the throw command.\ntry\n  echo \"Try\"\n  throw \"Nope\"\nendtry\nRun this. Vim will complain with \"Exception not caught: Nope error.\nNow add a catch block:\ntry\n  echo \"Try\"\n  throw \"Nope\"\ncatch\n  echo \"Caught it\"\nendtry\nNow there is no longer any error. You should see Try and Caught it displayed.\nLet’s remove the catch and add a finally:\ntry\n  echo \"Try\"\n  throw \"Nope\"\n  echo \"You won't see me\"\nfinally\n  echo \"Finally\"\nendtry\nRun this. Now Vim displays the error and Finally.\nLet’s put all of them together:\ntry\n  echo \"Try\"\n  throw \"Nope\"\ncatch\n  echo \"Caught it\"\nfinally\n  echo \"Finally\"\nendtry\nThis time Vim displays both Caught it and Finally. No error is displayed because Vim caught it.\nErrors come from different places. Another source of error is calling a nonexistent function, like Nope() below:\ntry\n  echo \"Try\"\n  call Nope()\ncatch\n  echo \"Caught it\"\nfinally\n  echo \"Finally\"\nendtry\nThe difference between catch and finally is that finally is always run, error or not, where a catch is only run when your code gets an error.\nYou can catch specific error with :catch. According to :h :catch:\ncatch /^Vim:Interrupt$/.             \" catch interrupts (CTRL-C)\ncatch /^Vim\\\\%((\\\\a\\\\+)\\\\)\\\\=:E/.    \" catch all Vim errors\ncatch /^Vim\\\\%((\\\\a\\\\+)\\\\)\\\\=:/.     \" catch errors and interrupts\ncatch /^Vim(write):/.                \" catch all errors in :write\ncatch /^Vim\\\\%((\\\\a\\\\+)\\\\)\\\\=:E123:/ \" catch error E123\ncatch /my-exception/.                \" catch user exception\ncatch /.*/                           \" catch everything\ncatch.                               \" same as /.*/\nInside a try block, an interrupt is considered a catchable error.\ntry\n  catch /^Vim:Interrupt$/\n  sleep 100\nendtry\nIn your vimrc, if you use a custom colorscheme, like gruvbox, and you accidentally delete the colorscheme directory but still have the line colorscheme gruvbox in your vimrc, Vim will throw an error when you source it. To fix this, I added this in my vimrc:\ntry\n  colorscheme gruvbox\ncatch\n  colorscheme default\nendtry\nNow if you source vimrc without gruvbox directory, Vim will use the colorscheme default."
  },
  {
    "objectID": "chapters/ch26_vimscript_conditionals_and_loops.md.html#learn-conditionals-the-smart-way",
    "href": "chapters/ch26_vimscript_conditionals_and_loops.md.html#learn-conditionals-the-smart-way",
    "title": "26  Ch26. Vimscript Conditionals and Loops",
    "section": "26.9 Learn Conditionals the Smart Way",
    "text": "26.9 Learn Conditionals the Smart Way\nIn the previous chapter, you learned about Vim basic data types. In this chapter, you learned how to combine them to write basic programs using conditionals and loops. These are the building blocks of programming.\nNext, let’s learn about variable scopes."
  },
  {
    "objectID": "chapters/ch27_vimscript_variable_scopes.md.html#mutable-and-immutable-variables",
    "href": "chapters/ch27_vimscript_variable_scopes.md.html#mutable-and-immutable-variables",
    "title": "27  Ch27. Vimscript Variable Scopes",
    "section": "27.1 Mutable and Immutable Variables",
    "text": "27.1 Mutable and Immutable Variables\nYou can assign a value to a variable in Vim with let:\nlet pancake = \"pancake\"\nLater you can call that variable any time.\necho pancake\n\" returns \"pancake\"\nlet is mutable, meaning you can change the value at any time in the future.\nlet pancake = \"pancake\"\nlet pancake = \"not waffles\"\n\necho pancake\n\" returns \"not waffles\"\nNotice that when you want to change the value of a set variable, you still need to use let.\nlet beverage = \"milk\"\n\nbeverage = \"orange juice\"\n\" throws an error\nYou can define an immutable variable with const. Being immutable, once a variable value is assigned, you cannot reassign it with a different value.\nconst waffle = \"waffle\"\nconst waffle = \"pancake\"\n\" throws an error"
  },
  {
    "objectID": "chapters/ch27_vimscript_variable_scopes.md.html#variable-sources",
    "href": "chapters/ch27_vimscript_variable_scopes.md.html#variable-sources",
    "title": "27  Ch27. Vimscript Variable Scopes",
    "section": "27.2 Variable Sources",
    "text": "27.2 Variable Sources\nThere are three sources for variables: environment variable, option variable, and register variable.\n\n27.2.1 Environment Variable\nVim can access your terminal environment variable. For example, if you have the SHELL environment variable available in your terminal, you can access it from Vim with:\necho $SHELL\n\" returns $SHELL value. In my case, it returns /bin/bash\n\n\n27.2.2 Option Variable\nYou can access Vim options with & (these are the settings you access with set).\nFor example, to see what background Vim uses, you can run:\necho &background\n\" returns either \"light\" or \"dark\"\nAlternatively, you can always run set background? to see the value of the background option.\n\n\n27.2.3 Register Variable\nYou can access Vim registers (Ch. 08) with @.\nSuppose the value chocolate is already saved in register a. To access it, you can use @a. You can also update it with let.\necho @a\n\" returns chocolate\n\nlet @a .= \" donut\"\n\necho @a\n\" returns \"chocolate donut\"\nNow when you paste from register a (\"ap), it will return chocolate donut. The operator .= concatenates two strings. The expression let @a .= \" donut\" is the same as let @a = @a . \" donut\""
  },
  {
    "objectID": "chapters/ch27_vimscript_variable_scopes.md.html#variable-scopes",
    "href": "chapters/ch27_vimscript_variable_scopes.md.html#variable-scopes",
    "title": "27  Ch27. Vimscript Variable Scopes",
    "section": "27.3 Variable Scopes",
    "text": "27.3 Variable Scopes\nThere are 9 different variable scopes in Vim. You can recognize them from their prepended letter:\ng:           Global variable\n{nothing}    Global variable\nb:           Buffer-local variable\nw:           Window-local variable\nt:           Tab-local variable\ns:           Sourced Vimscript variable\nl:           Function local variable\na:           Function formal parameter variable\nv:           Built-in Vim variable\n\n27.3.1 Global Variable\nWhen you are declaring a regular variable:\nlet pancake = \"pancake\"\npancake is actually a global variable. When you define a global variable, you can call them from anywhere.\nPrepending g: to a variable also creates a global variable.\nlet g:waffle = \"waffle\"\nIn this case both pancake and g:waffle have the same scope. You can call each of them with or without g:.\necho pancake\n\" returns \"pancake\"\n\necho g:pancake\n\" returns \"pancake\"\n\necho waffle\n\" returns \"waffle\"\n\necho g:waffle\n\" returns \"waffle\"\n\n\n27.3.2 Buffer Variable\nA variable preceded with b: is a buffer variable. A buffer variable is a variable that is local to the current buffer (Ch. 02). If you have multiple buffers open, each buffer will have their own separate list of buffer variables.\nIn buffer 1:\nconst b:donut = \"chocolate donut\"\nIn buffer 2:\nconst b:donut = \"blueberry donut\"\nIf you run echo b:donut from buffer 1, it will return chocolate donut. If you run it from buffer 2, it will return blueberry donut.\nOn the side note, Vim has a special buffer variable b:changedtick that keeps track of all the changes done to the current buffer.\n\nRun echo b:changedtick and note the number it returns..\nMake changes in Vim.\nRun echo b:changedtick again and note the number it now returns.\n\n\n\n27.3.3 Window Variable\nA variable preceded with w: is a window variable. It exists only in that window.\nIn window 1:\nconst w:donut = \"chocolate donut\"\nIn window 2:\nconst w:donut = \"raspberry donut\"\nOn each window, you can call echo w:donut to get unique values.\n\n\n27.3.4 Tab Variable\nA variable preceded with t: is a tab variable. It exists only in that tab.\nIn tab 1:\nconst t:donut = \"chocolate donut\"\nIn tab 2:\nconst t:donut = \"blackberry donut\"\nOn each tab, you can call echo t:donut to get unique values.\n\n\n27.3.5 Script Variable\nA variable preceded with s: is a script variable. These variables can only be accessed from inside that script.\nIf you have an arbitrary file dozen.vim and inside it you have:\nlet s:dozen = 12\n\nfunction Consume()\n  let s:dozen -= 1\n  echo s:dozen \" is left\"\nendfunction\nSource the file with :source dozen.vim. Now call the Consume function:\n:call Consume()\n\" returns \"11 is left\"\n\n:call Consume()\n\" returns \"10 is left\"\n\n:echo s:dozen\n\" Undefined variable error\nWhen you call Consume, you see it decrements the s:dozen value as expected. When you try to get s:dozen value directly, Vim won’t find it because you are out of scope. s:dozen is only accessible from inside dozen.vim.\nEach time you source the dozen.vim file, it resets the s:dozen counter. If you are in the middle of decrementing s:dozen value and you run :source dozen.vim, the counter resets back to 12. This can be a problem for unsuspecting users. To fix this issue, refactor the code:\nif !exists(\"s:dozen\")\n  let s:dozen = 12\nendif\n\nfunction Consume()\n  let s:dozen -= 1\n  echo s:dozen\nendfunction\nNow when you source dozen.vim while in the middle of decrementing, Vim reads !exists(\"s:dozen\"), finds that it is true, and doesn’t reset the value back to 12.\n\n\n27.3.6 Function Local and Function Formal Parameter Variable\nBoth the function local variable (l:) and the function formal variable (a:) will be covered in the next chapter.\n\n\n27.3.7 Built-in Vim Variables\nA variable prepended with v: is a special built-in Vim variable. You cannot define these variables. You have seen some of them already. - v:version tells you what Vim version you are using. - v:key contains the current item value when iterating through a dictionary. - v:val contains the current item value when running a map() or filter() operation. - v:true, v:false, v:null, and v:none are special data types.\nThere are other variables. For a list of Vim built-in variables, check out :h vim-variable or :h v:."
  },
  {
    "objectID": "chapters/ch27_vimscript_variable_scopes.md.html#using-vim-variable-scopes-the-smart-way",
    "href": "chapters/ch27_vimscript_variable_scopes.md.html#using-vim-variable-scopes-the-smart-way",
    "title": "27  Ch27. Vimscript Variable Scopes",
    "section": "27.4 Using Vim Variable Scopes the Smart Way",
    "text": "27.4 Using Vim Variable Scopes the Smart Way\nBeing able to quickly access environment, option, and register variables give you a broad flexibility to customize your editor and terminal environment. You also learned that Vim has 9 different variable scopes, each existing under a certain constraints. You can take advantage of these unique variable types to decouple your program.\nYou made it this far. You learned about data types, means of combinations, and variable scopes. Only one thing is left: functions."
  },
  {
    "objectID": "chapters/ch28_vimscript_functions.md.html#function-syntax-rules",
    "href": "chapters/ch28_vimscript_functions.md.html#function-syntax-rules",
    "title": "28  Ch28. Vimscript Functions",
    "section": "28.1 Function Syntax Rules",
    "text": "28.1 Function Syntax Rules\nAt the core, a Vimscript function has the following syntax:\nfunction {FunctionName}()\n  {do-something}\nendfunction\nA function definition must start with a capital letter. It starts with the function keyword and ends with endfunction. Below is a valid function:\nfunction! Tasty()\n  echo \"Tasty\"\nendfunction\nThe following is not a valid function because it does not start with a capital letter.\nfunction tasty()\n  echo \"Tasty\"\nendfunction\nIf you prepend a function with the script variable (s:), you can use it with a lower case. function s:tasty() is a valid name. The reason why Vim requires you to use an uppercase name is to prevent confusion with Vim’s built-in functions (all lowercase).\nA function name cannot start with a number. 1Tasty() is not a valid function name, but Tasty1() is. A function also cannot contain non-alphanumeric characters besides _. Tasty-food(), Tasty&food(), and Tasty.food() are not valid function names. Tasty_food() is.\nIf you define two functions with the same name, Vim will throw an error complaining that the function Tasty already exists. To overwrite the previous function with the same name, add a ! after the function keyword.\nfunction! Tasty()\n  echo \"Tasty\"\nendfunction"
  },
  {
    "objectID": "chapters/ch28_vimscript_functions.md.html#listing-available-functions",
    "href": "chapters/ch28_vimscript_functions.md.html#listing-available-functions",
    "title": "28  Ch28. Vimscript Functions",
    "section": "28.2 Listing Available Functions",
    "text": "28.2 Listing Available Functions\nTo see all the built-in and custom functions in Vim, you can run :function command. To look at the content of the Tasty function, you can run :function Tasty.\nYou can also search for functions with pattern with :function /pattern, similar to Vim’s search navigation (/pattern). To search for all function containing the phrase map, run :function /map. If you use external plugins, Vim will display the functions defined in those plugins.\nIf you want to look at where a function originates, you can use the :verbose command with the :function command. To look at where all the functions containing the word map are originated, run:\n:verbose function /map\nWhen I ran it, I got a number of results. This one tells me that the function fzf#vim#maps autoload function (to recap, refer to Ch. 23) is written inside ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim file, on line 1263. This is useful for debugging.\nfunction fzf#vim#maps(mode, ...)\n        Last set from ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 1263"
  },
  {
    "objectID": "chapters/ch28_vimscript_functions.md.html#removing-a-function",
    "href": "chapters/ch28_vimscript_functions.md.html#removing-a-function",
    "title": "28  Ch28. Vimscript Functions",
    "section": "28.3 Removing a Function",
    "text": "28.3 Removing a Function\nTo remove an existing function, use :delfunction {Function_name}. To delete Tasty, run :delfunction Tasty."
  },
  {
    "objectID": "chapters/ch28_vimscript_functions.md.html#function-return-value",
    "href": "chapters/ch28_vimscript_functions.md.html#function-return-value",
    "title": "28  Ch28. Vimscript Functions",
    "section": "28.4 Function Return Value",
    "text": "28.4 Function Return Value\nFor a function to return a value, you need to pass it an explicit return value. Otherwise, Vim automatically returns an implicit value of 0.\nfunction! Tasty()\n  echo \"Tasty\"\nendfunction\nAn empty return is also equivalent to a 0 value.\nfunction! Tasty()\n  echo \"Tasty\"\n  return\nendfunction\nIf you run :echo Tasty() using the function above, after Vim displays Tasty, it returns 0, the implicit return value. To make Tasty() to return Tasty value, you can do this:\nfunction! Tasty()\n  return \"Tasty\"\nendfunction\nNow when you run :echo Tasty(), it returns Tasty string.\nYou can use a function inside an expression. Vim will use the return value of that function. The expression :echo Tasty() . \" Food!\" outputs Tasty Food!"
  },
  {
    "objectID": "chapters/ch28_vimscript_functions.md.html#formal-arguments",
    "href": "chapters/ch28_vimscript_functions.md.html#formal-arguments",
    "title": "28  Ch28. Vimscript Functions",
    "section": "28.5 Formal Arguments",
    "text": "28.5 Formal Arguments\nTo pass a formal argument food to your Tasty function, you can do this:\nfunction! Tasty(food)\n  return \"Tasty \" . a:food\nendfunction\n\necho Tasty(\"pastry\")\n\" returns \"Tasty pastry\"\na: is one of the variable scopes mentioned in the last chapter. It is the formal parameter variable. It is Vim’s way to get a formal parameter value in a function. Without it, Vim will throw an error:\nfunction! Tasty(food)\n  return \"Tasty \" . food\nendfunction\n\necho Tasty(\"pasta\")\n\" returns \"undefined variable name\" error"
  },
  {
    "objectID": "chapters/ch28_vimscript_functions.md.html#function-local-variable",
    "href": "chapters/ch28_vimscript_functions.md.html#function-local-variable",
    "title": "28  Ch28. Vimscript Functions",
    "section": "28.6 Function Local Variable",
    "text": "28.6 Function Local Variable\nLet’s address the other variable you didn’t learn on the previous chapter: the function local variable (l:).\nWhen writing a function, you can define a variable inside:\nfunction! Yummy()\n  let location = \"tummy\"\n  return \"Yummy in my \" . location\nendfunction\n\necho Yummy()\n\" returns \"Yummy in my tummy\"\nIn this context, the variable location is the same as l:location. When you define a variable in a function, that variable is local to that function. When a user sees location, it could easily be mistaken as a global variable. I prefer to be more verbose than not, so I prefer to put l: to indicate that this is a function variable.\nAnother reason to use l:count is that Vim has special variables with aliases that look like regular variables. v:count is one example. It has an alias of count. In Vim, calling count is the same as calling v:count. It is easy to accidentally call one of those special variables.\nfunction! Calories()\n  let count = \"count\"\n  return \"I do not \" . count . \" my calories\"\nendfunction\n\necho Calories()\n\" throws an error\nThe execution above throws an error because let count = \"Count\" implicitly attempts to redefine Vim’s special variable v:count. Recall that special variables (v:) are read-only. You cannot mutate it. To fix it, use l:count:\nfunction! Calories()\n  let l:count = \"count\"\n  return \"I do not \" . l:count . \" my calories\"\nendfunction\n\necho Calories()\n\" returns \"I do not count my calories\""
  },
  {
    "objectID": "chapters/ch28_vimscript_functions.md.html#calling-a-function",
    "href": "chapters/ch28_vimscript_functions.md.html#calling-a-function",
    "title": "28  Ch28. Vimscript Functions",
    "section": "28.7 Calling a Function",
    "text": "28.7 Calling a Function\nVim has a :call command to call a function.\nfunction! Tasty(food)\n  return \"Tasty \" . a:food\nendfunction\n\ncall Tasty(\"gravy\")\nThe call command does not output the return value. Let’s call it with echo.\necho call Tasty(\"gravy\")\nWoops, you get an error. The call command above is a command-line command (:call). The echo command above is also a command-line command (:echo). You cannot call a command-line command with another command-line command. Let’s try a different flavor of the call command:\necho call(\"Tasty\", [\"gravy\"])\n\" returns \"Tasty gravy\"\nTo clear any confusion, you have just used two different call commands: the :call command-line command and the call() function. The call() function accepts as its first argument the function name (string) and its second argument the formal parameters (list).\nTo learn more about :call and call(), check out :h call() and :h :call."
  },
  {
    "objectID": "chapters/ch28_vimscript_functions.md.html#default-argument",
    "href": "chapters/ch28_vimscript_functions.md.html#default-argument",
    "title": "28  Ch28. Vimscript Functions",
    "section": "28.8 Default Argument",
    "text": "28.8 Default Argument\nYou can provide a function parameter with a default value with =. If you call Breakfast with only one argument, the beverage argument will use the milk default value.\nfunction! Breakfast(meal, beverage = \"Milk\")\n  return \"I had \" . a:meal . \" and \" . a:beverage . \" for breakfast\"\nendfunction\n\necho Breakfast(\"Hash Browns\")\n\" returns I had hash browns and milk for breakfast\n\necho Breakfast(\"Cereal\", \"Orange Juice\")\n\" returns I had Cereal and Orange Juice for breakfast"
  },
  {
    "objectID": "chapters/ch28_vimscript_functions.md.html#variable-arguments",
    "href": "chapters/ch28_vimscript_functions.md.html#variable-arguments",
    "title": "28  Ch28. Vimscript Functions",
    "section": "28.9 Variable Arguments",
    "text": "28.9 Variable Arguments\nYou can pass a variable argument with three-dots (...). Variable argument is useful when you don’t know how many variables a user will give.\nSuppose you are creating an all-you-can-eat buffet (you’ll never know how much food your customer will eat):\nfunction! Buffet(...)\n  return a:1\nendfunction\nIf you run echo Buffet(\"Noodles\"), it will output Noodles. Vim uses a:1 to print the first argument passed to ..., up to 20 (a:1 is the first argument, a:2 is the second argument, etc). If you run echo Buffet(\"Noodles\", \"Sushi\"), it will still display just Noodles, let’s update it:\nfunction! Buffet(...)\n  return a:1 . \" \" . a:2\nendfunction\n\necho Buffet(\"Noodles\", \"Sushi\")\n\" returns \"Noodles Sushi\"\nThe problem with this approach is if you now run echo Buffet(\"Noodles\") (with only one variable), Vim complains that it has an undefined variable a:2. How can you make it flexible enough to display exactly what the user gives?\nLuckily, Vim has a special variable a:0 to display the number of the arguments passed into ....\nfunction! Buffet(...)\n  return a:0\nendfunction\n\necho Buffet(\"Noodles\")\n\" returns 1\n\necho Buffet(\"Noodles\", \"Sushi\")\n\" returns 2\n\necho Buffet(\"Noodles\", \"Sushi\", \"Ice cream\", \"Tofu\", \"Mochi\")\n\" returns 5\nWith this, you can iterate using the length of the argument.\nfunction! Buffet(...)\n  let l:food_counter = 1\n  let l:foods = \"\"\n  while l:food_counter <= a:0\n    let l:foods .= a:{l:food_counter} . \" \"\n    let l:food_counter += 1\n  endwhile\n  return l:foods\nendfunction\nThe curly braces a:{l:food_counter} is a string interpolation, it uses the value of food_counter counter to call the formal parameter arguments a:1, a:2, a:3, etc.\necho Buffet(\"Noodles\")\n\" returns \"Noodles\"\n\necho Buffet(\"Noodles\", \"Sushi\", \"Ice cream\", \"Tofu\", \"Mochi\")\n\" returns everything you passed: \"Noodles Sushi Ice cream Tofu Mochi\"\nThe variable argument has one more special variable: a:000. It has the value of all variable arguments in a list format.\nfunction! Buffet(...)\n  return a:000\nendfunction\n\necho Buffet(\"Noodles\")\n\" returns [\"Noodles\"]\n\necho Buffet(\"Noodles\", \"Sushi\", \"Ice cream\", \"Tofu\", \"Mochi\")\n\" returns [\"Noodles\", \"Sushi\", \"Ice cream\", \"Tofu\", \"Mochi\"]\nLet’s refactor the function to use a for loop:\nfunction! Buffet(...)\n  let l:foods = \"\"\n  for food_item in a:000\n    let l:foods .= food_item . \" \"\n  endfor\n  return l:foods\nendfunction\n\necho Buffet(\"Noodles\", \"Sushi\", \"Ice cream\", \"Tofu\", \"Mochi\")\n\" returns Noodles Sushi Ice cream Tofu Mochi"
  },
  {
    "objectID": "chapters/ch28_vimscript_functions.md.html#range",
    "href": "chapters/ch28_vimscript_functions.md.html#range",
    "title": "28  Ch28. Vimscript Functions",
    "section": "28.10 Range",
    "text": "28.10 Range\nYou can define a ranged Vimscript function by adding a range keyword at the end of the function definition. A ranged function has two special variables available: a:firstline and a:lastline.\nfunction! Breakfast() range\n  echo a:firstline\n  echo a:lastline\nendfunction\nIf you are on line 100 and you run call Breakfast(), it will display 100 for both firstline and lastline. If you visually highlight (v, V, or Ctrl-V) lines 101 to 105 and run call Breakfast(), firstline displays 101 and lastline displays 105. firstline and lastline displays the minimum and maximum range where the function is called.\nYou can also use :call and passing it a range. If you run :11,20call Breakfast(), it will display 11 for firstline and 20 for lastline.\nYou might ask, That’s nice that Vimscript function accepts range, but can’t I get the line number with line(\".\")? Won’t it do the same thing?\nGood question. If this is what you mean:\nfunction! Breakfast()\n  echo line(\".\")\nendfunction\nCalling :11,20call Breakfast() executes the Breakfast function 10 times (one for each line in the range). Compare that if you had passed the range argument:\nfunction! Breakfast() range\n  echo line(\".\")\nendfunction\nCalling 11,20call Breakfast() executes the Breakfast function once.\nIf you pass a range keyword and you pass a numerical range (like 11,20) on call, Vim only executes that function once. If you don’t pass a range keyword and you pass a numerical range (like 11,20) on call, Vim executes that function N times depending on the range (in this case, N = 10)."
  },
  {
    "objectID": "chapters/ch28_vimscript_functions.md.html#dictionary",
    "href": "chapters/ch28_vimscript_functions.md.html#dictionary",
    "title": "28  Ch28. Vimscript Functions",
    "section": "28.11 Dictionary",
    "text": "28.11 Dictionary\nYou can add a function as a dictionary item by adding a dict keyword when defining a function.\nIf you have a function SecondBreakfast that returns whatever breakfast item you have:\nfunction! SecondBreakfast() dict\n  return self.breakfast\nendfunction\nLet’s add this function to the meals dictionary:\nlet meals = {\"breakfast\": \"pancakes\", \"second_breakfast\": function(\"SecondBreakfast\"), \"lunch\": \"pasta\"}\n\necho meals.second_breakfast()\n\" returns \"pancakes\"\nWith dict keyword, the key variable self refers to the dictionary where the function is stored (in this case, the meals dictionary). The expression self.breakfast is equal to meals.breakfast.\nAn alternative way to add a function into a dictionary object to use a namespace.\nfunction! meals.second_lunch()\n  return self.lunch\nendfunction\n\necho meals.second_lunch()\n\" returns \"pasta\"\nWith namespace, you do not have to use the dict keyword."
  },
  {
    "objectID": "chapters/ch28_vimscript_functions.md.html#funcref",
    "href": "chapters/ch28_vimscript_functions.md.html#funcref",
    "title": "28  Ch28. Vimscript Functions",
    "section": "28.12 Funcref",
    "text": "28.12 Funcref\nA funcref is a reference to a function. It is one of Vimscript’s basic data types mentioned in Ch. 24.\nThe expression function(\"SecondBreakfast\") above is an example of funcref. Vim has a built-in function function() that returns a funcref when you pass it a function name (string).\nfunction! Breakfast(item)\n  return \"I am having \" . a:item . \" for breakfast\"\nendfunction\n\nlet Breakfastify = Breakfast\n\" returns error\n\nlet Breakfastify = function(\"Breakfast\")\n\necho Breakfastify(\"oatmeal\")\n\" returns \"I am having oatmeal for breakfast\"\n\necho Breakfastify(\"pancake\")\n\" returns \"I am having pancake for breakfast\"\nIn Vim, if you want to assign a function to a variable, you can’t just run assign it directly like let MyVar = MyFunc. You need to use the function() function, like let MyVar = function(\"MyFunc\").\nYou can use funcref with maps and filters. Note that maps and filters will pass an index as the first argument and the iterated value as the second argument.\nfunction! Breakfast(index, item)\n  return \"I am having \" . a:item . \" for breakfast\"\nendfunction\n\nlet breakfast_items = [\"pancakes\", \"hash browns\", \"waffles\"]\nlet first_meals = map(breakfast_items, function(\"Breakfast\"))\n\nfor meal in first_meals\n  echo meal\nendfor"
  },
  {
    "objectID": "chapters/ch28_vimscript_functions.md.html#lambda",
    "href": "chapters/ch28_vimscript_functions.md.html#lambda",
    "title": "28  Ch28. Vimscript Functions",
    "section": "28.13 Lambda",
    "text": "28.13 Lambda\nA better way to use functions in maps and filters is to use lambda expression (sometimes known as unnamed function). For example:\nlet Plus = {x,y -> x + y}\necho Plus(1,2)\n\" returns 3\n\nlet Tasty = { -> 'tasty'}\necho Tasty()\n\" returns \"tasty\"\nYou can call a function from insisde a lambda expression:\nfunction! Lunch(item)\n  return \"I am having \" . a:item . \" for lunch\"\nendfunction\n\nlet lunch_items = [\"sushi\", \"ramen\", \"sashimi\"]\n\nlet day_meals = map(lunch_items, {index, item -> Lunch(item)})\n\nfor meal in day_meals\n  echo meal\nendfor\nIf you don’t want to call the function from inside lambda, you can refactor it:\nlet day_meals = map(lunch_items, {index, item -> \"I am having \" . item . \" for lunch\"})"
  },
  {
    "objectID": "chapters/ch28_vimscript_functions.md.html#method-chaining",
    "href": "chapters/ch28_vimscript_functions.md.html#method-chaining",
    "title": "28  Ch28. Vimscript Functions",
    "section": "28.14 Method Chaining",
    "text": "28.14 Method Chaining\nYou can chain several Vimscript functions and lambda expressions sequentially with ->. Keep in mind that -> must be followed by a method name without space.\nSource->Method1()->Method2()->...->MethodN()\nTo convert a float to a number using method chaining:\necho 3.14->float2nr()\n\" returns 3\nLet’s do a more complicated example. Suppose that you need to capitalize the first letter of each item on a list, then sort the list, then join the list to form a string.\nfunction! Capitalizer(word)\n  return substitute(a:word, \"\\^\\.\", \"\\\\u&\", \"g\")\nendfunction\n\nfunction! CapitalizeList(word_list)\n  return map(a:word_list, {index, word -> Capitalizer(word)})\nendfunction\n\nlet dinner_items = [\"bruschetta\", \"antipasto\", \"calzone\"]\n\necho dinner_items->CapitalizeList()->sort()->join(\", \")\n\" returns \"Antipasto, Bruschetta, Calzone\"\nWith method chaining, the sequence is more easily read and understood. I can just glance at dinner_items->CapitalizeList()->sort()->join(\", \") and know exactly what is going on."
  },
  {
    "objectID": "chapters/ch28_vimscript_functions.md.html#closure",
    "href": "chapters/ch28_vimscript_functions.md.html#closure",
    "title": "28  Ch28. Vimscript Functions",
    "section": "28.15 Closure",
    "text": "28.15 Closure\nWhen you define a variable inside a function, that variable exists within that function boundaries. This is called a lexical scope.\nfunction! Lunch()\n  let appetizer = \"shrimp\"\n\n  function! SecondLunch()\n    return appetizer\n  endfunction\n\n  return funcref(\"SecondLunch\")\nendfunction\nappetizer is defined inside the Lunch function, which returns SecondLunch funcref. Notice that SecondLunch uses the appetizer, but in Vimscript, it doesn’t have access to that variable. If you try to run echo Lunch()(), Vim will throw an undefined variable error.\nTo fix this issue, use the closure keyword. Let’s refactor:\nfunction! Lunch()\n  let appetizer = \"shrimp\"\n\n  function! SecondLunch() closure\n    return appetizer\n  endfunction\n\n  return funcref(\"SecondLunch\")\nendfunction\nNow if you run echo Lunch()(), Vim will return shrimp."
  },
  {
    "objectID": "chapters/ch28_vimscript_functions.md.html#learn-vimscript-functions-the-smart-way",
    "href": "chapters/ch28_vimscript_functions.md.html#learn-vimscript-functions-the-smart-way",
    "title": "28  Ch28. Vimscript Functions",
    "section": "28.16 Learn Vimscript Functions the Smart Way",
    "text": "28.16 Learn Vimscript Functions the Smart Way\nIn this chapter, you learned the anatomy of Vim function. You learned how to use different special keywords range, dict, and closure to modify function behavior. You also learned how to use lambda and to chain multiple functions together. Functions are important tools for creating complex abstractions.\nNext, let’s put everything that you have learned together to make your own plugin."
  },
  {
    "objectID": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#the-problem",
    "href": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#the-problem",
    "title": "29  Ch29. Write a Plugin: Creating a Titlecase Operator",
    "section": "29.1 The Problem",
    "text": "29.1 The Problem\nI use Vim to write my articles, including this very guide.\nOne main issue was to create a proper title case for the headings. One way to automate this is to capitalize each word in the header with g/^#/ s/\\<./\\u\\0/g. For basic use, this command was good enough, but it is still not as good as having an actual title case. The words The and Of in Capitalize The First Letter Of Each Word should be capitalized. Without a proper capitalization, the sentence looks slightly off.\nAt first, I wasn’t planning to write a plugin. Also it turns out that there is a titlecase plugin already: vim-titlecase. However, there were a few things that didn’t function quite the way I wanted them to. The main one was the blockwise visual mode behavior. If I have the phrase:\ntest title one\ntest title two\ntest title three\nIf I use a block visual highlight on the tle:\ntest ti[tle] one\ntest ti[tle] two\ntest ti[tle] three\nIf I press gt, the plugin won’t capitalize it. I find it inconsistent with the behaviors of gu, gU, and g~. So I decided to work off from that titlecase plugin repo and use that to a titlecase plugin myself that is consistent with gu, gU, and g~!. Again, the vim-titlecase plugin itself is an excellent plugin and worthy to be used on its own (the truth is, maybe deep down I just wanted to write my own Vim plugin. I can’t really see the blockwise titlecasing feature to be used that often in real life other than edge cases).\n\n29.1.1 Planning for the Plugin\nBefore writing the first line of code, I need to decide what the titlecase rules are. I found a neat table of different capitalization rules from the titlecaseconverter site. Did you know that there are at least 8 different capitalization rules in English language? Gasp!\nIn the end, I used the common denominators from that list to come up with a good enough basic rule for the plugin. Plus I doubt people will complain, Hey man, you’re using AMA, why aren’t you using APA?. Here are the basic rules: - First word is always uppercased. - Some adverbs, conjunctions, and prepositions are lowercased. - If the input word is totally uppercased, then don’t do anything (it could be an abbreviation).\nAs for which words are lowercased, different rules have different lists. I decided to stick with a an and at but by en for in nor of off on or out per so the to up yet vs via.\n\n\n29.1.2 Planning for the User Interface\nI want the plugin to be an operator to complement Vim’s existing case operators: gu, gU, and g~. Being an operator, it must accept either a motion or a text object (gtw should titlecase the next word, gtiw should titlecase the inner word, gt$ should titlecase the words from the current location until the end of the line, gtt should titlecase the current line, gti( should titlecase the words inside parentheses, etc). I also want it to be mapped to gt for easy mnemonics. Moreover, it should also work with all visual modes: v, V, and Ctrl-V. I should be able to highlight it in any visual mode, press gt, then all the highlighted texts will be titlecased."
  },
  {
    "objectID": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#vim-runtime",
    "href": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#vim-runtime",
    "title": "29  Ch29. Write a Plugin: Creating a Titlecase Operator",
    "section": "29.2 Vim Runtime",
    "text": "29.2 Vim Runtime\nThe first thing you see when you look at the repo is that it has two directories: plugin/ and doc/. When you start Vim, it looks for special files and directories inside the ~/.vim directory and runs all script files inside that directory. For more, review the Vim Runtime chapter.\nThe plugin utilizes two Vim runtime directories: doc/ and plugin/. doc/ is a place to put the help documentation (so you can search for keywords later, like :h totitle). I’ll go over how to create a help page later. For now, let’s focus on plugin/. The plugin/ directory is executed once when Vim boots up. There is one file inside this directory: totitle.vim. The naming doesn’t matter (I could’ve named it whatever.vim and it would still work). All the code responsible for the plugin to work is inside this file."
  },
  {
    "objectID": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#mappings",
    "href": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#mappings",
    "title": "29  Ch29. Write a Plugin: Creating a Titlecase Operator",
    "section": "29.3 Mappings",
    "text": "29.3 Mappings\nLet’s go through the code!\nAt the start of the file, you have:\nif !exists('g:totitle_default_keys')\n  let g:totitle_default_keys = 1\nendif\nWhen you start Vim, g:totitle_default_keys won’t exist yet, so !exists(...) returns true. In that case, define g:totitle_default_keys to equal 1. In Vim, 0 is falsy and non-zero is truthy (use 1 to indicate truthy).\nLet’s jump to the bottom of the file. You’ll see this:\nif g:totitle_default_keys\n  nnoremap <expr> gt ToTitle()\n  xnoremap <expr> gt ToTitle()\n  nnoremap <expr> gtt ToTitle() .. '_'\nendif\nThis is where the main gt mapping is defined. In this case, by the time you get to the if conditionals at the bottom of the file, if g:totitle_default_keys would return 1 (truthy), so Vim performs the following maps: - nnoremap <expr> gt ToTitle() maps the normal mode operator. This lets you run operator + motion/text-object like gtw to titlecase the next word or gtiw to titlecase the inner word. I will go over the details of how the operator mapping works later. - xnoremap <expr> gt ToTitle() maps the visual mode operators. This lets you to titlecase the texts that are visually highlighted. - nnoremap <expr> gtt ToTitle() .. '_' maps the normal mode linewise operator (analogous to guu and gUU). You may wonder what .. '_' does at the end. .. is Vim’s string interpolation operator. _ is used as a motion with an operator. If you look in :help _, it says that the underscore is used to count 1 line downward. It performs an operator on the current line (try it with other operators, try running gU_ or d_, notice that it does the same as gUU or dd). - Finally, the <expr> argument allows you to specify the count, so you can do 3gtw to togglecase the next 3 words.\nWhat if you don’t want to use the default gt mapping? Afterall, you are overriding Vim’s default gt (tab next) mapping. What if you want to use gz instead of gt? Remember earlier how you went through the trouble of checking if !exists('g:totitle_default_keys') and if g:totitle_default_keys? If you put let g:totitle_default_keys = 0 in your vimrc, then g:totitle_default_keys would already exist when the plugin is run (codes in your vimrc are executed before the plugin/ runtime files), so !exists('g:totitle_default_keys') returns false. Furthermore, if g:totitle_default_keys would be falsy (because it would have the value of 0), so it also won’t perform the gt mapping! This effectively lets you define your own custom mapping in Vimrc.\nTo define your own titlecase mapping to gz, add this in your vimrc:\nlet g:totitle_default_keys = 0\n\nnnoremap <expr> gz ToTitle()\nxnoremap <expr> gz ToTitle()\nnnoremap <expr> gzz ToTitle() .. '_'\nEasy peasy."
  },
  {
    "objectID": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#the-totitle-function",
    "href": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#the-totitle-function",
    "title": "29  Ch29. Write a Plugin: Creating a Titlecase Operator",
    "section": "29.4 The ToTitle Function",
    "text": "29.4 The ToTitle Function\nThe ToTitle() function is easily the longest function in this file.\n function! ToTitle(type = '')\n  if a:type ==# ''\n    set opfunc=ToTitle\n    return 'g@'\n  endif\n\n  \" invoke this when calling the ToTitle() function\n  if a:type != 'block' && a:type != 'line' && a:type != 'char'\n    let l:words = a:type\n    let l:wordsArr = trim(l:words)->split('\\s\\+')\n    call map(l:wordsArr, 's:capitalize(v:val)')\n    return l:wordsArr->join(' ')\n  endif\n\n  \" save the current settings\n  let l:sel_save = &selection\n  let l:reg_save = getreginfo('\"')\n  let l:cb_save = &clipboard\n  let l:visual_marks_save = [getpos(\"'<\"), getpos(\"'>\")]\n\n  try\n    set clipboard= selection=inclusive\n    let l:commands = #{line: \"'[V']y\", char: \"`[v`]y\", block: \"`[\\<c-v>`]y\"}\n\n    silent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')\n    let l:selected_phrase = getreg('\"')\n    let l:WORD_PATTERN = '\\<\\k*\\>'\n    let l:UPCASE_REPLACEMENT = '\\=s:capitalize(submatch(0))'\n\n    let l:startLine = line(\"'<\")\n    let l:startCol = virtcol(\".\")\n\n    \" when user calls a block operation\n    if a:type ==# \"block\"\n      sil! keepj norm! gv\"ad\n      keepj $\n      keepj pu_\n\n      let l:lastLine = line(\"$\")\n\n      sil! keepj norm \"ap\n\n      let l:curLine = line(\".\")\n\n      sil! keepj norm! VGg@\n      exe \"keepj norm! 0\\<c-v>G$h\\\"ad\"\n      exe \"keepj \" . l:startLine\n      exe \"sil! keepj norm! \" . l:startCol . \"\\<bar>\\\"aP\"\n      exe \"keepj \" . l:lastLine\n      sil! keepj norm! \"_dG\n      exe \"keepj \" . l:startLine\n      exe \"sil! keepj norm! \" . l:startCol . \"\\<bar>\"\n\n    \" when user calls a char or line operation\n    else\n      let l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')\n      let l:titlecased = s:capitalizeFirstWord(l:titlecased)\n      call setreg('\"', l:titlecased)\n      let l:subcommands = #{line: \"'[V']p\", char: \"`[v`]p\", block: \"`[\\<c-v>`]p\"}\n      silent execute \"noautocmd keepjumps normal! \" .. get(l:subcommands, a:type, \"\")\n      exe \"keepj \" . l:startLine\n      exe \"sil! keepj norm! \" . l:startCol . \"\\<bar>\"\n    endif\n  finally\n\n    \" restore the settings\n    call setreg('\"', l:reg_save)\n    call setpos(\"'<\", l:visual_marks_save[0])\n    call setpos(\"'>\", l:visual_marks_save[1])\n    let &clipboard = l:cb_save\n    let &selection = l:sel_save\n  endtry\n  return\nendfunction\nThis is very long, so let’s break it apart.\nI could refactor this into smaller sections, but for the sake of completing this chapter, I just left it as is."
  },
  {
    "objectID": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#the-operator-function",
    "href": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#the-operator-function",
    "title": "29  Ch29. Write a Plugin: Creating a Titlecase Operator",
    "section": "29.5 The Operator Function",
    "text": "29.5 The Operator Function\nHere is the first part of the code:\nif a:type ==# ''\n  set opfunc=ToTitle\n  return 'g@'\nendif\nWhat the heck is opfunc? Why is it returning g@?\nVim has a special operator, the operator function, g@. This operator lets you to use any function assigned to the opfunc option. If I have the function Foo() assigned to opfunc, then when I run g@w, I am running Foo() on the next word. If I run g@i(, then I’m running Foo() on the inner parentheses. This operator function is critical to create your own Vim operator.\nThe following line assigns the opfunc to the ToTitle function.\nset opfunc=ToTitle\nThe next line is literally returning g@:\nreturn g@\nSo exactly how do these two lines work and why is it returning g@?\nLet’s assume that you have the following map:\nnnoremap <expr> gt ToTitle()`\nThen you press gtw (titlecase the next word). The first time you run gtw, Vim calls the ToTitle() method. But right now opfunc is still blank. You are also not passing any argument to ToTitle(), so it will have a:type value of ''. This causes the conditional expression to check the argument a:type, if a:type ==# '', to be truthy. Inside, you assign opfunc to the ToTitle function with set opfunc=ToTitle. Now opfunc is assigned to ToTitle. Finally, after you assigned opfunc to the ToTitle function, you return g@. I will explain why it returns g@ below.\nYou are not done yet. Remember, you just pressed gtw. Pressing gt did all of the things above, but you still have w to process. By returning g@, at this point, you now technically have g@w (this is why you have return g@). Since g@ is the function operator, you are passing to it the w motion. So Vim, upon receiving g@w, calls the ToTitle one more time (don’t worry, you won’t end up with an infinite loop as you will see in a little bit).\nTo recap, by pressing gtw, Vim checks if opfunc is empty or not. If it is empty, then Vim will assign it with ToTitle. Then it returns g@, essentially calling the ToTitle again one more time so you can now use it as an operator. This is the trickiest part of creating a custom operator and you did it! Next, you need to build the logic for ToTitle() to actually titlecase the input."
  },
  {
    "objectID": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#processing-the-input",
    "href": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#processing-the-input",
    "title": "29  Ch29. Write a Plugin: Creating a Titlecase Operator",
    "section": "29.6 Processing the Input",
    "text": "29.6 Processing the Input\nYou now have gt functioning as an operator that executes ToTitle(). But what do you do next? How do you actually titlecase the text?\nWhenever you run any operator in Vim, there are three different action motion types: character, line, and block. g@w (word) is an example of a character operation. g@j (one line below) is an example of a line operation. Block operation is rare, but typically when you do Ctrl-V (visual block) operation, it will be counted as a block operation. Operations that target a few characters forward / backward are generally considered character operations (b, e, w, ge, etc). Operations that target a few lines downward / upward are generally considered line operations (j, k). Operations that target columns forward, backward, upward, or downward are generally considered block operations (they are usually either a columnar forced-motion or a blockwise visual mode; for more: :h forced-motion).\nThis means, if you press g@w, g@ will pass a literal string \"char\" as an argument to ToTitle(). If you do g@j, g@ will pass a literal string \"line\" as an argument to ToTitle(). This string is what will be passed into the ToTitle function as the type argument."
  },
  {
    "objectID": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#creating-your-own-custom-function-operator",
    "href": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#creating-your-own-custom-function-operator",
    "title": "29  Ch29. Write a Plugin: Creating a Titlecase Operator",
    "section": "29.7 Creating Your Own Custom Function Operator",
    "text": "29.7 Creating Your Own Custom Function Operator\nLet’s pause and play with g@ by writing a dummy function:\nfunction! Test(some_arg)\n  echom a:some_arg \nendfunction\nNow assign that function to opfunc by running:\n:set opfunc=Test\nThe g@ operator will execute Test(some_arg) and passes it with either \"char\", \"line\", or \"block\" depending on what operation you do. Run different operations like g@iw (inner word), g@j (one line below), g@$ (to the end of the line), etc. See what different values are being echoed. To test the block operation, you can use Vim’s forced motion for block operations: g@Ctrl-Vj (block operation one column below).\nYou can also use it with the visual mode. Use the various visual highlights like v, V, and Ctrl-V then press g@ (be warned, it will flash the output echo really quickly, so you need to have a quick eye - but the echo is definitely there. Also, since you are using echom, you can check the recorded echo messages with :messages).\nPretty cool, isn’t it? The things you can program with Vim! Why didn’t they teach this at school? Let’s continue with our plugin."
  },
  {
    "objectID": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#totitle-as-a-function",
    "href": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#totitle-as-a-function",
    "title": "29  Ch29. Write a Plugin: Creating a Titlecase Operator",
    "section": "29.8 ToTitle As a Function",
    "text": "29.8 ToTitle As a Function\nMoving on to the next few lines:\nif a:type != 'block' && a:type != 'line' && a:type != 'char'\n  let l:words = a:type\n  let l:wordsArr = trim(l:words)->split('\\s\\+')\n  call map(l:wordsArr, 's:capitalize(v:val)')\n  return l:wordsArr->join(' ')\nendif\nThis line actually has nothing to do with ToTitle() behavior an operator, but to enable it into a callable TitleCase function (yes, I know that I am violating the Single Responsibility Principle). The motivation is, Vim has native toupper() and tolower() functions that will uppercase and lowercase any given string. Ex: :echo toupper('hello') returns 'HELLO' and :echo tolower('HELLO') returns 'hello'. I want this plugin to have the ability to run ToTitle so you can do :echo ToTitle('once upon a time') and get a 'Once Upon a Time' return value.\nBy now, you know that when you are calling ToTitle(type) with g@, the type argument will have a value of either 'block', 'line', or 'char’. If the argument is neither 'block' nor 'line' nor 'char', you can safely assume that ToTitle() is being called outside of g@. In that case, you split them by whitespaces (\\s\\+) with:\nlet l:wordsArr = trim(l:words)->split('\\s\\+')\nThen capitalize each element:\ncall map(l:wordsArr, 's:capitalize(v:val)')\nBefore joining them back together:\nl:wordsArr->join(' ')\nThe capitalize() function will be covered later."
  },
  {
    "objectID": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#temporary-variables",
    "href": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#temporary-variables",
    "title": "29  Ch29. Write a Plugin: Creating a Titlecase Operator",
    "section": "29.9 Temporary Variables",
    "text": "29.9 Temporary Variables\nThe next few lines:\nlet l:sel_save = &selection\nlet l:reg_save = getreginfo('\"')\nlet l:cb_save = &clipboard\nlet l:visual_marks_save = [getpos(\"'<\"), getpos(\"'>\")]\nThese lines preserve various current states into temporary variables. Later in this you will use visual modes, marks, and registers. Doing these will tamper with the a few states. Since you don’t want to revise the history, you need to save them into temporary variables so you can restore the states later."
  },
  {
    "objectID": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#capitalizing-the-selections",
    "href": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#capitalizing-the-selections",
    "title": "29  Ch29. Write a Plugin: Creating a Titlecase Operator",
    "section": "29.10 Capitalizing the Selections",
    "text": "29.10 Capitalizing the Selections\nThe next lines are important:\ntry\n  set clipboard= selection=inclusive\n  let l:commands = #{line: \"'[V']y\", char: \"`[v`]y\", block: \"`[\\<c-v>`]y\"}\n\n  silent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')\n  let l:selected_phrase = getreg('\"')\n  let l:WORD_PATTERN = '\\<\\k*\\>'\n  let l:UPCASE_REPLACEMENT = '\\=s:capitalize(submatch(0))'\n\n  let l:startLine = line(\"'<\")\n  let l:startCol = virtcol(\".\")\n\nLet’s go through them in small chunks. This line:\nset clipboard= selection=inclusive\nYou first set the selection option to be inclusive and the clipboard to be empty. The selection attribute is typically used with the visual mode and there are three possible values: old, inclusive, and exclusive. Setting it to be inclusive means that the last character of the selection is included. I won’t cover them here, but the point is that choosing it to be inclusive makes it behave consistently in visual mode. By default Vim sets it to inclusive, but you set it here anyway just in case one of your plugins sets it to a different value. Check out :h 'clipboard' and :h 'selection' if you’re curious what they really do.\nNext you have this weird-looking hash followed by an execute command:\nlet l:commands = #{line: \"'[V']y\", char: \"`[v`]y\", block: \"`[\\<c-v>`]y\"}\nsilent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')\nFirst, the #{} syntax is Vim’s dictionary data type. The local variable l:commands is a hash with lines, char, and block as its keys. The command silent exe '...' executes whatever command inside the string silently (otherwise it will display notifications to the bottom of your screen).\nSecond, the executed commands are 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, ''). The first one, noautocmd, will execute the subsequent command without triggering any autocommand. The second one, keepjumps, is to not record the cursor movement while moving. In Vim, certain motions are automatically recorded in the change list, the jump list, and the mark list. This prevents that. The point of having noautocmd and keepjumps is to prevent side effects. Finally, the normal command executes the strings as normal commands. The .. is Vim’s string interpolation syntax. get() is a getter method that accepts either a list, blob, or dictionary. In this case, you are passing it the dictionary l:commands. The key is a:type. You learned earlier that a:type is either one of the three string values: char, line, or block. So if a:type is line, you will be executing \"noautocmd keepjumps normal! '[V']y\" (for more, check out :h silent, :h :exe, :h :noautocmd, :h :keepjumps, :h :normal, and :h get()).\nLet’s go over what '[V']y does. First assume that you have this body of text:\nthe second breakfast\nis better than the first breakfast\nAssume that your cursor is on the first line. Then you press g@j (run the operator function, g@, one line below, with j). '[ moves the cursor to the start of the previously changed or yanked text. Although you technically didn’t change or yank any text with g@j, Vim remembers the locations of the start and the end motions of the g@ command with '[ and '] (for more, check out :h g@). In your case, pressing '[ moves your cursor to the first line because that’s where you started when you ran g@. V is a linewise visual mode command. Finally, '] moves your cursor to the end of the previous changed or yanked text, but in this case, it moves your cursor to the end of your last g@ operation. Finally, y yanks the selected text.\nWhat you just did was yanking the same body of text you performed g@ on.\nIf you look at the other two commands in here:\nlet l:commands = #{line: \"'[V']y\", char: \"`[v`]y\", block: \"`[\\<c-v>`]y\"}\nThey all perform similar actions, except instead of using linewise actions, you would be using characterwise or blockwise actions. I’m going to sound redundant, but in any three cases you are effectively yanking the same body of text you performed g@ on.\nLet’s look at the next line:\nlet l:selected_phrase = getreg('\"')\nThis line gets the content of the unnamed register (\") and stores it inside the variable l:selected_phrase. Wait a minute… didn’t you just yank a body of text? The unnamed register currently contains the text that you had just yanked. This is how this plugin is able to get the copy of the text.\nThe next line is a regular expression pattern:\nlet l:WORD_PATTERN = '\\<\\k*\\>'\n\\< and \\> are word boundary patterns. The character following \\< matches the beginning of a word and the character preceding \\> matches the end of a word. \\k is the keyword pattern. You can check what characters Vim accepts as keywords with :set iskeyword?. Recall that the w motion in Vim moves your cursor word-wise. Vim comes with a pre-conceied notion of what a keyword is (you can even edit them by altering the iskeyword option). Check out :h /\\<, :h /\\>, and :h /\\k, and :h 'iskeyword' for more. Finally, * means zero or more of the subsequent pattern.\nIn the big picture, '\\<\\k*\\>' matches a word. If you have a string:\none two three\nMatching it against the pattern will give you three matches: one, two, and three.\nFinally, you have another pattern:\nlet l:UPCASE_REPLACEMENT = '\\=s:capitalize(submatch(0))'\nRecall that Vim’s substitute command can be used with an expression with \\={your-expression}. For example, if you want to uppercase the string donut in the current line, you can use Vim’s toupper() function. You can achieve this by running :%s/donut/\\=toupper(submatch(0))/g. submatch(0) is a special expression used in the substitute command. It returns the whole matched text.\nThe next two lines:\nlet l:startLine = line(\"'<\")\nlet l:startCol = virtcol(\".\")\nThe line() expression returns a line number. Here you pass it with the mark '<, representing the first line of the last selected visual area. Recall that you used visual mode to yank the text. '< returns the line number of the beginning of that visual area selection. The virtcol() expression returns a column number of the current cursor. You will be moving your cursor all over the place in a little bit, so you need to store your cursor location so you can return here later.\nTake a break here and review everything so far. Make sure you are still following along. When you’re ready, let’s continue."
  },
  {
    "objectID": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#handling-a-block-operation",
    "href": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#handling-a-block-operation",
    "title": "29  Ch29. Write a Plugin: Creating a Titlecase Operator",
    "section": "29.11 Handling a Block Operation",
    "text": "29.11 Handling a Block Operation\nLet’s go through this section:\nif a:type ==# \"block\"\n  sil! keepj norm! gv\"ad\n  keepj $\n  keepj pu_\n\n  let l:lastLine = line(\"$\")\n\n  sil! keepj norm \"ap\n\n  let l:curLine = line(\".\")\n\n  sil! keepj norm! VGg@\n  exe \"keepj norm! 0\\<c-v>G$h\\\"ad\" \n  exe \"keepj \" . l:startLine\n  exe \"sil! keepj norm! \" . l:startCol . \"\\<bar>\\\"aP\"\n  exe \"keepj \" . l:lastLine\n  sil! keepj norm! \"_dG\n  exe \"keepj \" . l:startLine\n  exe \"sil! keepj norm! \" . l:startCol . \"\\<bar>\"\nIt’s time to actually capitalize your text. Recall that you have the a:type to be either char, line, or block. In most cases, you’ll probably be getting char and line. But occasionally you may get a block. It is rare, but it must be addressed nonetheless. Unfortunately, handling a block is not as straight-forward as handling char and line. It will take a little extra effort, but it is doable.\nBefore you start, let’s take an example of how you might get a block. Assume that you have this text:\npancake for breakfast\npancake for lunch\npancake for dinner\nAssume that your cursor is on c on pancake on the first line. You then use the visual block (Ctrl-V) to select down and forward to select the cake in all three lines:\npan[cake] for breakfast\npan[cake] for lunch\npan[cake] for dinner\nWhen you press gt, you want to get:\npanCake for breakfast\npanCake for lunch\npanCake for dinner\n\nHere are your basic assumptions: when you highlight the three cakes in pancakes, you are telling Vim that you have three lines of words that you want to highlight. These words are cake, cake, and cake. You expect to get Cake, Cake, and Cake.\nLet’s move on to the implementation details. The next few lines have:\nsil! keepj norm! gv\"ad\nkeepj $\nkeepj pu_\nlet l:lastLine = line(\"$\")\nsil! keepj norm \"ap\nlet l:curLine = line(\".\")\nThe first line:\nsil! keepj norm! gv\"ad\nRecall that sil! runs silently and keepj keeps the jump history when moving. You then execute the normal command gv\"ad. gv selects the last visually highlighted text (in the pancakes example, it will re-highlight all three cakes). \"ad deletes the visually highlighted texts and stores them in register a. As a result, you now have:\npan for breakfast\npan for lunch\npan for dinner\nNow you have 3 blocks (not lines) of cakes stored in the register a. This distinction is important. Yanking a text with linewise visual mode is different from yanking a text with blockwise visual mode. Keep this in mind because you will see this again later.\nNext you have:\nkeepj $\nkeepj pu_\n$ moves you to the last line in your file. pu_ inserts one line below where your cursor is. You want to run them with keepj so you don’t alter the jump history.\nThen you store the line number of your last line (line(\"$\")) in the local variable lastLine.\nlet l:lastLine = line(\"$\")\nThen paste the content from the register with norm \"ap.\nsil! keepj norm \"ap\nKeep in mind that this is happening on the new line you created below the last line of the file - you are currently at the bottom of the file. Pasting give you these block texts:\ncake\ncake\ncake\nNext, you store the location of the current line where your cursor is.\nlet l:curLine = line(\".\")\nNow let’s go the next few lines:\nsil! keepj norm! VGg@\nexe \"keepj norm! 0\\<c-v>G$h\\\"ad\"\nexe \"keepj \" . l:startLine\nexe \"sil! keepj norm! \" . l:startCol . \"\\<bar>\\\"aP\"\nexe \"keepj \" . l:lastLine\nsil! keepj norm! \"_dG\nexe \"keepj \" . l:startLine\nexe \"sil! keepj norm! \" . l:startCol . \"\\<bar>\"\nThis line:\nsil! keepj norm! VGg@\nVG visually highlights them with line visual mode from the current line to the end of the file. So here you are highlighting the three blocks of cake texts with linewise highlight (recall the block vs line distinction). Note that the first time you pasted the three cake texts, you were pasting them as blocks. Now you are highlighting them as lines. They may look the same from the outside, but internally, Vim knows the difference between pasting blocks of texts and pasting lines of texts.\ncake\ncake\ncake\ng@ is the function operator, so you are essentially doing a recursive call to itself. But why? What does this accomplish?\nYou are making a recursive call to g@ and passing it with all 3 lines (after running it with V, you now have lines, not blocks) of cake texts so it will be handled by the other part of the code (you will go over this later). The result of running g@ is three lines of properly titlecased texts:\nCake\nCake\nCake\nThe next line:\nexe \"keepj norm! 0\\<c-v>G$h\\\"ad\"\nThis runs the normal mode command to go to the beginning of the line (0), use the block visual highlight to go to the last line and last character on that line (<c-v>G$). The h is to adjust the cursor (when doing $ Vim moves one extra line to the right). Finally, you delete the highlighted text and store it in the register a (\"ad).\nThe next line:\nexe \"keepj \" . l:startLine\nYou move your cursor back to where the startLine was.\nNext:\nexe \"sil! keepj norm! \" . l:startCol . \"\\<bar>\\\"aP\"\nBeing in the startLine location, you now jump to the column marked by startCol. \\<bar>\\ is the bar | motion. The bar motion in Vim moves your cursor to the nth column (let’s say the startCol was 4. Running 4| will make your cursor jump to the column position of 4). Recall that you startCol was the location where you stored the column position of the text you wanted to titlecase. Finally, \"aP pastes the texts stored in the register a. This puts the text back to where it was deleted before.\nLet’s look at the next 4 lines:\nexe \"keepj \" . l:lastLine\nsil! keepj norm! \"_dG\nexe \"keepj \" . l:startLine\nexe \"sil! keepj norm! \" . l:startCol . \"\\<bar>\"\nexe \"keepj \" . l:lastLine moves your cursor back to the lastLine location from earlier. sil! keepj norm! \"_dG deletes the extra space(s) that were created using the blackhole register (\"_dG) so your unnamed register stays clean. exe \"keepj \" . l:startLine moves your cursor back to startLine. Finally, exe \"sil! keepj norm! \" . l:startCol . \"\\<bar>\" moves your cursor to the startCol column.\nThese are all the actions you could’ve done manually in Vim. However, the benefit of turning these actions into reusable functions is that they will save you from running 30+ lines of instructions every single time you need to titlecase anything. The take home here is, anything that you can do manually in Vim, you can turn it into a reusable function, hence a plugin!\nHere is what it would look like.\nGiven some text:\npancake for breakfast\npancake for lunch\npancake for dinner\n\n... some text\nFirst, you visually highlight it blockwise:\npan[cake] for breakfast\npan[cake] for lunch\npan[cake] for dinner\n\n... some text\nThen you delete it and store that text in register a:\npan for breakfast\npan for lunch\npan for dinner\n\n... some text\nThen you paste it at the bottom of the file:\npan for breakfast\npan for lunch\npan for dinner\n\n... some text\ncake\ncake\ncake\nThen you capitalize it:\npan for breakfast\npan for lunch\npan for dinner\n\n... some text\nCake\nCake\nCake\nFinally, you put the capitalized text back:\npanCake for breakfast\npanCake for lunch\npanCake for dinner\n\n... some text"
  },
  {
    "objectID": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#handling-line-and-char-operations",
    "href": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#handling-line-and-char-operations",
    "title": "29  Ch29. Write a Plugin: Creating a Titlecase Operator",
    "section": "29.12 Handling Line and Char Operations",
    "text": "29.12 Handling Line and Char Operations\nYou are not done yet. You’ve only addressed the edge case when you run gt on block texts. You still need to handle the line and char operations. Let’s look at the else code to see how tthis is done.\nHere are the codes:\nif a:type ==# \"block\"\n  # ... \nelse\n  let l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')\n  let l:titlecased = s:capitalizeFirstWord(l:titlecased)\n  call setreg('\"', l:titlecased)\n  let l:subcommands = #{line: \"'[V']p\", char: \"`[v`]p\", block: \"`[\\<c-v>`]p\"}\n  silent execute \"noautocmd keepjumps normal! \" .. get(l:subcommands, a:type, \"\")\n  exe \"keepj \" . l:startLine\n  exe \"sil! keepj norm! \" . l:startCol . \"\\<bar>\"\nendif\nLet’s go through them linewise. The secret sauce of this plugin is actually on this line:\nlet l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')\n@@ contains the text from the unnamed register to be titlecased. l:WORD_PATTERN is the individual keyword match. l:UPCASE_REPLACEMENT is the call to the capitalize() command (which you will see later). The 'g' is the global flag that instructs the substitute command to substitute all given words, not just the first word.\nThe next line:\nlet l:titlecased = s:capitalizeFirstWord(l:titlecased)\nThis guarantees that the first word will always be capitalized. If you have a phrase like an apple a day keeps the doctor away, since the first word, an, is a special word, your substitute command won’t capitalize it. You need a a method that always capitalizes the first character no matter what. This function does just that (you will see this function detail later). The result of these capitalization methods is stored in the local variable l:titlecased.\nThe next line:\ncall setreg('\"', l:titlecased)\nThis puts the capitalized string into the unnamed register (\").\nNext, the following two lines:\nlet l:subcommands = #{line: \"'[V']p\", char: \"`[v`]p\", block: \"`[\\<c-v>`]p\"}\nsilent execute \"noautocmd keepjumps normal! \" .. get(l:subcommands, a:type, \"\")\nHey, that looks familiar! You have seen a similar pattern before with l:commands. Instead of yank, here you use paste (p). Check out the previous section where I went over the l:commands for a refresher.\nFinally, these two lines:\nexe \"keepj \" . l:startLine\nexe \"sil! keepj norm! \" . l:startCol . \"\\<bar>\"\nYou are moving your cursor back to the line and column where you started. That’s it!\nLet’s recap. The above substitute method is smart enough to capitalize the given texts and skip the special words (more on this later). After you have a titlecased string, you store them in the unnamed register. Then you visually highlight the exact same text you operated g@ on before, then paste from the unnamed register (this effectively replaces the non-titlecased texts with the titlecased version. Finally, you move your cursor back to where you started."
  },
  {
    "objectID": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#cleanups",
    "href": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#cleanups",
    "title": "29  Ch29. Write a Plugin: Creating a Titlecase Operator",
    "section": "29.13 Cleanups",
    "text": "29.13 Cleanups\nYou are technically done. The texts are now titlecased. All that is left to do is to restore the registers and settings.\ncall setreg('\"', l:reg_save)\ncall setpos(\"'<\", l:visual_marks_save[0])\ncall setpos(\"'>\", l:visual_marks_save[1])\nlet &clipboard = l:cb_save\nlet &selection = l:sel_save\nThese restore: - the unnamed register. - the < and > marks. - the 'clipboard' and 'selection' options.\nPhew, you are done. That was a long function. I could have made the function shorter by breaking it apart into smaller ones, but for now, that will have to suffice. Now let’s briefly go over the capitalize functions."
  },
  {
    "objectID": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#the-capitalize-function",
    "href": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#the-capitalize-function",
    "title": "29  Ch29. Write a Plugin: Creating a Titlecase Operator",
    "section": "29.14 The Capitalize Function",
    "text": "29.14 The Capitalize Function\nIn this section, let’s go over the s:capitalize() function. This is what the function looks like:\nfunction! s:capitalize(string)\n    if(toupper(a:string) ==# a:string && a:string != 'A')\n        return a:string\n    endif\n\n    let l:str = tolower(a:string)\n    let l:exclusions = '^\\(a\\|an\\|and\\|at\\|but\\|by\\|en\\|for\\|in\\|nor\\|of\\|off\\|on\\|or\\|out\\|per\\|so\\|the\\|to\\|up\\|yet\\|v\\.?\\|vs\\.?\\|via\\)$'\n    if (match(l:str, l:exclusions) >= 0) || (index(s:local_exclusion_list, l:str) >= 0)\n      return l:str\n    endif\n\n    return toupper(l:str[0]) . l:str[1:]\nendfunction\nRecall that the argument for the capitalize() function, a:string, is the individual word passed by the g@ operator. So if I am running gt on the text pancake for breakfast, ToTitle will call capitalize(string) three times, once for pancake, once for for, and once for breakfast.\nThe first part of the function is:\nif(toupper(a:string) ==# a:string && a:string != 'A')\n  return a:string\nendif\nThe first condition (toupper(a:string) ==# a:string) checks whether the uppercased version of the argument is the same as the string and whether the string itself is A. If these are true, then return that string. This is based on the assumption that if a given word is already totally uppercased, then it is an abbreviation. For example, the word CEO would otherwise be converted into Ceo. Hmm, your CEO won’t be happy. So it’s best to leave any fully uppercased word alone. The second condition, a:string != 'A', addresses an edge case for a capitalized A character. If a:string is already a capitalized A, it would have accidentally passed the toupper(a:string) ==# a:string test. Because a is an indefinite article in English, it needs to be lowercased.\nThe next part forces the string to be lowercased:\nlet l:str = tolower(a:string)\nThe next part is a regex of a list of all word exclusions. I got them from https://titlecaseconverter.com/rules/ :\nlet l:exclusions = '^\\(a\\|an\\|and\\|at\\|but\\|by\\|en\\|for\\|in\\|nor\\|of\\|off\\|on\\|or\\|out\\|per\\|so\\|the\\|to\\|up\\|yet\\|v\\.?\\|vs\\.?\\|via\\)$'\nThe next part:\nif (match(l:str, l:exclusions) >= 0) || (index(s:local_exclusion_list, l:str) >= 0)\n  return l:str\nendif\nFirst, check if your string is a part of the excluded word list (l:exclusions). If it is, don’t capitalize it. Then check if your string is a part of the local exclusion list (s:local_exclusion_list). This exclusion list is a custom list that the user can add in vimrc (in case the user has additional requirements for special words).\nThe last part returns the capitalized version of the word. The first character is uppercased while the rest remains as is.\nreturn toupper(l:str[0]) . l:str[1:]\nLet’s go over the second capitalize function. The function looks like this:\nfunction! s:capitalizeFirstWord(string)\n  if (a:string =~ \"\\n\")\n    let l:lineArr = trim(a:string)->split('\\n')\n    let l:lineArr = map(l:lineArr, 'toupper(v:val[0]) . v:val[1:]')\n    return l:lineArr->join(\"\\n\")\n  endif\n  return toupper(a:string[0]) . a:string[1:]\nendfunction\nThis function was created to handle an edge case if you have a sentence that starts with an excluded word, like an apple a day keeps the doctor away. Based on English language’s capitalization rules, all first words in a sentence, regardless if it is a special word or not, must be capitalized. With your substitute() command alone, the an in your sentence would be lowercased. You need to force the first character to be uppercased.\nIn this capitalizeFirstWord function, the a:string argument is not an individual word like a:string inside the capitalize function, but instead the whole text. So if you have pancake for breakfast, a:string’s value is pancake for breakfast.it only runs capitalizeFirstWord once for the whole text.\nOne scenario you need to watch out for is if you have a multi-line string like \"an apple a day\\nkeeps the doctor away\". You want to uppercase the first character of all lines. If you don’t have newlines, then simply uppercase the first character.\nreturn toupper(a:string[0]) . a:string[1:]\nIf you have newlines, you need to capitalize all the first characters in each line, so you split them into an array separated by newlines:\nlet l:lineArr = trim(a:string)->split('\\n')\nThen you map each element in the array and capitalize the first word of each element:\nlet l:lineArr = map(l:lineArr, 'toupper(v:val[0]) . v:val[1:]')\nFinally, you put the array elements together:\nreturn l:lineArr->join(\"\\n\")\nAnd you are done!"
  },
  {
    "objectID": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#docs",
    "href": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#docs",
    "title": "29  Ch29. Write a Plugin: Creating a Titlecase Operator",
    "section": "29.15 Docs",
    "text": "29.15 Docs\nThe second directory in the repository is the docs/ directory. It is good to provide the plugin with a thorough documentation. In this section, I’ll briefly go over how to make your own plugin docs.\nThe docs/ directory is one of Vim’s special runtime paths. Vim reads all the files inside the docs/ so when you search for a special keyword and that keyword is found in one of the files in the docs/ directory, it will display it in the help page. Here you have a totitle.txt. I name it that way because that’s the plugin name, but you can name it anything you want.\nA Vim docs file is a txt file at heart. The difference between a regular txt file and a Vim help file is that the latter uses special help syntaxes. But first, you need to tell Vim to treat it not as a text file type, but as a help file type. To tell Vim to interpret this totitle.txt as a help file, run :set ft=help (:h 'filetype' for more). By the way, if you want to tell Vim to interpret this totitle.txt as a regular txt file, run :set ft=txt.\n\n29.15.1 The Help File Special Syntax\nTo make a keyword discoverable, surround that keyword with asterisks. To make the keyword totitle discoverable when user searches for :h totitle, write it as *totitle* in the help file.\nFor example, I have these lines on top of my table of contents:\nTABLE OF CONTENTS                                     *totitle*  *totitle-toc*\n\n// more TOC stuff\nNote that I used two keywords: *totitle* and *totitle-toc* to mark the table of contents section. You can use as many keywords as you want. This means that whenever you search for either :h totitle or :h totitle-toc, Vim takes you to this location.\nHere is another example, somewhere down the file:\n2. Usage                                                       *totitle-usage*\n\n// usage\nIf you search for :h totitle-usage, Vim takes you to this section.\nYou can also use internal links to refer to another section in the help file by surrounding a keyword with the bar syntax |. In the TOC section, you see keywords surrounded by the bars, like |totitle-intro|, |totitle-usage|, etc.\nTABLE OF CONTENTS                                     *totitle*  *totitle-toc*\n\n    1. Intro ........................... |totitle-intro|\n    2. Usage ........................... |totitle-usage|\n    3. Words to capitalize ............. |totitle-words|\n    4. Operator ........................ |totitle-operator|\n    5. Key-binding ..................... |totitle-keybinding|\n    6. Bugs ............................ |totitle-bug-report|\n    7. Contributing .................... |totitle-contributing|\n    8. Credits ......................... |totitle-credits|\n\nThis lets you jump to the definition. If you put your cursor somewhere on |totitle-intro| and press Ctrl-], Vim will jump to the definition of that word. In this case, it will jump to the *totitle-intro* location. This is how you can link to different keywords in a help doc.\nThere is not a right or wrong way to write a doc file in Vim. If you look at different plugins by different authors, many of them use different formats. The point is to make an easy-to-understand help doc for your users.\nFinally, if you are writing your own plugin locally at first and you want to test the documentation page, simply adding a txt file inside the ~/.vim/docs/ won’t automatically make your keywords searchable. You need to instruct Vim to add your doc page. Run the helptags command: :helptags ~/.vim/doc to create new tag files. Now you can start searching for your keywords."
  },
  {
    "objectID": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#conclusion",
    "href": "chapters/ch29_plugin_example_writing-a-titlecase-plugin.md.html#conclusion",
    "title": "29  Ch29. Write a Plugin: Creating a Titlecase Operator",
    "section": "29.16 Conclusion",
    "text": "29.16 Conclusion\nYou made it to the end! This chapter is the amalgamation of all the Vimscript chapters. Here you are finally putting to practice what you’ve learned so far. Hopefully having read this, you understood not only how to create Vim plugins, but also encouraged you to write your own plugin.\nWhenever you find yourself repeating the same sequence of actions multiple times, you should try to create your own! It was said that you shouldn’t reinvent the wheel. However, I think it can be beneficial to reinvent the wheel for the sake of learning. Read other people’s plugins. Recreate them. Learn from them. Write your own! Who knows, maybe you will write the next awesome, super-popular plugin after reading this. Maybe you will be the next legendary Tim Pope. When that happens, let me know!"
  }
]